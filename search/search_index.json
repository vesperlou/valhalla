{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u2588\u2588\u2592 \u2588\u2593 \u2584\u2584\u2584 \u2588\u2588\u2593 \u2588\u2588\u2591 \u2588\u2588 \u2584\u2584\u2584 \u2588\u2588\u2593 \u2588\u2588\u2593 \u2584\u2584\u2584 \u2593\u2588\u2588\u2591 \u2588\u2592\u2592\u2588\u2588\u2588\u2588\u2584 \u2593\u2588\u2588\u2592 \u2593\u2588\u2588\u2591 \u2588\u2588\u2592\u2592\u2588\u2588\u2588\u2588\u2584 \u2593\u2588\u2588\u2592 \u2593\u2588\u2588\u2592 \u2592\u2588\u2588\u2588\u2588\u2584 \u2593\u2588\u2588 \u2588\u2592\u2591\u2592\u2588\u2588 \u2580\u2588\u2584 \u2592\u2588\u2588\u2591 \u2592\u2588\u2588\u2580\u2580\u2588\u2588\u2591\u2592\u2588\u2588 \u2580\u2588\u2584 \u2592\u2588\u2588\u2591 \u2592\u2588\u2588\u2591 \u2592\u2588\u2588 \u2580\u2588\u2584 \u2592\u2588\u2588 \u2588\u2591\u2591\u2591\u2588\u2588\u2584\u2584\u2584\u2584\u2588\u2588 \u2592\u2588\u2588\u2591 \u2591\u2593\u2588 \u2591\u2588\u2588 \u2591\u2588\u2588\u2584\u2584\u2584\u2584\u2588\u2588 \u2592\u2588\u2588\u2591 \u2592\u2588\u2588\u2591 \u2591\u2588\u2588\u2584\u2584\u2584\u2584\u2588\u2588 \u2592\u2580\u2588\u2591 \u2593\u2588 \u2593\u2588\u2588\u2592\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2591\u2593\u2588\u2592\u2591\u2588\u2588\u2593 \u2593\u2588 \u2593\u2588\u2588\u2592\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2593\u2588 \u2593\u2588\u2588\u2592 \u2591 \u2590\u2591 \u2592\u2592 \u2593\u2592\u2588\u2591\u2591 \u2592\u2591\u2593 \u2591 \u2592 \u2591\u2591\u2592\u2591\u2592 \u2592\u2592 \u2593\u2592\u2588\u2591\u2591 \u2592\u2591\u2593 \u2591\u2591 \u2592\u2591\u2593 \u2591\u2592\u2592 \u2593\u2592\u2588\u2591 \u2591 \u2591\u2591 \u2592 \u2592\u2592 \u2591\u2591 \u2591 \u2592 \u2591 \u2592 \u2591\u2592\u2591 \u2591 \u2592 \u2592\u2592 \u2591\u2591 \u2591 \u2592 \u2591\u2591 \u2591 \u2592 \u2591 \u2592 \u2592\u2592 \u2591 \u2591\u2591 \u2591 \u2592 \u2591 \u2591 \u2591 \u2591\u2591 \u2591 \u2591 \u2592 \u2591 \u2591 \u2591 \u2591 \u2591 \u2592 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 Valhalla is an open source routing engine and accompanying libraries for use with OpenStreetMap data. Valhalla also includes tools like time+distance matrix computation, isochrones, elevation sampling, map matching and tour optimization (Travelling Salesman). Build Status \u00b6 Linux/MacOs Windows MinGW64 Code Coverage License \u00b6 Valhalla, and all of the projects under the Valhalla organization, use the MIT License . Avatar/logo by Jordan . OpenStreetMap data in the ./test/data is licensed under ODbL and copyrighted by OSM contributors. Additional information on licenses and other requirements concerning the data sources most frequently used by Valhalla can be found in the docs . Overview \u00b6 There are several key features that we hope can differentiate the Valhalla project from other routing and network analysis engines. They are: Open source software, on open source data with a very liberal license. Should allow for transparency in development, encourage contribution and community input, and foster use in other projects. Tiled hierarchical data structure. Should allow users to have a small memory footprint on memory constrained devices, enable offline routing, provide a means for regional extracts and partial updates. Dynamic, runtime costing of edges and vertices within the graph via a plugin architecture. Should allow for customization and alternate route generation. C++ based API. Should allow for cross compilation of the various pieces to enable routing on offline portable devices. A plugin based narrative and manoeuvre generation architecture. Should allow for generation that is customized either to the administrative area or to the target locale. Multi-modal and time-based routes. Should allow for mixing auto, pedestrian, bike and public transportation in the same route or setting a time by which one must arrive at a location. Demo Server \u00b6 FOSSGIS e.V. hosts a demo server which is open to the public and includes a full planet graph with an open-source web app on https://valhalla.openstreetmap.de. The HTTP API is accessible on a slightly different subdomain, e.g. https://valhalla1.openstreetmap.de/isochrone. Usage of the demo server follows the usual fair-usage policy as OSRM & Nominatim demo servers (somewhat enforced by rate limits ). Platform Compatibility \u00b6 Valhalla is fully functional on many Linux and Mac OS distributions, and is also used on iOS and Android devices. For Windows, not all functionality is fully supported yet. Building the Valhalla library works flawlessly, as well as the following application modules: TOOLS : utilities to query and benchmark various components DATA_TOOLS : utilities to build input data and handle transit PYTHON_BINDINGS : use all actions (route, isochrones, matrix etc) via the Valhalla Python library (needs a full (i.e. development) Python distribution in the PATH ) Organization \u00b6 The Valhalla organization is comprised of several library modules each responsible for a different function. The layout of the various modules is as follows: Midgard - Basic geographic and geometric algorithms for use in the various other projects. Baldr - The base data structures for accessing and caching tiled route data. Sif - Library used in costing of graph nodes and edges. This can be used as input to loki and thor . Skadi - Library and service for accessing elevation data. This can be used as input to mjolnir or as a standalone service. Mjolnir - Tools for turning open data into Valhalla graph tiles. Loki - Library used to search graph tiles and correlate input locations to an entity within a tile. This correlated entity (edge or vertex) can be used as input to thor . Meili - Library used to for map-matching. Thor - Library used to generate a path through the graph tile hierarchy. This path and attribution along the path can be used as input to odin . Odin - Library used to generate manoeuvres and narrative based on a path. This set of directions information can be used as input to tyr . Tyr - Service used to handle http requests for a route communicating with all of the other valhalla APIs. The service will format output from odin and support json (and eventually protocol buffer) output. Tools - A set command line tools that exercise bits of functionality from the library components above and provide the basis for quality testing and performance benchmarking. Demos - A set of demos which allows interacting with the service and APIs. Documentation \u00b6 Documentation is stored in the docs/ folder in this GitHub repository. It can be viewed at valhalla.github.io/valhalla . Installation \u00b6 To run Valhalla locally or your own server, we recommend using our Docker image. Checkout the run-* docker containers here: https://hub.docker.com/r/valhalla/valhalla/tags. Also, there's a community Docker image with more \"magic\" than the native one. If you want to build Valhalla from source, follow the documentation . For more information on binaries, see Command Line Tools section below and the docs . Contributing \u00b6 We contributions to Valhalla. They could be non-technical, e.g. translations into other languages via Transifex or documentation improvements, or technical ones like bug fixes or feature implementations. It's important to open an issue before setting out to work on a PR. Ideally, get familiar with our Contribution guidelines first. Benchmarks \u00b6 Valhalla includes several microbenchmarks which you can build and run using: make benchmarks make run-benchmarks They are enabled by the -DENABLE_BENCHMARKS=On CMake flag and are currently only available for Linux and MacOS. Command Line Tools \u00b6 valhalla_service aka one-shot mode \u00b6 If you can't (e.g. Windows Server) or don't want to have the full-fledged HTTP API running, you can have the (almost) exact same behavior with the 'valhalla_service' executable in so-called \"one-shot\" mode. It's simple, just pass the config file, the action (route, isochrone, matrix etc) and the stringified JSON request (or alternatively a file containing the request to circumvent shell command length issues): valhalla_service valhalla.json isochrone '{\"locations\":[{\"lat\":42.552448,\"lon\":1.564865}],\"costing\":\"auto\",\"contours\":[{\"time\":10,\"color\":\"ff0000\"}], \"show_locations\":true}' # Alternatively you can pass a file with the same contents valhalla_service valhalla.json isochrone isochrone_request.txt It's important to note that all Valhalla logs for one-shot mode are piped to stderr while the actual JSON response will be in stdout . To completely silence the logs, pass type: \"\" to midgard.logging in the config file. Batch Script Tool \u00b6 Batch Run_Route Related projects \u00b6 The following projects are open-source and built with the intention to make it easier to use Valhalla and its features: OpenStreetMapSpeeds : A project conflating open GPS data to improve Valhalla's speed classification. The current JSON is from early 2022 and can be downloaded here and used by setting the path in the mjolnir.default_speeds_config config option. docker-valhalla : An easy-to-use, relatively magical Docker image for Valhalla, which only requires setting a few environment variables in docker-compose.yml to get a full-featured Valhalla instance. valhalla-operator : A k8s operator to deploy and manage Valhalla. valhalla-app : A React based web app for Valhalla, powering https://valhalla.openstreetmap.de/. valhalla-qgis-plugin : A QGIS plugin for Valhalla, also available in the official QGIS plugin store . Note , it's almost deprecated and will be replaced with a much superior alternative. routingpy : A Python client for most open-source routing engines, including Valhalla, with a common interface for all engines. Available on PyPI . routingjs : A TypeScript client for most open-source routing engines, including Valhalla, with a common interface for all engines. Available as engine-specific packages on npm . pyvalhalla : Python bindings for Valhalla, so its APIs can be used from within Python without a HTTP service. Available on PyPI . Valhalla_jll.jl : Valhalla binaries shipped for Julia.","title":"Home"},{"location":"#build-status","text":"Linux/MacOs Windows MinGW64 Code Coverage","title":"Build Status"},{"location":"#license","text":"Valhalla, and all of the projects under the Valhalla organization, use the MIT License . Avatar/logo by Jordan . OpenStreetMap data in the ./test/data is licensed under ODbL and copyrighted by OSM contributors. Additional information on licenses and other requirements concerning the data sources most frequently used by Valhalla can be found in the docs .","title":"License"},{"location":"#overview","text":"There are several key features that we hope can differentiate the Valhalla project from other routing and network analysis engines. They are: Open source software, on open source data with a very liberal license. Should allow for transparency in development, encourage contribution and community input, and foster use in other projects. Tiled hierarchical data structure. Should allow users to have a small memory footprint on memory constrained devices, enable offline routing, provide a means for regional extracts and partial updates. Dynamic, runtime costing of edges and vertices within the graph via a plugin architecture. Should allow for customization and alternate route generation. C++ based API. Should allow for cross compilation of the various pieces to enable routing on offline portable devices. A plugin based narrative and manoeuvre generation architecture. Should allow for generation that is customized either to the administrative area or to the target locale. Multi-modal and time-based routes. Should allow for mixing auto, pedestrian, bike and public transportation in the same route or setting a time by which one must arrive at a location.","title":"Overview"},{"location":"#demo-server","text":"FOSSGIS e.V. hosts a demo server which is open to the public and includes a full planet graph with an open-source web app on https://valhalla.openstreetmap.de. The HTTP API is accessible on a slightly different subdomain, e.g. https://valhalla1.openstreetmap.de/isochrone. Usage of the demo server follows the usual fair-usage policy as OSRM & Nominatim demo servers (somewhat enforced by rate limits ).","title":"Demo Server"},{"location":"#platform-compatibility","text":"Valhalla is fully functional on many Linux and Mac OS distributions, and is also used on iOS and Android devices. For Windows, not all functionality is fully supported yet. Building the Valhalla library works flawlessly, as well as the following application modules: TOOLS : utilities to query and benchmark various components DATA_TOOLS : utilities to build input data and handle transit PYTHON_BINDINGS : use all actions (route, isochrones, matrix etc) via the Valhalla Python library (needs a full (i.e. development) Python distribution in the PATH )","title":"Platform Compatibility"},{"location":"#organization","text":"The Valhalla organization is comprised of several library modules each responsible for a different function. The layout of the various modules is as follows: Midgard - Basic geographic and geometric algorithms for use in the various other projects. Baldr - The base data structures for accessing and caching tiled route data. Sif - Library used in costing of graph nodes and edges. This can be used as input to loki and thor . Skadi - Library and service for accessing elevation data. This can be used as input to mjolnir or as a standalone service. Mjolnir - Tools for turning open data into Valhalla graph tiles. Loki - Library used to search graph tiles and correlate input locations to an entity within a tile. This correlated entity (edge or vertex) can be used as input to thor . Meili - Library used to for map-matching. Thor - Library used to generate a path through the graph tile hierarchy. This path and attribution along the path can be used as input to odin . Odin - Library used to generate manoeuvres and narrative based on a path. This set of directions information can be used as input to tyr . Tyr - Service used to handle http requests for a route communicating with all of the other valhalla APIs. The service will format output from odin and support json (and eventually protocol buffer) output. Tools - A set command line tools that exercise bits of functionality from the library components above and provide the basis for quality testing and performance benchmarking. Demos - A set of demos which allows interacting with the service and APIs.","title":"Organization"},{"location":"#documentation","text":"Documentation is stored in the docs/ folder in this GitHub repository. It can be viewed at valhalla.github.io/valhalla .","title":"Documentation"},{"location":"#installation","text":"To run Valhalla locally or your own server, we recommend using our Docker image. Checkout the run-* docker containers here: https://hub.docker.com/r/valhalla/valhalla/tags. Also, there's a community Docker image with more \"magic\" than the native one. If you want to build Valhalla from source, follow the documentation . For more information on binaries, see Command Line Tools section below and the docs .","title":"Installation"},{"location":"#contributing","text":"We contributions to Valhalla. They could be non-technical, e.g. translations into other languages via Transifex or documentation improvements, or technical ones like bug fixes or feature implementations. It's important to open an issue before setting out to work on a PR. Ideally, get familiar with our Contribution guidelines first.","title":"Contributing"},{"location":"#benchmarks","text":"Valhalla includes several microbenchmarks which you can build and run using: make benchmarks make run-benchmarks They are enabled by the -DENABLE_BENCHMARKS=On CMake flag and are currently only available for Linux and MacOS.","title":"Benchmarks"},{"location":"#command-line-tools","text":"","title":"Command Line Tools"},{"location":"#valhalla_service-aka-one-shot-mode","text":"If you can't (e.g. Windows Server) or don't want to have the full-fledged HTTP API running, you can have the (almost) exact same behavior with the 'valhalla_service' executable in so-called \"one-shot\" mode. It's simple, just pass the config file, the action (route, isochrone, matrix etc) and the stringified JSON request (or alternatively a file containing the request to circumvent shell command length issues): valhalla_service valhalla.json isochrone '{\"locations\":[{\"lat\":42.552448,\"lon\":1.564865}],\"costing\":\"auto\",\"contours\":[{\"time\":10,\"color\":\"ff0000\"}], \"show_locations\":true}' # Alternatively you can pass a file with the same contents valhalla_service valhalla.json isochrone isochrone_request.txt It's important to note that all Valhalla logs for one-shot mode are piped to stderr while the actual JSON response will be in stdout . To completely silence the logs, pass type: \"\" to midgard.logging in the config file.","title":"valhalla_service aka one-shot mode"},{"location":"#batch-script-tool","text":"Batch Run_Route","title":"Batch Script Tool"},{"location":"#related-projects","text":"The following projects are open-source and built with the intention to make it easier to use Valhalla and its features: OpenStreetMapSpeeds : A project conflating open GPS data to improve Valhalla's speed classification. The current JSON is from early 2022 and can be downloaded here and used by setting the path in the mjolnir.default_speeds_config config option. docker-valhalla : An easy-to-use, relatively magical Docker image for Valhalla, which only requires setting a few environment variables in docker-compose.yml to get a full-featured Valhalla instance. valhalla-operator : A k8s operator to deploy and manage Valhalla. valhalla-app : A React based web app for Valhalla, powering https://valhalla.openstreetmap.de/. valhalla-qgis-plugin : A QGIS plugin for Valhalla, also available in the official QGIS plugin store . Note , it's almost deprecated and will be replaced with a much superior alternative. routingpy : A Python client for most open-source routing engines, including Valhalla, with a common interface for all engines. Available on PyPI . routingjs : A TypeScript client for most open-source routing engines, including Valhalla, with a common interface for all engines. Available as engine-specific packages on npm . pyvalhalla : Python bindings for Valhalla, so its APIs can be used from within Python without a HTTP service. Available on PyPI . Valhalla_jll.jl : Valhalla binaries shipped for Julia.","title":"Related projects"},{"location":"baldr/","text":"Baldr \u00b6 Baldr serves as a set of routing-specific data structures for use within other pieces of the valhalla library. In keeping with the Norse mythological theme, the name Baldr was chosen as a backronym standing for: Base ALgorithms and Data Resource. Since baldr deals mostly with accessing routing data and algorithms related to routing subproblems. Baldr is essentially a set of various data structures and alogrithms which deal with things like: route data tiles, tile caching, hierarchical tile layout and tile data members such as nodes, edgeds and exits. Components \u00b6 What follows are some notable components of baldr. GraphId \u00b6 TODO: GraphTileReader \u00b6 TODO:","title":"Baldr (routing data strutures/algorithms)"},{"location":"baldr/#baldr","text":"Baldr serves as a set of routing-specific data structures for use within other pieces of the valhalla library. In keeping with the Norse mythological theme, the name Baldr was chosen as a backronym standing for: Base ALgorithms and Data Resource. Since baldr deals mostly with accessing routing data and algorithms related to routing subproblems. Baldr is essentially a set of various data structures and alogrithms which deal with things like: route data tiles, tile caching, hierarchical tile layout and tile data members such as nodes, edgeds and exits.","title":"Baldr"},{"location":"baldr/#components","text":"What follows are some notable components of baldr.","title":"Components"},{"location":"baldr/#graphid","text":"TODO:","title":"GraphId"},{"location":"baldr/#graphtilereader","text":"TODO:","title":"GraphTileReader"},{"location":"building/","text":"We aim to make Valhalla installable on every half-modern hardware, platform and architecture. If the below instructions are not working for you, we'd be happy if you file an issue or open a PR with a fix . Build Configuration (all platforms) \u00b6 Valhalla uses CMake as build system. When compiling with gcc (GNU Compiler Collection), currently version 5 or newer is supported. Important build options include: Option Behavior -DENABLE_TOOLS ( On / Off ) Build valhalla_service and other utilities (defaults to on) -DENABLE_DATA_TOOLS ( On / Off ) Build the data preprocessing tools (defaults to on) -DENABLE_HTTP ( On / Off ) Build with curl support (defaults to on) -DENABLE_PYTHON_BINDINGS ( On / Off ) Build the python bindings (defaults to on) -DENABLE_SERVICES ( On / Off ) Build the HTTP service (defaults to on) -DENABLE_THREAD_SAFE_TILE_REF_COUNT ( ON / OFF ) If ON uses shared_ptr as tile reference (i.e. it is thread safe, defaults to off) -DENABLE_CCACHE ( On / Off ) Speed up incremental rebuilds via ccache (defaults to on) -DENABLE_BENCHMARKS ( On / Off ) Enable microbenchmarking (defaults to on) -DENABLE_TESTS ( On / Off ) Enable Valhalla tests (defaults to on) -DENABLE_COVERAGE ( On / Off ) Build with coverage instrumentalisation (defaults to off) -DBUILD_SHARED_LIBS ( On / Off ) Build static or shared libraries (defaults to off) -DENABLE_STATIC_LIBRARY_MODULES ( On / Off ) If ON builds Valhalla modules as STATIC library targets (defaults to off) -DENABLE_COMPILER_WARNINGS ( ON / OFF ) Build with common compiler warnings (defaults to off) -DENABLE_SINGLE_FILES_WERROR ( ON / OFF ) Convert compiler warnings to errors for a (growing) selection of files (defaults to on) -DENABLE_WERROR ( ON / OFF ) Treat compiler warnings as errors (defaults to off). Requires -DENABLE_COMPILER_WARNINGS=ON to take effect. -DENABLE_SANITIZERS ( ON / OFF ) Build with all the integrated sanitizers (defaults to off). -DENABLE_ADDRESS_SANITIZER ( ON / OFF ) Build with address sanitizer (defaults to off). -DENABLE_UNDEFINED_SANITIZER ( ON / OFF ) Build with undefined behavior sanitizer (defaults to off). If you're building on Apple Silicon and use the Rosetta terminal (see below), you might need to additionally specify the appropriate options: cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_OSX_ARCHITECTURES=\"x86_64\" Building from Source - Linux \u00b6 To install on a Debian or Ubuntu system you need to install its dependencies with: sudo add-apt-repository -y ppa:valhalla-core/valhalla sudo apt-get update sudo apt-get install -y cmake make libtool pkg-config g++ gcc curl unzip jq lcov protobuf-compiler vim-common locales libcurl4-openssl-dev zlib1g-dev liblz4-dev libprime-server-dev libprotobuf-dev prime-server-bin #if you plan to compile with data building support, see below for more info sudo apt-get install -y libgeos-dev libgeos++-dev libluajit-5.1-dev libspatialite-dev libsqlite3-dev wget sqlite3 spatialite-bin python3-shapely source /etc/lsb-release if [[ $( python3 -c \"print(int( $DISTRIB_RELEASE > 15))\" ) > 0 ]] ; then sudo apt-get install -y libsqlite3-mod-spatialite ; fi #if you plan to compile with python bindings, see below for more info sudo apt-get install -y python-all-dev Now you can build and install Valhalla, e.g. # will build to ./build cmake -B build -DCMAKE_BUILD_TYPE = Release make -C build -j $( nproc ) sudo make -C build install Building from Source - macOS \u00b6 Configuring Rosetta for ARM64 MacBook \u00b6 Check your architecture typing arch in the terminal. In case the result is arm64 set up Rosetta terminal to emulate x86_64 behavior. Otherwise, skip this step. Go to Finder > Application > Utilities . Select Terminal and right-click on it, then choose Duplicate . Rename the duplicated app Rosetta Terminal . Now select Rosetta Terminal application, right-click and choose Get Info . Check the box for Open using Rosetta , then close the Get Info window. Make shure you get i386 after typing arch command in Rosetta Terminal . Now it fully supports Homebrew and other x86_64 command line applications. Install Homebrew in the Rosetta Terminal app and update the aliases. echo \"alias ibrew='arch -x86_64 /usr/local/bin/brew'\" >> ~/.zshrc echo \"alias mbrew='arch -arm64e /opt/homebrew/bin/brew'\" >> ~/.zshrc You will use them to specify the platform when installing a library. Note: use ibrew in Rosetta Terminal to install all dependencies for valhalla and prime_server projects. NOTE: If when installing packages below you get message attempting to link with file built for macOS-arm64 , you can remove already installed packages for arm64 i.e. mbrew uninstall ... . Also, if there are problems with individual packages, you can install them from sources e.g. geos or sqlite . NOTE: It is possible to build Valhalla natively for Apple Silicon, but some dependencies(e.g. LuaJIT) don't have stable versions supporting Apple Silicon and have to be built and installed manually from source. Installing dependencies \u00b6 To install valhalla on macOS, you need to install its dependencies with Homebrew : # install dependencies (automake & czmq are required by prime_server) brew install automake cmake libtool protobuf-c libspatialite pkg-config sqlite3 jq curl wget czmq lz4 spatialite-tools unzip luajit # following packages are needed for running Linux compatible scripts brew install bash coreutils binutils # Update your PATH env variable to include /usr/local/opt/binutils/bin:/usr/local/opt/coreutils/libexec/gnubin Now, clone the Valhalla repository git clone --recurse-submodules https://github.com/valhalla/valhalla.git Then, build prime_server . After getting the dependencies install it with e.g.: # will build to ./build cmake -B build -DCMAKE_BUILD_TYPE = Release make -C build -j $( sysctl -n hw.physicalcpu ) sudo make -C build install Building from Source - Windows \u00b6 It's recommended to work with the following toolset: - Visual Studio with C++ support - Visual Studio Code (easier and lighter to handle) - vcpkg to install packages - CMake Install the following packages with vcpkg and your platform triplet (e.g. x64-windows ). Note, you can remove all packages after zlib in .\\.vcpkg_deps.txt if you don't want to build TOOLS & DATA_TOOLS : # Basic packages git -C C:\\path\\to\\vcpkg checkout f4bd6423 cd C:\\path\\to\\project C:\\path\\to\\vcpkg.exe --triplet x64-windows install \"@.vcpkg_deps.txt\" Let CMake configure the build with the required modules enabled. Note , you have to manually link LuaJIT for some reason, e.g. the final command for x64 could look like \"C:\\Program Files\\CMake\\bin\\cmake.EXE\" --no-warn-unused-cli -DENABLE_TOOLS=ON -DENABLE_DATA_TOOLS=ON -DENABLE_PYTHON_BINDINGS=ON -DENABLE_HTTP=ON -DENABLE_CCACHE=OFF -DENABLE_SERVICES=OFF -DENABLE_BENCHMARKS=OFF -DENABLE_TESTS=OFF -DLUA_LIBRARIES=path\\to\\vcpkg\\installed\\x64-windows\\lib\\lua51.lib -DLUA_INCLUDE_DIR=path\\to\\vcpkg\\installed\\x64-windows\\include\\luajit -DVCPKG_TARGET_TRIPLET=x64-windows -DCMAKE_TOOLCHAIN_FILE=path\\to\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -Hpath/to/project -Bpath/to/project/build -G \"Visual Studio 16 2019\" -T host=x64 -A x64 Run the build for all targets. cd C:\\path\\to\\project cmake -B build . The artifacts will be built to ./build/Release . Running Valhalla server on Unix \u00b6 The following script should be enough to make some routing data and start a server using it. (Note - if you would like to run an elevation lookup service with Valhalla follow the instructions here ). # download some data and make tiles out of it # NOTE: you can feed multiple extracts into pbfgraphbuilder wget http://download.geofabrik.de/europe/switzerland-latest.osm.pbf http://download.geofabrik.de/europe/liechtenstein-latest.osm.pbf # get the config and setup mkdir -p valhalla_tiles valhalla_build_config --mjolnir-tile-dir ${ PWD } /valhalla_tiles --mjolnir-tile-extract ${ PWD } /valhalla_tiles.tar --mjolnir-timezone ${ PWD } /valhalla_tiles/timezones.sqlite --mjolnir-admin ${ PWD } /valhalla_tiles/admins.sqlite > valhalla.json # build timezones.sqlite to support time-dependent routing valhalla_build_timezones > valhalla_tiles/timezones.sqlite # build routing tiles # TODO: run valhalla_build_admins? valhalla_build_tiles -c valhalla.json switzerland-latest.osm.pbf liechtenstein-latest.osm.pbf # tar it up for running the server # either run this to build a tile index for faster graph loading times valhalla_build_extract -c valhalla.json -v # or simply tar up the tiles find valhalla_tiles | sort -n | tar cf valhalla_tiles.tar --no-recursion -T - # grab the demos repo and open up the point and click routing sample git clone --depth = 1 --recurse-submodules --single-branch --branch = gh-pages https://github.com/valhalla/demos.git firefox demos/routing/index-internal.html & # NOTE: set the environment pulldown to 'localhost' to point it at your own server # start up the server valhalla_service valhalla.json 1 # curl it directly if you like: curl http://localhost:8002/route --data '{\"locations\":[{\"lat\":47.365109,\"lon\":8.546824,\"type\":\"break\",\"city\":\"Z\u00fcrich\",\"state\":\"Altstadt\"},{\"lat\":47.108878,\"lon\":8.394801,\"type\":\"break\",\"city\":\"6037 Root\",\"state\":\"Untere Waldstrasse\"}],\"costing\":\"auto\",\"directions_options\":{\"units\":\"miles\"}}' | jq '.' #HAVE FUN!","title":"Build from Source"},{"location":"building/#build-configuration-all-platforms","text":"Valhalla uses CMake as build system. When compiling with gcc (GNU Compiler Collection), currently version 5 or newer is supported. Important build options include: Option Behavior -DENABLE_TOOLS ( On / Off ) Build valhalla_service and other utilities (defaults to on) -DENABLE_DATA_TOOLS ( On / Off ) Build the data preprocessing tools (defaults to on) -DENABLE_HTTP ( On / Off ) Build with curl support (defaults to on) -DENABLE_PYTHON_BINDINGS ( On / Off ) Build the python bindings (defaults to on) -DENABLE_SERVICES ( On / Off ) Build the HTTP service (defaults to on) -DENABLE_THREAD_SAFE_TILE_REF_COUNT ( ON / OFF ) If ON uses shared_ptr as tile reference (i.e. it is thread safe, defaults to off) -DENABLE_CCACHE ( On / Off ) Speed up incremental rebuilds via ccache (defaults to on) -DENABLE_BENCHMARKS ( On / Off ) Enable microbenchmarking (defaults to on) -DENABLE_TESTS ( On / Off ) Enable Valhalla tests (defaults to on) -DENABLE_COVERAGE ( On / Off ) Build with coverage instrumentalisation (defaults to off) -DBUILD_SHARED_LIBS ( On / Off ) Build static or shared libraries (defaults to off) -DENABLE_STATIC_LIBRARY_MODULES ( On / Off ) If ON builds Valhalla modules as STATIC library targets (defaults to off) -DENABLE_COMPILER_WARNINGS ( ON / OFF ) Build with common compiler warnings (defaults to off) -DENABLE_SINGLE_FILES_WERROR ( ON / OFF ) Convert compiler warnings to errors for a (growing) selection of files (defaults to on) -DENABLE_WERROR ( ON / OFF ) Treat compiler warnings as errors (defaults to off). Requires -DENABLE_COMPILER_WARNINGS=ON to take effect. -DENABLE_SANITIZERS ( ON / OFF ) Build with all the integrated sanitizers (defaults to off). -DENABLE_ADDRESS_SANITIZER ( ON / OFF ) Build with address sanitizer (defaults to off). -DENABLE_UNDEFINED_SANITIZER ( ON / OFF ) Build with undefined behavior sanitizer (defaults to off). If you're building on Apple Silicon and use the Rosetta terminal (see below), you might need to additionally specify the appropriate options: cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_OSX_ARCHITECTURES=\"x86_64\"","title":"Build Configuration (all platforms)"},{"location":"building/#building-from-source-linux","text":"To install on a Debian or Ubuntu system you need to install its dependencies with: sudo add-apt-repository -y ppa:valhalla-core/valhalla sudo apt-get update sudo apt-get install -y cmake make libtool pkg-config g++ gcc curl unzip jq lcov protobuf-compiler vim-common locales libcurl4-openssl-dev zlib1g-dev liblz4-dev libprime-server-dev libprotobuf-dev prime-server-bin #if you plan to compile with data building support, see below for more info sudo apt-get install -y libgeos-dev libgeos++-dev libluajit-5.1-dev libspatialite-dev libsqlite3-dev wget sqlite3 spatialite-bin python3-shapely source /etc/lsb-release if [[ $( python3 -c \"print(int( $DISTRIB_RELEASE > 15))\" ) > 0 ]] ; then sudo apt-get install -y libsqlite3-mod-spatialite ; fi #if you plan to compile with python bindings, see below for more info sudo apt-get install -y python-all-dev Now you can build and install Valhalla, e.g. # will build to ./build cmake -B build -DCMAKE_BUILD_TYPE = Release make -C build -j $( nproc ) sudo make -C build install","title":"Building from Source - Linux"},{"location":"building/#building-from-source-macos","text":"","title":"Building from Source - macOS"},{"location":"building/#configuring-rosetta-for-arm64-macbook","text":"Check your architecture typing arch in the terminal. In case the result is arm64 set up Rosetta terminal to emulate x86_64 behavior. Otherwise, skip this step. Go to Finder > Application > Utilities . Select Terminal and right-click on it, then choose Duplicate . Rename the duplicated app Rosetta Terminal . Now select Rosetta Terminal application, right-click and choose Get Info . Check the box for Open using Rosetta , then close the Get Info window. Make shure you get i386 after typing arch command in Rosetta Terminal . Now it fully supports Homebrew and other x86_64 command line applications. Install Homebrew in the Rosetta Terminal app and update the aliases. echo \"alias ibrew='arch -x86_64 /usr/local/bin/brew'\" >> ~/.zshrc echo \"alias mbrew='arch -arm64e /opt/homebrew/bin/brew'\" >> ~/.zshrc You will use them to specify the platform when installing a library. Note: use ibrew in Rosetta Terminal to install all dependencies for valhalla and prime_server projects. NOTE: If when installing packages below you get message attempting to link with file built for macOS-arm64 , you can remove already installed packages for arm64 i.e. mbrew uninstall ... . Also, if there are problems with individual packages, you can install them from sources e.g. geos or sqlite . NOTE: It is possible to build Valhalla natively for Apple Silicon, but some dependencies(e.g. LuaJIT) don't have stable versions supporting Apple Silicon and have to be built and installed manually from source.","title":"Configuring Rosetta for ARM64 MacBook"},{"location":"building/#installing-dependencies","text":"To install valhalla on macOS, you need to install its dependencies with Homebrew : # install dependencies (automake & czmq are required by prime_server) brew install automake cmake libtool protobuf-c libspatialite pkg-config sqlite3 jq curl wget czmq lz4 spatialite-tools unzip luajit # following packages are needed for running Linux compatible scripts brew install bash coreutils binutils # Update your PATH env variable to include /usr/local/opt/binutils/bin:/usr/local/opt/coreutils/libexec/gnubin Now, clone the Valhalla repository git clone --recurse-submodules https://github.com/valhalla/valhalla.git Then, build prime_server . After getting the dependencies install it with e.g.: # will build to ./build cmake -B build -DCMAKE_BUILD_TYPE = Release make -C build -j $( sysctl -n hw.physicalcpu ) sudo make -C build install","title":"Installing dependencies"},{"location":"building/#building-from-source-windows","text":"It's recommended to work with the following toolset: - Visual Studio with C++ support - Visual Studio Code (easier and lighter to handle) - vcpkg to install packages - CMake Install the following packages with vcpkg and your platform triplet (e.g. x64-windows ). Note, you can remove all packages after zlib in .\\.vcpkg_deps.txt if you don't want to build TOOLS & DATA_TOOLS : # Basic packages git -C C:\\path\\to\\vcpkg checkout f4bd6423 cd C:\\path\\to\\project C:\\path\\to\\vcpkg.exe --triplet x64-windows install \"@.vcpkg_deps.txt\" Let CMake configure the build with the required modules enabled. Note , you have to manually link LuaJIT for some reason, e.g. the final command for x64 could look like \"C:\\Program Files\\CMake\\bin\\cmake.EXE\" --no-warn-unused-cli -DENABLE_TOOLS=ON -DENABLE_DATA_TOOLS=ON -DENABLE_PYTHON_BINDINGS=ON -DENABLE_HTTP=ON -DENABLE_CCACHE=OFF -DENABLE_SERVICES=OFF -DENABLE_BENCHMARKS=OFF -DENABLE_TESTS=OFF -DLUA_LIBRARIES=path\\to\\vcpkg\\installed\\x64-windows\\lib\\lua51.lib -DLUA_INCLUDE_DIR=path\\to\\vcpkg\\installed\\x64-windows\\include\\luajit -DVCPKG_TARGET_TRIPLET=x64-windows -DCMAKE_TOOLCHAIN_FILE=path\\to\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -Hpath/to/project -Bpath/to/project/build -G \"Visual Studio 16 2019\" -T host=x64 -A x64 Run the build for all targets. cd C:\\path\\to\\project cmake -B build . The artifacts will be built to ./build/Release .","title":"Building from Source - Windows"},{"location":"building/#running-valhalla-server-on-unix","text":"The following script should be enough to make some routing data and start a server using it. (Note - if you would like to run an elevation lookup service with Valhalla follow the instructions here ). # download some data and make tiles out of it # NOTE: you can feed multiple extracts into pbfgraphbuilder wget http://download.geofabrik.de/europe/switzerland-latest.osm.pbf http://download.geofabrik.de/europe/liechtenstein-latest.osm.pbf # get the config and setup mkdir -p valhalla_tiles valhalla_build_config --mjolnir-tile-dir ${ PWD } /valhalla_tiles --mjolnir-tile-extract ${ PWD } /valhalla_tiles.tar --mjolnir-timezone ${ PWD } /valhalla_tiles/timezones.sqlite --mjolnir-admin ${ PWD } /valhalla_tiles/admins.sqlite > valhalla.json # build timezones.sqlite to support time-dependent routing valhalla_build_timezones > valhalla_tiles/timezones.sqlite # build routing tiles # TODO: run valhalla_build_admins? valhalla_build_tiles -c valhalla.json switzerland-latest.osm.pbf liechtenstein-latest.osm.pbf # tar it up for running the server # either run this to build a tile index for faster graph loading times valhalla_build_extract -c valhalla.json -v # or simply tar up the tiles find valhalla_tiles | sort -n | tar cf valhalla_tiles.tar --no-recursion -T - # grab the demos repo and open up the point and click routing sample git clone --depth = 1 --recurse-submodules --single-branch --branch = gh-pages https://github.com/valhalla/demos.git firefox demos/routing/index-internal.html & # NOTE: set the environment pulldown to 'localhost' to point it at your own server # start up the server valhalla_service valhalla.json 1 # curl it directly if you like: curl http://localhost:8002/route --data '{\"locations\":[{\"lat\":47.365109,\"lon\":8.546824,\"type\":\"break\",\"city\":\"Z\u00fcrich\",\"state\":\"Altstadt\"},{\"lat\":47.108878,\"lon\":8.394801,\"type\":\"break\",\"city\":\"6037 Root\",\"state\":\"Untere Waldstrasse\"}],\"costing\":\"auto\",\"directions_options\":{\"units\":\"miles\"}}' | jq '.' #HAVE FUN!","title":"Running Valhalla server on Unix"},{"location":"decoding/","text":"Decode a route shape \u00b6 Valhalla routing, map-matching, and elevation services use an encoded polyline format to store a series of latitude, longitude coordinates as a single string. Polyline encoding greatly reduces the size of the route response or map-matching request, especially for longer routes or GPS traces. A description is found here: polyline encoding . Note: Valhalla APIs use six digits of decimal precision. It is very important that you use six digits, rather than five as referenced in the Google algorithms documentation. With fewer than six digits, your locations are incorrectly placed (commonly, in the middle of an ocean), and you may receive errors with your API requests. Below are some sample algorithms to decode the string to create a list of latitude,longitude coordinates. Using this demo tool , you can also paste an encoded polyline string, decode it, and see the locations on a map (and save to GeoJSON). Use it to test and verify that your points are placed where you expected them. JavaScript \u00b6 Here is an example of decoding in JavaScript. // This is adapted from the implementation in Project-OSRM // https://github.com/DennisOSRM/Project-OSRM-Web/blob/master/WebContent/routing/OSRM.RoutingGeometry.js polyline . decode = function ( str , precision ) { var index = 0 , lat = 0 , lng = 0 , coordinates = [], shift = 0 , result = 0 , byte = null , latitude_change , longitude_change , factor = Math . pow ( 10 , precision || 6 ); // Coordinates have variable length when encoded, so just keep // track of whether we've hit the end of the string. In each // loop iteration, a single coordinate is decoded. while ( index < str . length ) { // Reset shift, result, and byte byte = null ; shift = 0 ; result = 0 ; do { byte = str . charCodeAt ( index ++ ) - 63 ; result |= ( byte & 0x1f ) << shift ; shift += 5 ; } while ( byte >= 0x20 ); latitude_change = (( result & 1 ) ? ~ ( result >> 1 ) : ( result >> 1 )); shift = result = 0 ; do { byte = str . charCodeAt ( index ++ ) - 63 ; result |= ( byte & 0x1f ) << shift ; shift += 5 ; } while ( byte >= 0x20 ); longitude_change = (( result & 1 ) ? ~ ( result >> 1 ) : ( result >> 1 )); lat += latitude_change ; lng += longitude_change ; coordinates . push ([ lat / factor , lng / factor ]); } return coordinates ; }; C++ 11 \u00b6 Here is an example of decoding in C++11 #include <vector> constexpr double kPolylinePrecision = 1E6 ; constexpr double kInvPolylinePrecision = 1.0 / kPolylinePrecision ; struct PointLL { float lat ; float lon ; }; std :: vector < PointLL > decode ( const std :: string & encoded ) { size_t i = 0 ; // what byte are we looking at // Handy lambda to turn a few bytes of an encoded string into an integer auto deserialize = [ & encoded , & i ]( const int previous ) { // Grab each 5 bits and mask it in where it belongs using the shift int byte , shift = 0 , result = 0 ; do { byte = static_cast < int > ( encoded [ i ++ ]) - 63 ; result |= ( byte & 0x1f ) << shift ; shift += 5 ; } while ( byte >= 0x20 ); // Undo the left shift from above or the bit flipping and add to previous // since its an offset return previous + ( result & 1 ? ~ ( result >> 1 ) : ( result >> 1 )); }; // Iterate over all characters in the encoded string std :: vector < PointLL > shape ; int last_lon = 0 , last_lat = 0 ; while ( i < encoded . length ()) { // Decode the coordinates, lat first for some reason int lat = deserialize ( last_lat ); int lon = deserialize ( last_lon ); // Shift the decimal point 5 places to the left shape . emplace_back ( static_cast < float > ( static_cast < double > ( lat ) * kInvPolylinePrecision ), static_cast < float > ( static_cast < double > ( lon ) * kInvPolylinePrecision )); // Remember the last one we encountered last_lon = lon ; last_lat = lat ; } return shape ; } Python \u00b6 Here is an example of decoding in Python #!/usr/bin/env python import sys #six degrees of precision in valhalla inv = 1.0 / 1e6 ; #decode an encoded string def decode ( encoded ): decoded = [] previous = [ 0 , 0 ] i = 0 #for each byte while i < len ( encoded ): #for each coord (lat, lon) ll = [ 0 , 0 ] for j in [ 0 , 1 ]: shift = 0 byte = 0x20 #keep decoding bytes until you have this coord while byte >= 0x20 : byte = ord ( encoded [ i ]) - 63 i += 1 ll [ j ] |= ( byte & 0x1f ) << shift shift += 5 #get the final value adding the previous offset and remember it for the next ll [ j ] = previous [ j ] + ( ~ ( ll [ j ] >> 1 ) if ll [ j ] & 1 else ( ll [ j ] >> 1 )) previous [ j ] = ll [ j ] #scale by the precision and chop off long coords also flip the positions so #its the far more standard lon,lat instead of lat,lon decoded . append ([ float ( ' %.6f ' % ( ll [ 1 ] * inv )), float ( ' %.6f ' % ( ll [ 0 ] * inv ))]) #hand back the list of coordinates return decoded print ( decode ( sys . argv [ 1 ])) R \u00b6 Here is an example of decoding in R. library ( tidyverse ) decode <- function ( encoded ) { chars <- stringr :: str_split ( encoded , \"\" )[[ 1 ]] lats <- vector ( mode = \"integer\" , length = 1 ) lons <- vector ( mode = \"integer\" , length = 1 ) i <- 0 while ( i < length ( chars )){ shift <- 0 result <- 0 byte <- 0x20L while ( byte >= 0x20 ) { i <- i + 1 byte <- chars [[ i ]] %>% utf8ToInt () - 63 result <- bitwOr ( result , bitwAnd ( byte , 0x1f ) %>% bitwShiftL ( shift )) shift <- shift + 5 if ( byte < 0x20 ) break } if ( bitwAnd ( result , 1 )) { result <- result %>% bitwShiftR ( 1 ) %>% bitwNot () } else { result <- result %>% bitwShiftR ( 1 ) } lats <- c ( lats , ( lats [[ length ( lats )]] + result )) shift <- 0 result <- 0 byte <- 10000L while ( byte >= 0x20 ) { i <- i + 1 byte <- chars [[ i ]] %>% utf8ToInt () - 63 result <- bitwOr ( result , bitwAnd ( byte , 0x1f ) %>% bitwShiftL ( shift )) shift <- shift + 5 if ( byte < 0x20 ) break } if ( bitwAnd ( result , 1 )) { result <- result %>% bitwShiftR ( 1 ) %>% bitwNot () } else { result <- result %>% bitwShiftR ( 1 ) } lons <- c ( lons , ( lons [[ length ( lons )]] + result )) } decoded <- tibble :: tibble ( lat = lats [ 2 : length ( lats )] / 1000000 , lng = lons [ 2 : length ( lons )] / 1000000 ) return ( decoded ) } Go \u00b6 func decodePolyline ( encoded * string , precisionOptional ... int ) [][] float64 { // default to 6 digits of precision precision := 6 if len ( precisionOptional ) > 0 { precision = precisionOptional [ 0 ] } factor := math . Pow10 ( precision ) // Coordinates have variable length when encoded, so just keep // track of whether we've hit the end of the string. In each // loop iteration, a single coordinate is decoded. lat , lng := 0 , 0 var coordinates [][] float64 index := 0 for index < len ( * encoded ) { // Consume varint bits for lat until we run out var byte int = 0x20 shift , result := 0 , 0 for byte >= 0x20 { byte = int (( * encoded )[ index ]) - 63 result |= ( byte & 0x1f ) << shift shift += 5 index ++ } // check if we need to go negative or not if ( result & 1 ) > 0 { lat += ^( result >> 1 ) } else { lat += result >> 1 } // Consume varint bits for lng until we run out byte = 0x20 shift , result = 0 , 0 for byte >= 0x20 { byte = int (( * encoded )[ index ]) - 63 result |= ( byte & 0x1f ) << shift shift += 5 index ++ } // check if we need to go negative or not if ( result & 1 ) > 0 { lng += ^( result >> 1 ) } else { lng += result >> 1 } // scale the int back to floating point and store it coordinates = append ( coordinates , [] float64 { float64 ( lat ) / factor , float64 ( lng ) / factor }) } return coordinates }","title":"Decoding shape"},{"location":"decoding/#decode-a-route-shape","text":"Valhalla routing, map-matching, and elevation services use an encoded polyline format to store a series of latitude, longitude coordinates as a single string. Polyline encoding greatly reduces the size of the route response or map-matching request, especially for longer routes or GPS traces. A description is found here: polyline encoding . Note: Valhalla APIs use six digits of decimal precision. It is very important that you use six digits, rather than five as referenced in the Google algorithms documentation. With fewer than six digits, your locations are incorrectly placed (commonly, in the middle of an ocean), and you may receive errors with your API requests. Below are some sample algorithms to decode the string to create a list of latitude,longitude coordinates. Using this demo tool , you can also paste an encoded polyline string, decode it, and see the locations on a map (and save to GeoJSON). Use it to test and verify that your points are placed where you expected them.","title":"Decode a route shape"},{"location":"decoding/#javascript","text":"Here is an example of decoding in JavaScript. // This is adapted from the implementation in Project-OSRM // https://github.com/DennisOSRM/Project-OSRM-Web/blob/master/WebContent/routing/OSRM.RoutingGeometry.js polyline . decode = function ( str , precision ) { var index = 0 , lat = 0 , lng = 0 , coordinates = [], shift = 0 , result = 0 , byte = null , latitude_change , longitude_change , factor = Math . pow ( 10 , precision || 6 ); // Coordinates have variable length when encoded, so just keep // track of whether we've hit the end of the string. In each // loop iteration, a single coordinate is decoded. while ( index < str . length ) { // Reset shift, result, and byte byte = null ; shift = 0 ; result = 0 ; do { byte = str . charCodeAt ( index ++ ) - 63 ; result |= ( byte & 0x1f ) << shift ; shift += 5 ; } while ( byte >= 0x20 ); latitude_change = (( result & 1 ) ? ~ ( result >> 1 ) : ( result >> 1 )); shift = result = 0 ; do { byte = str . charCodeAt ( index ++ ) - 63 ; result |= ( byte & 0x1f ) << shift ; shift += 5 ; } while ( byte >= 0x20 ); longitude_change = (( result & 1 ) ? ~ ( result >> 1 ) : ( result >> 1 )); lat += latitude_change ; lng += longitude_change ; coordinates . push ([ lat / factor , lng / factor ]); } return coordinates ; };","title":"JavaScript"},{"location":"decoding/#c-11","text":"Here is an example of decoding in C++11 #include <vector> constexpr double kPolylinePrecision = 1E6 ; constexpr double kInvPolylinePrecision = 1.0 / kPolylinePrecision ; struct PointLL { float lat ; float lon ; }; std :: vector < PointLL > decode ( const std :: string & encoded ) { size_t i = 0 ; // what byte are we looking at // Handy lambda to turn a few bytes of an encoded string into an integer auto deserialize = [ & encoded , & i ]( const int previous ) { // Grab each 5 bits and mask it in where it belongs using the shift int byte , shift = 0 , result = 0 ; do { byte = static_cast < int > ( encoded [ i ++ ]) - 63 ; result |= ( byte & 0x1f ) << shift ; shift += 5 ; } while ( byte >= 0x20 ); // Undo the left shift from above or the bit flipping and add to previous // since its an offset return previous + ( result & 1 ? ~ ( result >> 1 ) : ( result >> 1 )); }; // Iterate over all characters in the encoded string std :: vector < PointLL > shape ; int last_lon = 0 , last_lat = 0 ; while ( i < encoded . length ()) { // Decode the coordinates, lat first for some reason int lat = deserialize ( last_lat ); int lon = deserialize ( last_lon ); // Shift the decimal point 5 places to the left shape . emplace_back ( static_cast < float > ( static_cast < double > ( lat ) * kInvPolylinePrecision ), static_cast < float > ( static_cast < double > ( lon ) * kInvPolylinePrecision )); // Remember the last one we encountered last_lon = lon ; last_lat = lat ; } return shape ; }","title":"C++ 11"},{"location":"decoding/#python","text":"Here is an example of decoding in Python #!/usr/bin/env python import sys #six degrees of precision in valhalla inv = 1.0 / 1e6 ; #decode an encoded string def decode ( encoded ): decoded = [] previous = [ 0 , 0 ] i = 0 #for each byte while i < len ( encoded ): #for each coord (lat, lon) ll = [ 0 , 0 ] for j in [ 0 , 1 ]: shift = 0 byte = 0x20 #keep decoding bytes until you have this coord while byte >= 0x20 : byte = ord ( encoded [ i ]) - 63 i += 1 ll [ j ] |= ( byte & 0x1f ) << shift shift += 5 #get the final value adding the previous offset and remember it for the next ll [ j ] = previous [ j ] + ( ~ ( ll [ j ] >> 1 ) if ll [ j ] & 1 else ( ll [ j ] >> 1 )) previous [ j ] = ll [ j ] #scale by the precision and chop off long coords also flip the positions so #its the far more standard lon,lat instead of lat,lon decoded . append ([ float ( ' %.6f ' % ( ll [ 1 ] * inv )), float ( ' %.6f ' % ( ll [ 0 ] * inv ))]) #hand back the list of coordinates return decoded print ( decode ( sys . argv [ 1 ]))","title":"Python"},{"location":"decoding/#r","text":"Here is an example of decoding in R. library ( tidyverse ) decode <- function ( encoded ) { chars <- stringr :: str_split ( encoded , \"\" )[[ 1 ]] lats <- vector ( mode = \"integer\" , length = 1 ) lons <- vector ( mode = \"integer\" , length = 1 ) i <- 0 while ( i < length ( chars )){ shift <- 0 result <- 0 byte <- 0x20L while ( byte >= 0x20 ) { i <- i + 1 byte <- chars [[ i ]] %>% utf8ToInt () - 63 result <- bitwOr ( result , bitwAnd ( byte , 0x1f ) %>% bitwShiftL ( shift )) shift <- shift + 5 if ( byte < 0x20 ) break } if ( bitwAnd ( result , 1 )) { result <- result %>% bitwShiftR ( 1 ) %>% bitwNot () } else { result <- result %>% bitwShiftR ( 1 ) } lats <- c ( lats , ( lats [[ length ( lats )]] + result )) shift <- 0 result <- 0 byte <- 10000L while ( byte >= 0x20 ) { i <- i + 1 byte <- chars [[ i ]] %>% utf8ToInt () - 63 result <- bitwOr ( result , bitwAnd ( byte , 0x1f ) %>% bitwShiftL ( shift )) shift <- shift + 5 if ( byte < 0x20 ) break } if ( bitwAnd ( result , 1 )) { result <- result %>% bitwShiftR ( 1 ) %>% bitwNot () } else { result <- result %>% bitwShiftR ( 1 ) } lons <- c ( lons , ( lons [[ length ( lons )]] + result )) } decoded <- tibble :: tibble ( lat = lats [ 2 : length ( lats )] / 1000000 , lng = lons [ 2 : length ( lons )] / 1000000 ) return ( decoded ) }","title":"R"},{"location":"decoding/#go","text":"func decodePolyline ( encoded * string , precisionOptional ... int ) [][] float64 { // default to 6 digits of precision precision := 6 if len ( precisionOptional ) > 0 { precision = precisionOptional [ 0 ] } factor := math . Pow10 ( precision ) // Coordinates have variable length when encoded, so just keep // track of whether we've hit the end of the string. In each // loop iteration, a single coordinate is decoded. lat , lng := 0 , 0 var coordinates [][] float64 index := 0 for index < len ( * encoded ) { // Consume varint bits for lat until we run out var byte int = 0x20 shift , result := 0 , 0 for byte >= 0x20 { byte = int (( * encoded )[ index ]) - 63 result |= ( byte & 0x1f ) << shift shift += 5 index ++ } // check if we need to go negative or not if ( result & 1 ) > 0 { lat += ^( result >> 1 ) } else { lat += result >> 1 } // Consume varint bits for lng until we run out byte = 0x20 shift , result = 0 , 0 for byte >= 0x20 { byte = int (( * encoded )[ index ]) - 63 result |= ( byte & 0x1f ) << shift shift += 5 index ++ } // check if we need to go negative or not if ( result & 1 ) > 0 { lng += ^( result >> 1 ) } else { lng += result >> 1 } // scale the int back to floating point and store it coordinates = append ( coordinates , [] float64 { float64 ( lat ) / factor , float64 ( lng ) / factor }) } return coordinates }","title":"Go"},{"location":"elevation/","text":"Elevation Lookup Service \u00b6 This document describes how to run an elevation lookup service using Valhalla. Documentation for querying this service can be found here: elevation-api-docdocs . Running \u00b6 The easiest way to start an elevation service is to run valhalla via Docker, download elevation data, and start the service. Or you can build Valhalla from source. See the main README for installation instructions. The following bash should be enough to make some get some elevation data and start a server using it: # Be sure that the parallel and curl dependencies are installed sudo apt-get install parallel sudo apt-get install curl # grab data for the whole world (it's about 1.6TB) or a smaller bounding box valhalla_build_elevation -180 180 -90 90 ./elevation_tiles $( nproc ) #configure the server valhalla_build_config --additional-data-elevation ./elevation_tiles > config.json #start up the server with the config and number of threads valhalla_service config.json 1 #curl it directly if you like: curl http://localhost:8002/height --data '{\"range\":true,\"shape\":[{\"lat\":40.712431,\"lon\":-76.504916},{\"lat\":40.712275,\"lon\":-76.605259},{\"lat\":40.712122,\"lon\":-76.805694},{\"lat\":40.722431,\"lon\":-76.884916},{\"lat\":40.812275,\"lon\":-76.905259},{\"lat\":40.912122,\"lon\":-76.965694}]' | jq '.' #HAVE FUN! See Also \u00b6 API docs for /height endpoint Skadi module for working with digital elevation model (DEM) data Terrain tiles for download from Amazon Web Services Public Datasets program","title":"Elevation Lookup Service"},{"location":"elevation/#elevation-lookup-service","text":"This document describes how to run an elevation lookup service using Valhalla. Documentation for querying this service can be found here: elevation-api-docdocs .","title":"Elevation Lookup Service"},{"location":"elevation/#running","text":"The easiest way to start an elevation service is to run valhalla via Docker, download elevation data, and start the service. Or you can build Valhalla from source. See the main README for installation instructions. The following bash should be enough to make some get some elevation data and start a server using it: # Be sure that the parallel and curl dependencies are installed sudo apt-get install parallel sudo apt-get install curl # grab data for the whole world (it's about 1.6TB) or a smaller bounding box valhalla_build_elevation -180 180 -90 90 ./elevation_tiles $( nproc ) #configure the server valhalla_build_config --additional-data-elevation ./elevation_tiles > config.json #start up the server with the config and number of threads valhalla_service config.json 1 #curl it directly if you like: curl http://localhost:8002/height --data '{\"range\":true,\"shape\":[{\"lat\":40.712431,\"lon\":-76.504916},{\"lat\":40.712275,\"lon\":-76.605259},{\"lat\":40.712122,\"lon\":-76.805694},{\"lat\":40.722431,\"lon\":-76.884916},{\"lat\":40.812275,\"lon\":-76.905259},{\"lat\":40.912122,\"lon\":-76.965694}]' | jq '.' #HAVE FUN!","title":"Running"},{"location":"elevation/#see-also","text":"API docs for /height endpoint Skadi module for working with digital elevation model (DEM) data Terrain tiles for download from Amazon Web Services Public Datasets program","title":"See Also"},{"location":"incidents/","text":"Incidents \u00b6 Valhalla supports loading incidents in the form of pbf format valhalla-shaped tiles. That means that we have a proto definition which describes the tile format in such a way that code can be generated to access the data but also that the geograph area a tile covers matches those of the tiles that are natively supported in valhalla. Very briefly, the incident format has a vector of incident locations objects each of which specify the location along an edge in the corresponding graph tile where the incident occurs (begins/ends). There is also a vector of metadata which is indexed by the incident location information. Here's some pseudo code to give you the gist: struct incident_tile { struct locations { uint32_t edge_index ; // the index of the edge in the corresponding graph tile float start_pct ; // the percent along the edge the incident starts float end_pct ; // the percent along the edge the incident ends size_t metadata_index ; // the index into the metadata vector describing the incident }; struct metadata { enum struct event_type : uint8_t { CONSTRUCTION = 0 , // ... many more }; std :: string description ; //... many more see the proto file }; // locations of incidents along edges, sorted by edge id std :: vector < location > locations ; // metadata to go along with each incident std :: vector < metadata > metadatas ; }; Runtime support \u00b6 If your request enables the incidents attribute filter and both incident tiles are available and the library is configured to use them, then incidents along paths will be attached to TripLeg s as they are created. These are then serialized into json as their own top level object. Tile access \u00b6 Much like graph tile, incident tiles are loaded from a configured directory. Since the tiles are not fixed size (protobuf and unknown number of incidens per tile) the idea here is that we will need to continually refresh the tiles from the directory. There are a couple of assumptions that we are making: its unlikely that incidents change frequently its unlikely that there are large numbers of incidents incidents will not affect routing algorithms computations The graphreader will then call a singleton whose job it is to give access to the available incident tiles from the directory. Access is used in triplegbuilder to associate incidents to the pbf route leg. The way these incidents are accessed is via binary search to find the corresponding incident for the edge index. We also mark a bit in the speed record for the edge to say that a given edge should have an incident. Upon seeing this bit set to true in the graphreader we will go look up the incident from the incident tile via the singleton. How are incidents refreshed \u00b6 This deserves an explanation because its the trickier part. The model we use here is a class with a private constructor and one public static function. That function statically initializes a singleton instance of this class. The class's constructor spawns a thread that runs in the background. That thread is responsible for monitoring the filesystem for new incidents. When the thread is first started, the singleton waits for it to initialize (load all the incidents that are available). The thread and the singleton instance communicate over the thread barrier by sharing a state object. The bulk of communications use atomic booleans (which are hopefully lock free on most implementations). You'll notice a mutex in there as well. The mutex is only used for synchronization of the tile cache, which is an unordered_map . Synchronization is needed because the unordered_map may reallocate when new tiles are added to it. Thus this synchronization is also conditional. When the tileset is static, ie. when its a memory mapped tar, we do not need to use the mutex to synchronize and instead preallocate all the slots needed for the cache. The state object shared between the threads is wrapped in a shared_ptr , from the code comments: // we use a shared_ptr to wrap the state between the watcher thread and the main threads singleton // instance. this gives the responsibility to the last living thread to deallocate the state object. // if we didn't do this, and the watcher thread were still running when the singleton instance got // destructed, then the watcher would be making use of a deallocated state object. this way, if the // watcher is last to die it owns the lifetime of the state and if the singleton is the last to die // it owns the lifetime of the state. note that we still need to use atomics inside the state as // only the shared_ptr itself is thread safe, not the thing it points to There are two modes for the incident loading singleton, one which does directory scans ( mjolnir.incident_dir in the config), which on a modern ssd where changes are happening to the incident directory, takes 15 seconds for a planets worth of incident tiles. The second mode is a memory mapped log file which tells the timestamp when an incident tile was last changed rather than using mtime of the files on the filesystem. This can be configured with the mjolnir.incident_log config option and takes generally subsecond on modern ssds to complete for updates since it doesnt need to scan the whole directory. Since there is only one thread (per process) who is in charge of updating incidents we need to be worried about the health of this thread. There is one other configuration options to do with the healthiness of this thread. This config option is called mjolnir.max_incident_loading_latency and controls how long a round of incident updates can take before we log an error that the update was latent.","title":"Incidents"},{"location":"incidents/#incidents","text":"Valhalla supports loading incidents in the form of pbf format valhalla-shaped tiles. That means that we have a proto definition which describes the tile format in such a way that code can be generated to access the data but also that the geograph area a tile covers matches those of the tiles that are natively supported in valhalla. Very briefly, the incident format has a vector of incident locations objects each of which specify the location along an edge in the corresponding graph tile where the incident occurs (begins/ends). There is also a vector of metadata which is indexed by the incident location information. Here's some pseudo code to give you the gist: struct incident_tile { struct locations { uint32_t edge_index ; // the index of the edge in the corresponding graph tile float start_pct ; // the percent along the edge the incident starts float end_pct ; // the percent along the edge the incident ends size_t metadata_index ; // the index into the metadata vector describing the incident }; struct metadata { enum struct event_type : uint8_t { CONSTRUCTION = 0 , // ... many more }; std :: string description ; //... many more see the proto file }; // locations of incidents along edges, sorted by edge id std :: vector < location > locations ; // metadata to go along with each incident std :: vector < metadata > metadatas ; };","title":"Incidents"},{"location":"incidents/#runtime-support","text":"If your request enables the incidents attribute filter and both incident tiles are available and the library is configured to use them, then incidents along paths will be attached to TripLeg s as they are created. These are then serialized into json as their own top level object.","title":"Runtime support"},{"location":"incidents/#tile-access","text":"Much like graph tile, incident tiles are loaded from a configured directory. Since the tiles are not fixed size (protobuf and unknown number of incidens per tile) the idea here is that we will need to continually refresh the tiles from the directory. There are a couple of assumptions that we are making: its unlikely that incidents change frequently its unlikely that there are large numbers of incidents incidents will not affect routing algorithms computations The graphreader will then call a singleton whose job it is to give access to the available incident tiles from the directory. Access is used in triplegbuilder to associate incidents to the pbf route leg. The way these incidents are accessed is via binary search to find the corresponding incident for the edge index. We also mark a bit in the speed record for the edge to say that a given edge should have an incident. Upon seeing this bit set to true in the graphreader we will go look up the incident from the incident tile via the singleton.","title":"Tile access"},{"location":"incidents/#how-are-incidents-refreshed","text":"This deserves an explanation because its the trickier part. The model we use here is a class with a private constructor and one public static function. That function statically initializes a singleton instance of this class. The class's constructor spawns a thread that runs in the background. That thread is responsible for monitoring the filesystem for new incidents. When the thread is first started, the singleton waits for it to initialize (load all the incidents that are available). The thread and the singleton instance communicate over the thread barrier by sharing a state object. The bulk of communications use atomic booleans (which are hopefully lock free on most implementations). You'll notice a mutex in there as well. The mutex is only used for synchronization of the tile cache, which is an unordered_map . Synchronization is needed because the unordered_map may reallocate when new tiles are added to it. Thus this synchronization is also conditional. When the tileset is static, ie. when its a memory mapped tar, we do not need to use the mutex to synchronize and instead preallocate all the slots needed for the cache. The state object shared between the threads is wrapped in a shared_ptr , from the code comments: // we use a shared_ptr to wrap the state between the watcher thread and the main threads singleton // instance. this gives the responsibility to the last living thread to deallocate the state object. // if we didn't do this, and the watcher thread were still running when the singleton instance got // destructed, then the watcher would be making use of a deallocated state object. this way, if the // watcher is last to die it owns the lifetime of the state and if the singleton is the last to die // it owns the lifetime of the state. note that we still need to use atomics inside the state as // only the shared_ptr itself is thread safe, not the thing it points to There are two modes for the incident loading singleton, one which does directory scans ( mjolnir.incident_dir in the config), which on a modern ssd where changes are happening to the incident directory, takes 15 seconds for a planets worth of incident tiles. The second mode is a memory mapped log file which tells the timestamp when an incident tile was last changed rather than using mtime of the files on the filesystem. This can be configured with the mjolnir.incident_log config option and takes generally subsecond on modern ssds to complete for updates since it doesnt need to scan the whole directory. Since there is only one thread (per process) who is in charge of updating incidents we need to be worried about the health of this thread. There is one other configuration options to do with the healthiness of this thread. This config option is called mjolnir.max_incident_loading_latency and controls how long a round of incident updates can take before we log an error that the update was latent.","title":"How are incidents refreshed"},{"location":"loki/","text":"Loki \u00b6 Loki can be used to associate location information to an underlying graph tile object for use in creating input to the routing engine . In keeping with the Norse mythological theme, the name Loki was chosen as a play on the word locate. Since loki deals mostly with correlating some input (minimally a lat,lon) to an object within a graph tile, this seemed like a fitting name! Loki is essentially a set of various data structures and alogrithms which deal with things like: correlating an input location to the underlying graph, partial distance along an edge and filtering edges which shouldn't be considered for correlation. Components \u00b6 What follows are some notable components of loki. Search \u00b6 What's it do? \u00b6 The primary function of loki is to correlate the given input coordinate(s) to the underlying routing graph by searching over small portions of said graph near said input. The goal is to return information about the graph that can be used by a router to find a path in the graph from one point to another. Generally this is a set of candidate edges for each input coordinate. Additionally the actual correlated (snapped to route network geometry) coordinate is returned which can be useful for things like placing transit egress points on the route network or fun trivia stuff like dropping a point in the atlantic or a massive desert to find the closest signs of civilization to that point. How's it work? \u00b6 First, we exploit the fact that the graph is tiled and separated into levels of detail. See Why Tiles? for more detail. This is important because it lets us focus our search on specific partitions of the graph which are closest to the input coordinate. Also, note that loki is only interested in the most detailed level as it has all of the edges in the graph, even the lesser importance ones. You might be thinking ok so those tiles must be pretty darn small to make this reasonable (time/space complexity). Because the tiles are a regularly spaced grid, some will land on almost no routable edges and some will land on, well, Tokyo. This may not seem like much of a problem at first but closer inspection reveals its very important to strike a balance between tile size and complexity concerns. The heart of the problem is that we use these tiles for several different use-cases (algorithms) and each has different needs. Performing the actual graph traversal algorithm benefits from loading larger tiles into memory so the expansion of the graph doesn't hit (load more) new tiles so frequently. At the same time you want smaller tiles so that when you need to find just a couple edges nearest to a point you don't need to consider so many edges. There are more concerns but these illustrate the point well enough. So to settle on a size we looked at which operation dominated (in terms of complexity) with the intuition that optimizing things for that would give the most bang for the buck. That lead us to larger (for some value of large) tiles to benefit graph traversal. It did though mean that some tricks needed to be carried out on the graph correlation use-case. We're getting ahead of ourselves though. How did it work with native high detail level tile sizes? You noticed the past tense there right? Foreshadowing! The initial implementation (lets call it v0) of this was very very simple. For a single input coordinate, loki would just open the tile that the coordinate was in, scan through all the nodes in that chunk of the routing graph and return the edges connected to the one that was closest to the input. If there were no nodes in the tile, it would return no result. As you may have guessed though, it was really fast (sub-millisecond in Tokyo). You may also have guessed that it was really annoying. The closest node is often not even connected to the correct edge and can be pretty far away from the input coordinate in sparser tiles. This brings up another point about what a good implementation of loki should do. It should find the most plausible result not just the quickest one. This sounds obvious but of course the two things are at odds. Next we were onto the second implementation (v1 I guess?) which entailed actually looking at the edges' shapes. Now this operation is expensive... The shapes are compressed into strings via LEB128 encoding, which means to look at one we need to decompress it. This is expensive (comparatively), so its important to look at as few as possible. Here is where we run into a problem. We really want to look at all the edges that have shape near the input coordinate, but we have no idea which ones those are without looking at every edge's shape. So we did a few tricks. The first one was that since scanning through the nodes was free (again comparatively) we would do that first and if we were within a certain distance from a node we'd just return that result. This was problematic if the distance threshold wasn't set high enough because it could snap the result to a node on an opposing lane of traffic. Tune the threshold smaller and you make the likelihood of snapping to a node so low its not worth doing. The second trick we employed was using the length of an edge as a heuristic to determine whether an edge should or should not be considered (ie. have its shape decoded) with respect to a given input point. Basically if an edge was long enough to have reached the input point from one of its endpoints it would be considered. This weeded out a lot of short edges that weren't close to the input, but it had the side effect of over emphasizing larger edges nearer to the input. In other words it was not all that fast and there were lots of problems with it: finds result in wrong tile, finds no result because its in the adjacent tile, snaps to the wrong road because of node snapping, finds the wrong road because of over emphasis on longer edges (see issues: #72 , #62 , #52 ). So we were in a bit of a terrible state... Wrong results or no results and nothing that was particularly fast (median 130ms across NYC). It was time to come back to the tile size... But honestly it was only affecting this use-case. The case in which you are using the tiles as a geospatial index to limit your search to a small geographic region. So we had an idea. Add an index to each tile at high enough resolution for it to be performant. So we hopped over to mjolnir and did it. Essentially for each tile, we cut it up into a 5x5 set of bins and for each bin we note which edges' shapes pass through it. Mjolnir is what makes our tiles, meaning we do this once at tile creation time so the index is cached with the tile (its basically appended to the end with the shape data and so forth). Another important trick we did was reference the edges in these bins in a global fashion (an edge from another tile can pass into a bin in this tile, I like to call these hairy tiles). This lets us find edges that cross tiles boundaries (one of the problems noted above). Finally we employed one more trick to make the indexes easier to use. The graph is arranged so that you can traverse an edge in both the forward and reverse direction. To do this, each edge is represented by two directed edges (one from A to B and one from B to A). Each of these directed edges has its own id. We only ever store one of these two ids in the bins the edges intersect. This cuts down on redundant shape decoding. So what does the current implementation look like (v2?)? Well, after the indexes were added to the tiles we went to work using them. We wrote a little utility that lets you iterate (kind of like a python generator) over the bins in a closest first fashion. Basically we grab this closest bin first generator, seed it with the input point and iterate over the bins it passes us. If the bin is empty we move on, if its not, we decode the shapes of each edge in the bin and see if any edge was closer to this point than the current known closest. We terminate when either we've searched too far without finding anything or the bin we are about to look in is farther away than our current known closest edge. Since we look at bins in closest first order we shouldn't be able to find anything closer if the closest point in the bin is further than the current known closest edge. This implementation is small, it prunes a lot of search space, it doesn't find the wrong edge (in terms of closeness), it can find things in tiles not containing the input coordinates and of course its way fast (median 4ms across NYC). It does cost in data size but it was measured as a less than %5 increase across the planet tileset. What's next? \u00b6 In terms of features there are a few things I didn't mention that the current (and previous) version of the algorithm do provide. The most important of these is probably the filtering out of edges that are not traversable by you for the mode of travel you've selected. For example, you can't drive a car on the Appalachian Trail so if you request a driving route with points along the trail, loki will filter those trail edges out because they don't provide car access. It will end up correlating your coordinates to edges closest to your input which do have car access though. Another feature provided by the current (and previous) version of loki is that of favoring a direction of travel. This is very useful in a mobile navigation context. Say you are speeding down a two lane road when your passenger presses the 'get route' button. As previously mentioned, even if you two are smack in the middle of a long edge with no other connecting edges around, technically there are two results, the edge in the direction you are traveling and the edge in the reverse direction of travel. The thing is, you don't care about the route in the reverse direction of travel. So loki allows you to specify a favored direction of travel and if one of the directions is with in a 90 degree window of that then it will be included in the candidate set passed onto the routing algorithm. You might be noticing a theme here. In some cases we want to reject or favor certain edges based on some criteria (usually derived from the users request parameters). And this is the first area of future work. For a given edge we essentially want to assign a probability which denotes its likelihood of being the actual edge intended in the request. At this point the probabilty is binary. It either is traversable by your mode of travel or not. It either is in the general direction you are going, or not. It either is the closest edge to your input or not. It would seem we should want to have each of these factors influence a portion of the final probability. This would allow us to add other factors in the future. For example, if the request supplied a street name with the coordinate we could give a higher weighting to edges with similar street names. This means we would want to actually look at least a little bit further than the absolute closest edge in the presence of that edge not matching the provided street name. Another general problem is that of islands of connectivity. Without traversing the route network, one cannot say for certain that two edges are reachable from one another (for a given mode of travel). So it happens with some degree of probability that loki will correlate a pair of inputs but the routing algorithm will find no path between them. In some cases this is by design. In fact at a coarse level, if two regions are not possibly connected, think O'ahu and Mt. Everest, we won't even ask loki to correlate the coordinates to the graph. Even places that are quite close can have reachability issues which indeed should fail to find paths (unless you have a boat/hanglider/climbing gear handy). However there are a number of fairly frequently occurring cases that follow a pattern similar to the following. A user is somewhere on the road network (highly connected). User wants to go to a POI. The POI itself might be a polygon such as a park, the white house or a golf course, which will give an input coordiate as the centroid of that feature. Or it may be a point POI, such as a city center or something relatively small like an overlook on a mountain. The problem with all of these is that their location, the coordinate that will be provided as input to loki was picked so that the feature could be properly labeled on the map. In other words the coordinates are those you'd expect to use if you wanted to see where the thing is. This is often very unhelpful for the purpose of routing. Not only could routing to that label point be suboptimal (the parking for the golf course is not near its centroid), but it could actually put you on an island of limited connectivity. So that when you pass these results to the routing algorithm you won't find a path. To tackle this issue we have a few options. We could at data creation time crawl the route network to find small islands of connectivity. We could mark the edges in these islands so that loki would know to only send them to the routing algorithm if both input coordinates were in the same island. Or we could use a multi-pass approach in which we have the routing algorithm detect when its search is trapped in an island of connectivity and send the list of edges with in back to loki as a set of edges excluded from the correlation process. That latter would seem like the best option at this point in time simply because the information needed to store and time to crawl the tiles to find these small islands of connectivity would be prohibative. The final area for future work would be an elaboration to what was said earlier about wanting only to look a the highest detail level of route network data. One could conceive of a scenario in which a user has a route and they want to drag a portion of that route so as to force it toward a certain feature. If the route network is dense where that feature lives but the users map is zoomed out such that the user only sees certain route network edges loki should attempt to correlate to those rather than the possibly not visible edges in the area. Essentially when doing a correlation at a course zoom level we may want to exclude certain classes of edges that are unlikely to be visible to the user interacting with the map. Benchmark \u00b6 TODO:","title":"Loki (associate locations with graph edges)"},{"location":"loki/#loki","text":"Loki can be used to associate location information to an underlying graph tile object for use in creating input to the routing engine . In keeping with the Norse mythological theme, the name Loki was chosen as a play on the word locate. Since loki deals mostly with correlating some input (minimally a lat,lon) to an object within a graph tile, this seemed like a fitting name! Loki is essentially a set of various data structures and alogrithms which deal with things like: correlating an input location to the underlying graph, partial distance along an edge and filtering edges which shouldn't be considered for correlation.","title":"Loki"},{"location":"loki/#components","text":"What follows are some notable components of loki.","title":"Components"},{"location":"loki/#search","text":"","title":"Search"},{"location":"loki/#whats-it-do","text":"The primary function of loki is to correlate the given input coordinate(s) to the underlying routing graph by searching over small portions of said graph near said input. The goal is to return information about the graph that can be used by a router to find a path in the graph from one point to another. Generally this is a set of candidate edges for each input coordinate. Additionally the actual correlated (snapped to route network geometry) coordinate is returned which can be useful for things like placing transit egress points on the route network or fun trivia stuff like dropping a point in the atlantic or a massive desert to find the closest signs of civilization to that point.","title":"What's it do?"},{"location":"loki/#hows-it-work","text":"First, we exploit the fact that the graph is tiled and separated into levels of detail. See Why Tiles? for more detail. This is important because it lets us focus our search on specific partitions of the graph which are closest to the input coordinate. Also, note that loki is only interested in the most detailed level as it has all of the edges in the graph, even the lesser importance ones. You might be thinking ok so those tiles must be pretty darn small to make this reasonable (time/space complexity). Because the tiles are a regularly spaced grid, some will land on almost no routable edges and some will land on, well, Tokyo. This may not seem like much of a problem at first but closer inspection reveals its very important to strike a balance between tile size and complexity concerns. The heart of the problem is that we use these tiles for several different use-cases (algorithms) and each has different needs. Performing the actual graph traversal algorithm benefits from loading larger tiles into memory so the expansion of the graph doesn't hit (load more) new tiles so frequently. At the same time you want smaller tiles so that when you need to find just a couple edges nearest to a point you don't need to consider so many edges. There are more concerns but these illustrate the point well enough. So to settle on a size we looked at which operation dominated (in terms of complexity) with the intuition that optimizing things for that would give the most bang for the buck. That lead us to larger (for some value of large) tiles to benefit graph traversal. It did though mean that some tricks needed to be carried out on the graph correlation use-case. We're getting ahead of ourselves though. How did it work with native high detail level tile sizes? You noticed the past tense there right? Foreshadowing! The initial implementation (lets call it v0) of this was very very simple. For a single input coordinate, loki would just open the tile that the coordinate was in, scan through all the nodes in that chunk of the routing graph and return the edges connected to the one that was closest to the input. If there were no nodes in the tile, it would return no result. As you may have guessed though, it was really fast (sub-millisecond in Tokyo). You may also have guessed that it was really annoying. The closest node is often not even connected to the correct edge and can be pretty far away from the input coordinate in sparser tiles. This brings up another point about what a good implementation of loki should do. It should find the most plausible result not just the quickest one. This sounds obvious but of course the two things are at odds. Next we were onto the second implementation (v1 I guess?) which entailed actually looking at the edges' shapes. Now this operation is expensive... The shapes are compressed into strings via LEB128 encoding, which means to look at one we need to decompress it. This is expensive (comparatively), so its important to look at as few as possible. Here is where we run into a problem. We really want to look at all the edges that have shape near the input coordinate, but we have no idea which ones those are without looking at every edge's shape. So we did a few tricks. The first one was that since scanning through the nodes was free (again comparatively) we would do that first and if we were within a certain distance from a node we'd just return that result. This was problematic if the distance threshold wasn't set high enough because it could snap the result to a node on an opposing lane of traffic. Tune the threshold smaller and you make the likelihood of snapping to a node so low its not worth doing. The second trick we employed was using the length of an edge as a heuristic to determine whether an edge should or should not be considered (ie. have its shape decoded) with respect to a given input point. Basically if an edge was long enough to have reached the input point from one of its endpoints it would be considered. This weeded out a lot of short edges that weren't close to the input, but it had the side effect of over emphasizing larger edges nearer to the input. In other words it was not all that fast and there were lots of problems with it: finds result in wrong tile, finds no result because its in the adjacent tile, snaps to the wrong road because of node snapping, finds the wrong road because of over emphasis on longer edges (see issues: #72 , #62 , #52 ). So we were in a bit of a terrible state... Wrong results or no results and nothing that was particularly fast (median 130ms across NYC). It was time to come back to the tile size... But honestly it was only affecting this use-case. The case in which you are using the tiles as a geospatial index to limit your search to a small geographic region. So we had an idea. Add an index to each tile at high enough resolution for it to be performant. So we hopped over to mjolnir and did it. Essentially for each tile, we cut it up into a 5x5 set of bins and for each bin we note which edges' shapes pass through it. Mjolnir is what makes our tiles, meaning we do this once at tile creation time so the index is cached with the tile (its basically appended to the end with the shape data and so forth). Another important trick we did was reference the edges in these bins in a global fashion (an edge from another tile can pass into a bin in this tile, I like to call these hairy tiles). This lets us find edges that cross tiles boundaries (one of the problems noted above). Finally we employed one more trick to make the indexes easier to use. The graph is arranged so that you can traverse an edge in both the forward and reverse direction. To do this, each edge is represented by two directed edges (one from A to B and one from B to A). Each of these directed edges has its own id. We only ever store one of these two ids in the bins the edges intersect. This cuts down on redundant shape decoding. So what does the current implementation look like (v2?)? Well, after the indexes were added to the tiles we went to work using them. We wrote a little utility that lets you iterate (kind of like a python generator) over the bins in a closest first fashion. Basically we grab this closest bin first generator, seed it with the input point and iterate over the bins it passes us. If the bin is empty we move on, if its not, we decode the shapes of each edge in the bin and see if any edge was closer to this point than the current known closest. We terminate when either we've searched too far without finding anything or the bin we are about to look in is farther away than our current known closest edge. Since we look at bins in closest first order we shouldn't be able to find anything closer if the closest point in the bin is further than the current known closest edge. This implementation is small, it prunes a lot of search space, it doesn't find the wrong edge (in terms of closeness), it can find things in tiles not containing the input coordinates and of course its way fast (median 4ms across NYC). It does cost in data size but it was measured as a less than %5 increase across the planet tileset.","title":"How's it work?"},{"location":"loki/#whats-next","text":"In terms of features there are a few things I didn't mention that the current (and previous) version of the algorithm do provide. The most important of these is probably the filtering out of edges that are not traversable by you for the mode of travel you've selected. For example, you can't drive a car on the Appalachian Trail so if you request a driving route with points along the trail, loki will filter those trail edges out because they don't provide car access. It will end up correlating your coordinates to edges closest to your input which do have car access though. Another feature provided by the current (and previous) version of loki is that of favoring a direction of travel. This is very useful in a mobile navigation context. Say you are speeding down a two lane road when your passenger presses the 'get route' button. As previously mentioned, even if you two are smack in the middle of a long edge with no other connecting edges around, technically there are two results, the edge in the direction you are traveling and the edge in the reverse direction of travel. The thing is, you don't care about the route in the reverse direction of travel. So loki allows you to specify a favored direction of travel and if one of the directions is with in a 90 degree window of that then it will be included in the candidate set passed onto the routing algorithm. You might be noticing a theme here. In some cases we want to reject or favor certain edges based on some criteria (usually derived from the users request parameters). And this is the first area of future work. For a given edge we essentially want to assign a probability which denotes its likelihood of being the actual edge intended in the request. At this point the probabilty is binary. It either is traversable by your mode of travel or not. It either is in the general direction you are going, or not. It either is the closest edge to your input or not. It would seem we should want to have each of these factors influence a portion of the final probability. This would allow us to add other factors in the future. For example, if the request supplied a street name with the coordinate we could give a higher weighting to edges with similar street names. This means we would want to actually look at least a little bit further than the absolute closest edge in the presence of that edge not matching the provided street name. Another general problem is that of islands of connectivity. Without traversing the route network, one cannot say for certain that two edges are reachable from one another (for a given mode of travel). So it happens with some degree of probability that loki will correlate a pair of inputs but the routing algorithm will find no path between them. In some cases this is by design. In fact at a coarse level, if two regions are not possibly connected, think O'ahu and Mt. Everest, we won't even ask loki to correlate the coordinates to the graph. Even places that are quite close can have reachability issues which indeed should fail to find paths (unless you have a boat/hanglider/climbing gear handy). However there are a number of fairly frequently occurring cases that follow a pattern similar to the following. A user is somewhere on the road network (highly connected). User wants to go to a POI. The POI itself might be a polygon such as a park, the white house or a golf course, which will give an input coordiate as the centroid of that feature. Or it may be a point POI, such as a city center or something relatively small like an overlook on a mountain. The problem with all of these is that their location, the coordinate that will be provided as input to loki was picked so that the feature could be properly labeled on the map. In other words the coordinates are those you'd expect to use if you wanted to see where the thing is. This is often very unhelpful for the purpose of routing. Not only could routing to that label point be suboptimal (the parking for the golf course is not near its centroid), but it could actually put you on an island of limited connectivity. So that when you pass these results to the routing algorithm you won't find a path. To tackle this issue we have a few options. We could at data creation time crawl the route network to find small islands of connectivity. We could mark the edges in these islands so that loki would know to only send them to the routing algorithm if both input coordinates were in the same island. Or we could use a multi-pass approach in which we have the routing algorithm detect when its search is trapped in an island of connectivity and send the list of edges with in back to loki as a set of edges excluded from the correlation process. That latter would seem like the best option at this point in time simply because the information needed to store and time to crawl the tiles to find these small islands of connectivity would be prohibative. The final area for future work would be an elaboration to what was said earlier about wanting only to look a the highest detail level of route network data. One could conceive of a scenario in which a user has a route and they want to drag a portion of that route so as to force it toward a certain feature. If the route network is dense where that feature lives but the users map is zoomed out such that the user only sees certain route network edges loki should attempt to correlate to those rather than the possibly not visible edges in the area. Essentially when doing a correlation at a course zoom level we may want to exclude certain classes of edges that are unlikely to be visible to the user interacting with the map.","title":"What's next?"},{"location":"loki/#benchmark","text":"TODO:","title":"Benchmark"},{"location":"meili/","text":"Meili, provides a set of algorithms and datastructures for map matching. It matches a sequence of locations (usually noisy e.g. GPS trajectory) to the underlying road network. In keeping with the Norse mythological theme, the name Meili , Thor's brother, was chosen. Since map matching is closely related to routing and since Thor is the Valhalla routing library, meili seemed most appropriate. Additionally the main author of this software, @ptpt from team Mapillary noted that, m\u0115il\u00ec (\u7f8e\u4e3d) means beautiful in Chinese. This is indeed a beautiful collaboration between team Mapillary and team Valhalla! Open source FTW! Documentation \u00b6 Overview Library API Configuration The Algorithms","title":"Meili"},{"location":"meili/#documentation","text":"Overview Library API Configuration The Algorithms","title":"Documentation"},{"location":"midgard/","text":"Midgard \u00b6 Midgard serves as a set of geographic/metric data structures and algorithms for use in essentially all other parts of valhalla. In keeping with the Norse mythological theme, the name Midgard was chosen as it is represents the world as humans know it. Since the software and classes within midgard deal mostly with the maths of our favorite spheroid, this seemed like a fitting name! Midgard contains a set of various geometric data structures and support classes. It also includes algorithms which deal with things like: closest point to line, vector and matrix operations, polyline encoding, logging, projection, tiling, and culling. Midgard also include a variety of constants for time and distance conversions as well as angular measures. Components \u00b6 What follows are some notable components of midgard. 2-D Points and Latitude, Longitude \u00b6 Midgard includes classes to support two-dimensional points: either Cartesian x,y (Point2) or latitude, longitude (PointLL). Basic operations such as distance between 2 points are provided, with the PointLL providing arc-distance or distance along a spherical earth. 2-D Vectors \u00b6 Midgard includes a 2-D vector class. This is a templated class so it can support either Cartesian coordinates or latitude, longitude coordinates. Basic 2-D vector operations such as dot products, scaling, normalization, projection, and angle computations are provided. Line Segments and Polylines \u00b6 Midgard provides a class supporting 2-D line segments. This is a templated class so it can support either Cartesian coordinates or latitude, longitude coordinates. Various intersection methods, clipping methods, and distance methods are provided. 2-D Bounding Boxes \u00b6 Midgard includes a class to support 2-D axis-aligned bounding boxes. This is a templated class so it can support either Cartesian coordinates or latitude, longitude coordinates. Methods to determine if points are inside a bounding box are provided as well as methods to find the intersection of 2 bounding boxes. Clipping operations to clip polylines to the bounding box are also provided. A class supporting oriented or general 2-D bounding boxes is also provided. Ellipse \u00b6 Midgard contains a class supporting methods to construct an ellipse, test if a line segment intersects the ellipse, test if an axis-aligned bounding box intersects, and test whether a point is within the ellipse. This is a templated class to work with Point2 (Euclidean x,y) or PointLL (latitude,longitude). Tiles \u00b6 Midgard provides a class that provides a uniform (square) tiling system for a specified bounding box and tile size. This is a template class that works with Point2 (Euclidean x,y) or PointLL (latitude,longitude). A unique tile Id is assigned for each tile based on the following rules: Tile numbers start at 0 at the min y, x (lower left) Tile numbers increase by column (x,longitude) then by row (y,latitude) Tile numbers increase along each row by increasing x,longitude. This class contains methods for converting x,y or lat,lng into tile Id and vice-versa. Methods for relative tiles (using row and column offsets) are also provided. Also includes a method to get a list of tiles covering a bounding box. Gridded Data \u00b6 Midgard provides a class to store data in a gridded/tiled data structure. Contains methods to mark each tile with data using a compare operator. There is also a method to generate contour lines from isotile data. The contouring method is a derivation from the C code version of CONREC by Paul Bourke: http://paulbourke.net/papers/conrec/ Distance Approximation \u00b6 Midgard provides a special class to perform distance approximation in latitude, longitude space. This class approximates distance (meters) between two points. This method is more efficient than using spherical distance calculations within the PointLL class. It computes an approximate distance using the pythagorean theorem with the meters of latitude change (exact) and the meters of longitude change at the \"test point\". Longitude is inexact since meters per degree of longitude changes with latitude. This approximation has very little error (less than 1%) if the positions are close to one another (within several hundred meters). Error increases at high (near polar) latitudes. This method will not work if the points cross 180 degrees longitude. Polyline Encoding \u00b6 TODO: Logging \u00b6 TODO: Util \u00b6 midgard includes a variety of utility methods supporting : TODO Sequence \u00b6 TODO:","title":"Midgard (data structures for geography/geometry)"},{"location":"midgard/#midgard","text":"Midgard serves as a set of geographic/metric data structures and algorithms for use in essentially all other parts of valhalla. In keeping with the Norse mythological theme, the name Midgard was chosen as it is represents the world as humans know it. Since the software and classes within midgard deal mostly with the maths of our favorite spheroid, this seemed like a fitting name! Midgard contains a set of various geometric data structures and support classes. It also includes algorithms which deal with things like: closest point to line, vector and matrix operations, polyline encoding, logging, projection, tiling, and culling. Midgard also include a variety of constants for time and distance conversions as well as angular measures.","title":"Midgard"},{"location":"midgard/#components","text":"What follows are some notable components of midgard.","title":"Components"},{"location":"midgard/#2-d-points-and-latitude-longitude","text":"Midgard includes classes to support two-dimensional points: either Cartesian x,y (Point2) or latitude, longitude (PointLL). Basic operations such as distance between 2 points are provided, with the PointLL providing arc-distance or distance along a spherical earth.","title":"2-D Points and Latitude, Longitude"},{"location":"midgard/#2-d-vectors","text":"Midgard includes a 2-D vector class. This is a templated class so it can support either Cartesian coordinates or latitude, longitude coordinates. Basic 2-D vector operations such as dot products, scaling, normalization, projection, and angle computations are provided.","title":"2-D Vectors"},{"location":"midgard/#line-segments-and-polylines","text":"Midgard provides a class supporting 2-D line segments. This is a templated class so it can support either Cartesian coordinates or latitude, longitude coordinates. Various intersection methods, clipping methods, and distance methods are provided.","title":"Line Segments and Polylines"},{"location":"midgard/#2-d-bounding-boxes","text":"Midgard includes a class to support 2-D axis-aligned bounding boxes. This is a templated class so it can support either Cartesian coordinates or latitude, longitude coordinates. Methods to determine if points are inside a bounding box are provided as well as methods to find the intersection of 2 bounding boxes. Clipping operations to clip polylines to the bounding box are also provided. A class supporting oriented or general 2-D bounding boxes is also provided.","title":"2-D Bounding Boxes"},{"location":"midgard/#ellipse","text":"Midgard contains a class supporting methods to construct an ellipse, test if a line segment intersects the ellipse, test if an axis-aligned bounding box intersects, and test whether a point is within the ellipse. This is a templated class to work with Point2 (Euclidean x,y) or PointLL (latitude,longitude).","title":"Ellipse"},{"location":"midgard/#tiles","text":"Midgard provides a class that provides a uniform (square) tiling system for a specified bounding box and tile size. This is a template class that works with Point2 (Euclidean x,y) or PointLL (latitude,longitude). A unique tile Id is assigned for each tile based on the following rules: Tile numbers start at 0 at the min y, x (lower left) Tile numbers increase by column (x,longitude) then by row (y,latitude) Tile numbers increase along each row by increasing x,longitude. This class contains methods for converting x,y or lat,lng into tile Id and vice-versa. Methods for relative tiles (using row and column offsets) are also provided. Also includes a method to get a list of tiles covering a bounding box.","title":"Tiles"},{"location":"midgard/#gridded-data","text":"Midgard provides a class to store data in a gridded/tiled data structure. Contains methods to mark each tile with data using a compare operator. There is also a method to generate contour lines from isotile data. The contouring method is a derivation from the C code version of CONREC by Paul Bourke: http://paulbourke.net/papers/conrec/","title":"Gridded Data"},{"location":"midgard/#distance-approximation","text":"Midgard provides a special class to perform distance approximation in latitude, longitude space. This class approximates distance (meters) between two points. This method is more efficient than using spherical distance calculations within the PointLL class. It computes an approximate distance using the pythagorean theorem with the meters of latitude change (exact) and the meters of longitude change at the \"test point\". Longitude is inexact since meters per degree of longitude changes with latitude. This approximation has very little error (less than 1%) if the positions are close to one another (within several hundred meters). Error increases at high (near polar) latitudes. This method will not work if the points cross 180 degrees longitude.","title":"Distance Approximation"},{"location":"midgard/#polyline-encoding","text":"TODO:","title":"Polyline Encoding"},{"location":"midgard/#logging","text":"TODO:","title":"Logging"},{"location":"midgard/#util","text":"midgard includes a variety of utility methods supporting : TODO","title":"Util"},{"location":"midgard/#sequence","text":"TODO:","title":"Sequence"},{"location":"mjolnir/","text":"Mjolnir \u00b6 The mjolnir is essentially a set of applications, data structures and alogrithms which deal with things like: parsing OSM data extracts, cutting routable \"graph\" tiles, generating tile hierarchies and testing for data deficiencies. This tiled routing data is used in routing and searching under the valhalla organization. In keeping with the Norse mythological theme, the name Mj\u00f6lnir was chosen as it represents a weapon of mass destruction. This seemed fitting since the main application deals mostly with pounding planet sized OSM data into tiny routable tile fragments. Components \u00b6 What follows are some notable components of the mjolnir.","title":"Mjolnir"},{"location":"mjolnir/#mjolnir","text":"The mjolnir is essentially a set of applications, data structures and alogrithms which deal with things like: parsing OSM data extracts, cutting routable \"graph\" tiles, generating tile hierarchies and testing for data deficiencies. This tiled routing data is used in routing and searching under the valhalla organization. In keeping with the Norse mythological theme, the name Mj\u00f6lnir was chosen as it represents a weapon of mass destruction. This seemed fitting since the main application deals mostly with pounding planet sized OSM data into tiny routable tile fragments.","title":"Mjolnir"},{"location":"mjolnir/#components","text":"What follows are some notable components of the mjolnir.","title":"Components"},{"location":"odin/","text":"Odin \u00b6 Odin serves as a directions engine for annotating a path as input from the routing engine for use in navigation. In keeping with the Norse mythological theme, the name Odin was chosen as he has often been noted as being very wise. Since the library deals mostly with providing, hopefully wise, guidance along a path to be used for navigation, this seemed like a fitting name! We've also managed to create a backronym out of Odin which stands for: Open Directions and Improved Narrative. Odin contains a set of various data structures and alogrithms which deal with things like: maneuver generation, streetname matching and narrative generation. Components \u00b6 What follows are some notable components of the odin. Maneuver \u00b6 TODO: Util \u00b6 TODO:","title":"Odin (route narrative/maneuver generation)"},{"location":"odin/#odin","text":"Odin serves as a directions engine for annotating a path as input from the routing engine for use in navigation. In keeping with the Norse mythological theme, the name Odin was chosen as he has often been noted as being very wise. Since the library deals mostly with providing, hopefully wise, guidance along a path to be used for navigation, this seemed like a fitting name! We've also managed to create a backronym out of Odin which stands for: Open Directions and Improved Narrative. Odin contains a set of various data structures and alogrithms which deal with things like: maneuver generation, streetname matching and narrative generation.","title":"Odin"},{"location":"odin/#components","text":"What follows are some notable components of the odin.","title":"Components"},{"location":"odin/#maneuver","text":"TODO:","title":"Maneuver"},{"location":"odin/#util","text":"TODO:","title":"Util"},{"location":"releasing/","text":"Releasing a new Valhalla version \u00b6 We are using http://semver.org/ for versioning with major, minor and patch versions. Guarantees \u00b6 We are giving the following guarantees between versions: Major version change \u00b6 There are no guarantees about compatiblity of APIs or datasets Breaking changes will be noted as BREAKING in the changelog Minor version change \u00b6 We may introduce forward-compatible changes: query parameters and response properties may be added in responses, but existing properties may not be changed or removed. One exception to this is the addition of new turn types, which we see as forward-compatible changes. Forward-compatible HTTP API Forward-compatible C++ library API Forward-compatible dataset version Patch version change \u00b6 No change of query parameters or response formats Compatible HTTP API Compatible C++ library API Compatible data datasets Release and branch management \u00b6 The master branch is for the bleeding edge development We create and maintain release branches x.y to control the release flow We create the release branch once we create release branches once we want to release the first RC RCs go in the release branch, commits needs to be cherry-picked from master No minor or major version will be released without a code-equal release candidates For quality assurance, release candidates need to be staged before tagging a final release Patch versions may be released without a release candidate We may backport fixes to older versions and release them as patch versions Releasing a version \u00b6 Update the translations from Transifex, see README . Check out the appropriate release branch x.y . Make sure CHANGELOG.md is up to date. Make sure all tests are passing (e.g. Circle CI gives you a ). Make sure the valhalla/valhalla.h has been updated. Use an annotated tag to mark the release: git tag x.y.z -a . The body of the tag description should be the changelog entries. Push tags and commits: git push; git push --tags On https://github.com/valhalla/valhalla/releases press Draft a new release , write the release tag x.y.z in the Tag version field, write the changelog entries in the Describe this release field and press Publish release .","title":"Releasing a new Valhalla version"},{"location":"releasing/#releasing-a-new-valhalla-version","text":"We are using http://semver.org/ for versioning with major, minor and patch versions.","title":"Releasing a new Valhalla version"},{"location":"releasing/#guarantees","text":"We are giving the following guarantees between versions:","title":"Guarantees"},{"location":"releasing/#major-version-change","text":"There are no guarantees about compatiblity of APIs or datasets Breaking changes will be noted as BREAKING in the changelog","title":"Major version change"},{"location":"releasing/#minor-version-change","text":"We may introduce forward-compatible changes: query parameters and response properties may be added in responses, but existing properties may not be changed or removed. One exception to this is the addition of new turn types, which we see as forward-compatible changes. Forward-compatible HTTP API Forward-compatible C++ library API Forward-compatible dataset version","title":"Minor version change"},{"location":"releasing/#patch-version-change","text":"No change of query parameters or response formats Compatible HTTP API Compatible C++ library API Compatible data datasets","title":"Patch version change"},{"location":"releasing/#release-and-branch-management","text":"The master branch is for the bleeding edge development We create and maintain release branches x.y to control the release flow We create the release branch once we create release branches once we want to release the first RC RCs go in the release branch, commits needs to be cherry-picked from master No minor or major version will be released without a code-equal release candidates For quality assurance, release candidates need to be staged before tagging a final release Patch versions may be released without a release candidate We may backport fixes to older versions and release them as patch versions","title":"Release and branch management"},{"location":"releasing/#releasing-a-version","text":"Update the translations from Transifex, see README . Check out the appropriate release branch x.y . Make sure CHANGELOG.md is up to date. Make sure all tests are passing (e.g. Circle CI gives you a ). Make sure the valhalla/valhalla.h has been updated. Use an annotated tag to mark the release: git tag x.y.z -a . The body of the tag description should be the changelog entries. Push tags and commits: git push; git push --tags On https://github.com/valhalla/valhalla/releases press Draft a new release , write the release tag x.y.z in the Tag version field, write the changelog entries in the Describe this release field and press Publish release .","title":"Releasing a version"},{"location":"route_overview/","text":"Overview of how routes are computed \u00b6 This document provides a brief overview of Valhalla route computation. Request Parsing \u00b6 Parse incoming request (JSON) to validate inputs. Converts (most) of the incoming request to protocol buffer objects to pass through the individual stages. The exception is currently some costing options for which parsing is deferred until needed within the costing module itself. Finding Candidate Edges \u00b6 The first step within a route is to find candidate edges for each incoming location. This logic is held within the loki directory. A set of nearby edges is found by iterating through bins within a routing graph tile or set of tiles near the location latitude, longitude. Bins are subdivided portions of Valhalla tiles that are currently .05 degrees per bin. Each bin stores a list of Valhalla edges with the bin. Edges that are allowed for the specified costing model are tested to determine the closest point along the geometry or shape of the edge. Special logic manages edges that are in disconnected regions which frequently occur in OpenStreetMap data. Additional candidate edges may be created in these cases. In addition, other filters such as filtering by heading can optionally be applied to narrow the set of candidate edges. Path Computation \u00b6 Valhalla uses a couple different algorithms to generate the route path. Code for these algorithms is held within the thor directory. They are all flavors of Dijkstra\u2019s algorithm. The following classes are derived from PathAlgorithm (base class defining the route path interface): UnidirectionalAStar - This is a forward OR reverse direction A* algorithm which is currently used for time-dependent routing and trivial paths. BidirectionalAStar - This is a bidirectional A* algorithm used for routes that are not time-dependent and are not trivial. MultiModal - This is a forward direction A* algorithm with transit schedule lookup included as well as logic to switch modes between pedestrian and transit. This algorithm is time-dependent due to the nature of transit schedules. All of Valhalla\u2019s path algorithms use dynamic, run-time costing. Costing logic is held within the sif directory. A base class ( DynamicCost ) defines the interface that each costing model implements. A brief overview of the costing design is located here . Forming the Trip Path TripPathBuilder creates the Trip Path for Valhalla. Code for this step is within the thor directory. This Trip path is a sequence of nodes and edges that will form a path. The path is created in a forward direction from Node 0 to Node 1 to... Node N . Edge and node attributes are added to the path which will then be passed to Odin to create Trip Directions. Moreover, TripPathBuilder will add intersecting edge attributes at each node within the path to assist Odin with maneuver generation. Looking at the figure below, our path is from Node 1 to Node 2 to Node 3 to... Node N . The path (a, f, l) is highlighted in red. Each arrow represents a directed edge (DE) from Node to Node. Looking at our path, when we are at Node 2 we will store the edge information for DE a/b and the attributes(e.g., surface, speed, access, transit information, and etc.) for DE a . Also, we will store the intersecting edge info for c/d , e/f , and g/h . Generating Guidance The route narrative/guidance generating code is located in the odin directory. Odin inspects the trip path nodes and edges in reverse order to form an initial list of maneuvers or steps Odin collapses the initial maneuver list to form a concise list of maneuvers Odin adds text and verbal instructions to form trip directions Odin supports these languages for narration instructions Serializing the Route Response \u00b6 The serialization of the route response takes place in the tyr layer of the Valhalla source code. Tyr is used to handle HTTP requests for a route and communicates with all of the other Valhalla APIs. Tyr will format output from Odin and supports JSON and protocol buffer (pbf) output. Serialization logic is split up by API (route, matrix, isochrone, height, locate, and map-matching (trace_route and trace_attributes). route_serializer.cc serializeDirections (request, path_legs, directions_legs) \u2192 outputs a json string toOSRM - Serialize route response in OSRM compatible format toJSON - Returns a trip object formated to JSON jsonToProtoRoute (json_route, proto_route) \u2192 used by navigator Transfers the JSON route information returned from a route request into the Route pbf object passed in by reference. To summarize, Valhalla builds a JSON \u201ctrip\u201d object which contains the locations, route summary with basic info about the trip, a list of legs of the trip, status, units and language. A more in depth description of the results can be found here .","title":"Overview of how routes are computed"},{"location":"route_overview/#overview-of-how-routes-are-computed","text":"This document provides a brief overview of Valhalla route computation.","title":"Overview of how routes are computed"},{"location":"route_overview/#request-parsing","text":"Parse incoming request (JSON) to validate inputs. Converts (most) of the incoming request to protocol buffer objects to pass through the individual stages. The exception is currently some costing options for which parsing is deferred until needed within the costing module itself.","title":"Request Parsing"},{"location":"route_overview/#finding-candidate-edges","text":"The first step within a route is to find candidate edges for each incoming location. This logic is held within the loki directory. A set of nearby edges is found by iterating through bins within a routing graph tile or set of tiles near the location latitude, longitude. Bins are subdivided portions of Valhalla tiles that are currently .05 degrees per bin. Each bin stores a list of Valhalla edges with the bin. Edges that are allowed for the specified costing model are tested to determine the closest point along the geometry or shape of the edge. Special logic manages edges that are in disconnected regions which frequently occur in OpenStreetMap data. Additional candidate edges may be created in these cases. In addition, other filters such as filtering by heading can optionally be applied to narrow the set of candidate edges.","title":"Finding Candidate Edges"},{"location":"route_overview/#path-computation","text":"Valhalla uses a couple different algorithms to generate the route path. Code for these algorithms is held within the thor directory. They are all flavors of Dijkstra\u2019s algorithm. The following classes are derived from PathAlgorithm (base class defining the route path interface): UnidirectionalAStar - This is a forward OR reverse direction A* algorithm which is currently used for time-dependent routing and trivial paths. BidirectionalAStar - This is a bidirectional A* algorithm used for routes that are not time-dependent and are not trivial. MultiModal - This is a forward direction A* algorithm with transit schedule lookup included as well as logic to switch modes between pedestrian and transit. This algorithm is time-dependent due to the nature of transit schedules. All of Valhalla\u2019s path algorithms use dynamic, run-time costing. Costing logic is held within the sif directory. A base class ( DynamicCost ) defines the interface that each costing model implements. A brief overview of the costing design is located here . Forming the Trip Path TripPathBuilder creates the Trip Path for Valhalla. Code for this step is within the thor directory. This Trip path is a sequence of nodes and edges that will form a path. The path is created in a forward direction from Node 0 to Node 1 to... Node N . Edge and node attributes are added to the path which will then be passed to Odin to create Trip Directions. Moreover, TripPathBuilder will add intersecting edge attributes at each node within the path to assist Odin with maneuver generation. Looking at the figure below, our path is from Node 1 to Node 2 to Node 3 to... Node N . The path (a, f, l) is highlighted in red. Each arrow represents a directed edge (DE) from Node to Node. Looking at our path, when we are at Node 2 we will store the edge information for DE a/b and the attributes(e.g., surface, speed, access, transit information, and etc.) for DE a . Also, we will store the intersecting edge info for c/d , e/f , and g/h . Generating Guidance The route narrative/guidance generating code is located in the odin directory. Odin inspects the trip path nodes and edges in reverse order to form an initial list of maneuvers or steps Odin collapses the initial maneuver list to form a concise list of maneuvers Odin adds text and verbal instructions to form trip directions Odin supports these languages for narration instructions","title":"Path Computation"},{"location":"route_overview/#serializing-the-route-response","text":"The serialization of the route response takes place in the tyr layer of the Valhalla source code. Tyr is used to handle HTTP requests for a route and communicates with all of the other Valhalla APIs. Tyr will format output from Odin and supports JSON and protocol buffer (pbf) output. Serialization logic is split up by API (route, matrix, isochrone, height, locate, and map-matching (trace_route and trace_attributes). route_serializer.cc serializeDirections (request, path_legs, directions_legs) \u2192 outputs a json string toOSRM - Serialize route response in OSRM compatible format toJSON - Returns a trip object formated to JSON jsonToProtoRoute (json_route, proto_route) \u2192 used by navigator Transfers the JSON route information returned from a route request into the Route pbf object passed in by reference. To summarize, Valhalla builds a JSON \u201ctrip\u201d object which contains the locations, route summary with basic info about the trip, a list of legs of the trip, status, units and language. A more in depth description of the results can be found here .","title":"Serializing the Route Response"},{"location":"sif/","text":"Sif \u00b6 Sif provides dynamic, extensible costing for edges and transitions between edges (turn costs). Its primary use is in the routing engine when forming the best path between locations. In keeping with the Norse mythological theme, the name Sif was chosen since Sif is a companion to Thor. Sif is essentially a set of various data structures and alogrithms which deal with things like: correlating an input location to the underlying graph, partial distance along an edge and filtering edges which shouldn't be considered for correlation. Components \u00b6 What follows are some notable components of sif. Dynamic Costing \u00b6 TODO:","title":"Sif (costing for edges/transitions)"},{"location":"sif/#sif","text":"Sif provides dynamic, extensible costing for edges and transitions between edges (turn costs). Its primary use is in the routing engine when forming the best path between locations. In keeping with the Norse mythological theme, the name Sif was chosen since Sif is a companion to Thor. Sif is essentially a set of various data structures and alogrithms which deal with things like: correlating an input location to the underlying graph, partial distance along an edge and filtering edges which shouldn't be considered for correlation.","title":"Sif"},{"location":"sif/#components","text":"What follows are some notable components of sif.","title":"Components"},{"location":"sif/#dynamic-costing","text":"TODO:","title":"Dynamic Costing"},{"location":"skadi/","text":"Skadi \u00b6 Skadi can be used to access digital elevation model data which is useful in computing steepness of edges in the route graph or generating an elevation profile along a computed route. In keeping with the Norse mythological theme, the jotunn/goddess Ska\u00f0i was chosen as she is associated, among other things, with the mountains. Since skadi deals mostly with extracting elevation data from various datasets, this seemed like a fitting name! Skadi is essentially a set of various data structures and alogrithms which deal with things like: sampling elevation data in an adhoc or evenly sampled manner as well as serving elevation data in structured (json) or raw (geotiff) formats. Components \u00b6 What follows are some notable components of Skadi. Sample \u00b6 TODO: Service \u00b6 TODO:","title":"Skadi (digital elevation model usage)"},{"location":"skadi/#skadi","text":"Skadi can be used to access digital elevation model data which is useful in computing steepness of edges in the route graph or generating an elevation profile along a computed route. In keeping with the Norse mythological theme, the jotunn/goddess Ska\u00f0i was chosen as she is associated, among other things, with the mountains. Since skadi deals mostly with extracting elevation data from various datasets, this seemed like a fitting name! Skadi is essentially a set of various data structures and alogrithms which deal with things like: sampling elevation data in an adhoc or evenly sampled manner as well as serving elevation data in structured (json) or raw (geotiff) formats.","title":"Skadi"},{"location":"skadi/#components","text":"What follows are some notable components of Skadi.","title":"Components"},{"location":"skadi/#sample","text":"TODO:","title":"Sample"},{"location":"skadi/#service","text":"TODO:","title":"Service"},{"location":"speeds/","text":"Speed values in Valhalla APIs \u00b6 To calculate speed and related factors when routing, such as travel times, Valhalla APIs consider speed limits in the OpenStreetMap source data, defaults for a particular category of road, or a measure of whether the road is in an urban or rural environment. Real-time or historical traffic information is not currently included in speed calculations. Valhalla is working towards these capabilities, and the tiled data structures of Valhalla and dynamic costing approach can readily support traffic information when available. Assignment of speeds to roadways \u00b6 Routing data contains two attributes to denote speed: speed and speed_limit . The most important for routing determination is speed , given in units of kilometers per hour. The speed value, along with the length of the roadway edge, determine the travel time along a road section. The speed_limit contains the posted speed limit, if available, and can be used by mobile navigation applications to display the speed limit and possibly alert the driver when it is exceeded. The speed is assigned based on tags within the OpenStreetMap data as follows: max_speed : If a maxspeed tag is available from OSM, that speed is used as the routing speed and the speed_limit is set to that value. Note that maxspeed=none is valid and means the speed limit is unlimited (as on the German Autobahn); in this case we do not set a speed based on maxspeed but rely on the default speeds based on the highway tag (see next bullet point). highway : If there is no maxspeed or maxspeed=none tag, then speed is based on the OSM highway tag. There are a default set of speeds for each highway tag. Note that future work involves implementing country-specific default speeds for highway tags. road density: The road density (the length of drivable roads in kilometers per square kilometer) at each node in the routing graph is estimated during Valhalla data import. The road density is used to determine if a road is in a rural or urban area. Roads in urban areas have their speed reduced if there is no maxspeed tag. In the future, this method may be replaced with a more accurate measure of rural versus urban regions, but density produces adequate results for now. The speed_type attribute defines whether the assigned routing speed is from a speed limit or based on the highway tag.","title":"Speed information"},{"location":"speeds/#speed-values-in-valhalla-apis","text":"To calculate speed and related factors when routing, such as travel times, Valhalla APIs consider speed limits in the OpenStreetMap source data, defaults for a particular category of road, or a measure of whether the road is in an urban or rural environment. Real-time or historical traffic information is not currently included in speed calculations. Valhalla is working towards these capabilities, and the tiled data structures of Valhalla and dynamic costing approach can readily support traffic information when available.","title":"Speed values in Valhalla APIs"},{"location":"speeds/#assignment-of-speeds-to-roadways","text":"Routing data contains two attributes to denote speed: speed and speed_limit . The most important for routing determination is speed , given in units of kilometers per hour. The speed value, along with the length of the roadway edge, determine the travel time along a road section. The speed_limit contains the posted speed limit, if available, and can be used by mobile navigation applications to display the speed limit and possibly alert the driver when it is exceeded. The speed is assigned based on tags within the OpenStreetMap data as follows: max_speed : If a maxspeed tag is available from OSM, that speed is used as the routing speed and the speed_limit is set to that value. Note that maxspeed=none is valid and means the speed limit is unlimited (as on the German Autobahn); in this case we do not set a speed based on maxspeed but rely on the default speeds based on the highway tag (see next bullet point). highway : If there is no maxspeed or maxspeed=none tag, then speed is based on the OSM highway tag. There are a default set of speeds for each highway tag. Note that future work involves implementing country-specific default speeds for highway tags. road density: The road density (the length of drivable roads in kilometers per square kilometer) at each node in the routing graph is estimated during Valhalla data import. The road density is used to determine if a road is in a rural or urban area. Roads in urban areas have their speed reduced if there is no maxspeed tag. In the future, this method may be replaced with a more accurate measure of rural versus urban regions, but density produces adequate results for now. The speed_type attribute defines whether the assigned routing speed is from a speed limit or based on the highway tag.","title":"Assignment of speeds to roadways"},{"location":"terminology/","text":"Mobility glossary \u00b6 break location - the start or end point of a route. cost - fixed costs in seconds that are added to both the path cost and the estimated time. costing model - set of costs for particular methods of travel, such as automobile or pedestrian. edge - a line connected between nodes factor - multiply the cost along an edge or road section in a way that influences the path to favor or avoid a particular attribute graph - a set of edges connected by nodes used for building a route location - a latitude, longitude coordinate pair, specified in decimal degrees that determines the routing and order of navigation. maneuver - an operation to be performed during navigation, such as a turn, and the expected duration of the movement. narration - textual guidance describing the maneuver to be performed, such as a turn, distance to travel, and expected time. path - the sequence of edges forming a route penalty - fixed costs in seconds that are only added to the path cost. Penalties can influence the route path determination but do not add to the estimated time along the path. route - sequence of edges and maneuvers forming the best travel path between locations given the available road network, costs, influence factors, and other inputs. short path - a route that attempts to minimize distance traveled over the constituent edges, but may not be the shortest distance. through location - an optional location to influence the route to travel through that location. tiled routing - method of building a path on graph data that has been split into square cells. time - the number of seconds estimated to complete a maneuver or trip, including any additional costs. trip - results of an entire route, including locations, legs, and maneuvers. height - with respect to elevation, the height above or below sea level at a specific location (lat,lng). height with range - computing the range (cumulative distance) and height for a series of lat,lng pairs of a line or shape. This is very useful for charting/graphing.","title":"Terminology"},{"location":"terminology/#mobility-glossary","text":"break location - the start or end point of a route. cost - fixed costs in seconds that are added to both the path cost and the estimated time. costing model - set of costs for particular methods of travel, such as automobile or pedestrian. edge - a line connected between nodes factor - multiply the cost along an edge or road section in a way that influences the path to favor or avoid a particular attribute graph - a set of edges connected by nodes used for building a route location - a latitude, longitude coordinate pair, specified in decimal degrees that determines the routing and order of navigation. maneuver - an operation to be performed during navigation, such as a turn, and the expected duration of the movement. narration - textual guidance describing the maneuver to be performed, such as a turn, distance to travel, and expected time. path - the sequence of edges forming a route penalty - fixed costs in seconds that are only added to the path cost. Penalties can influence the route path determination but do not add to the estimated time along the path. route - sequence of edges and maneuvers forming the best travel path between locations given the available road network, costs, influence factors, and other inputs. short path - a route that attempts to minimize distance traveled over the constituent edges, but may not be the shortest distance. through location - an optional location to influence the route to travel through that location. tiled routing - method of building a path on graph data that has been split into square cells. time - the number of seconds estimated to complete a maneuver or trip, including any additional costs. trip - results of an entire route, including locations, legs, and maneuvers. height - with respect to elevation, the height above or below sea level at a specific location (lat,lng). height with range - computing the range (cumulative distance) and height for a series of lat,lng pairs of a line or shape. This is very useful for charting/graphing.","title":"Mobility glossary"},{"location":"testing/","text":"Unit tests \u00b6 Valhalla currently uses googletest for unit testing. The basics are covered in googletest primer More advanced topics are covered here Important things to note: * EXPECT_XXX macros mark the test as failed but continue execution * Allows to test more at once * A preferred way over ASSERT_XXX * ASSERT_XXX family should be used when it's pointless to continue the test * e.g. the method we test returns nullptr instead of a valid pointer * Tests execution order is unspecified * If the order is needed fixtures or test suite environments may help * Sometimes it may hint the test design needs rethinking * Be careful with _ in test names - gtest joins a suite name with test name using _ * TEST(Foo, Basic_test) and TEST(Foo_Basic, test) will produce a conflict * In practice it never happens - no need to worry much about it * Be aware of curly braces{} inside macros * A typical case -> container with initializer list creation inside assert macro * Preprocessor is dumb and thinks commas separate the arguments * ASSERT_EQ(foo, vector{1,2,3}); * Fixing this can be done by adding () - ASSERT_EQ(foo, (vector{1,2,3})); * Disabling a test is easy - just prefix its name with DISABLED_ * TEST(PredictiveTraffic, DISABLED_test_predictive_traffic) * They are still compiled and there is always a warning each time the suite runs","title":"Unit tests"},{"location":"testing/#unit-tests","text":"Valhalla currently uses googletest for unit testing. The basics are covered in googletest primer More advanced topics are covered here Important things to note: * EXPECT_XXX macros mark the test as failed but continue execution * Allows to test more at once * A preferred way over ASSERT_XXX * ASSERT_XXX family should be used when it's pointless to continue the test * e.g. the method we test returns nullptr instead of a valid pointer * Tests execution order is unspecified * If the order is needed fixtures or test suite environments may help * Sometimes it may hint the test design needs rethinking * Be careful with _ in test names - gtest joins a suite name with test name using _ * TEST(Foo, Basic_test) and TEST(Foo_Basic, test) will produce a conflict * In practice it never happens - no need to worry much about it * Be aware of curly braces{} inside macros * A typical case -> container with initializer list creation inside assert macro * Preprocessor is dumb and thinks commas separate the arguments * ASSERT_EQ(foo, vector{1,2,3}); * Fixing this can be done by adding () - ASSERT_EQ(foo, (vector{1,2,3})); * Disabling a test is easy - just prefix its name with DISABLED_ * TEST(PredictiveTraffic, DISABLED_test_predictive_traffic) * They are still compiled and there is always a warning each time the suite runs","title":"Unit tests"},{"location":"thor/","text":"Thor \u00b6 Thor serves as a routing engine backed by tiled open source routing data. Thor is a companion to Sif which it relies heavily on to determine the appropriate graph traversal. The resulting path can be used as input for creating guidance/narrative. The name Thor was chosen as an acronym standing for: Tiled Hierarchical Open Routing and was the foundational idea around which the organization Valhalla and its Norse mythology theme was formed. The thor library is essentially a set of various data structures and alogrithms which deal with things like: A* graph traversal, edge costing, vertex costing and path construction. It also includes methods for computing time-distance matrices, optimized routing, and isochrones. Components \u00b6 What follows are some notable components of thor. PathAlgorithm \u00b6 Valhalla uses a couple different algorithms to generate the route path. Thor contains a base class, called PathAlgorithm , defining the route path comptution interface. The following classes are derived from PathAlgorithm : - AStar - This is a forward direction A* algorithm which is currently used only for \u201ctrivial paths\u201d where the origin and destination are on the same edge or adjacent, connected edges. - TimeDepForward - This is a forward direction A* algorithm meant to be used for time dependent routes where a departure time from the origin is specified. - TimeDepReverse - This is a revers direction A* algorithm meant to be used for time dependent routes where an arrival time at the destination is specified. - BidirectionalAStar - This is a bidirectional A* algorithm used for routes that are not time-dependent and are not trivial. - MultiModal - This is a forward direction A* algorithm with transit schedule lookup included as well as logic to switch modes between pedestrian and transit. This algorithm is time-dependent due to the nature of transit schedules. TripPathBuilder \u00b6 The PathAlgorithm methods all form a simple definition of the route path containing the directed edges comprising the path as well as the elapsed time at each edge along the path. This list is sent to a class called TripPathBuilder to form a more detailed representation of the trip path. TripPathBuilder forms details along the path that are required for guidance or narrative generation. Forming this TripPath requires reading attribution such as names, geometry, and other information required so that the subsequent guidance generation processing does not have to access the Valhalla tiles. Matrix, Isochrone, Optimized Routes \u00b6 Thor also includes methods to compute time-distance matrices, isochrones, and optimized routes (Traveling Salesman Problem).","title":"Thor"},{"location":"thor/#thor","text":"Thor serves as a routing engine backed by tiled open source routing data. Thor is a companion to Sif which it relies heavily on to determine the appropriate graph traversal. The resulting path can be used as input for creating guidance/narrative. The name Thor was chosen as an acronym standing for: Tiled Hierarchical Open Routing and was the foundational idea around which the organization Valhalla and its Norse mythology theme was formed. The thor library is essentially a set of various data structures and alogrithms which deal with things like: A* graph traversal, edge costing, vertex costing and path construction. It also includes methods for computing time-distance matrices, optimized routing, and isochrones.","title":"Thor"},{"location":"thor/#components","text":"What follows are some notable components of thor.","title":"Components"},{"location":"thor/#pathalgorithm","text":"Valhalla uses a couple different algorithms to generate the route path. Thor contains a base class, called PathAlgorithm , defining the route path comptution interface. The following classes are derived from PathAlgorithm : - AStar - This is a forward direction A* algorithm which is currently used only for \u201ctrivial paths\u201d where the origin and destination are on the same edge or adjacent, connected edges. - TimeDepForward - This is a forward direction A* algorithm meant to be used for time dependent routes where a departure time from the origin is specified. - TimeDepReverse - This is a revers direction A* algorithm meant to be used for time dependent routes where an arrival time at the destination is specified. - BidirectionalAStar - This is a bidirectional A* algorithm used for routes that are not time-dependent and are not trivial. - MultiModal - This is a forward direction A* algorithm with transit schedule lookup included as well as logic to switch modes between pedestrian and transit. This algorithm is time-dependent due to the nature of transit schedules.","title":"PathAlgorithm"},{"location":"thor/#trippathbuilder","text":"The PathAlgorithm methods all form a simple definition of the route path containing the directed edges comprising the path as well as the elapsed time at each edge along the path. This list is sent to a class called TripPathBuilder to form a more detailed representation of the trip path. TripPathBuilder forms details along the path that are required for guidance or narrative generation. Forming this TripPath requires reading attribution such as names, geometry, and other information required so that the subsequent guidance generation processing does not have to access the Valhalla tiles.","title":"TripPathBuilder"},{"location":"thor/#matrix-isochrone-optimized-routes","text":"Thor also includes methods to compute time-distance matrices, isochrones, and optimized routes (Traveling Salesman Problem).","title":"Matrix, Isochrone, Optimized Routes"},{"location":"tiles/","text":"Tile Specifications \u00b6 Hierarchies/Levels \u00b6 Tiles are split up into three levels or hierarchies. Hierarchy 0 contains edges pertaining to roads that are considered highway (motorway, trunk, and primary) roads and are stored in 4 degree tiles. Hierarchy 1 contains roads that are at a arterial level (secondary and tertiary) and are saved in 1 degree tiles. Finally, Hierarchy 2 contains roads that are considered at a local level (unclassified, residential, and service or other). These tiles are saved in .25 degree tiles. So in python, the levels are defined as: valhalla_tiles = [{'level': 2, 'size': 0.25}, {'level': 1, 'size': 1.0}, {'level': 0, 'size': 4.0}] The World at Level 0 \u00b6 The following image shows the world at level 0. Using a world bounding box (-180, -90, 180, 90) the world is split up into 4 degree tiles. The rows and columns start from the bottom left and increase to the top right. Tiles are row ordered increasing from west to east. Image generated using http://geojson.io Using a bounding box for Germany, Pennsylvania, and NYC we can show how the regions would be split up into the 3 levels. Level 0 is colored in light blue. Level 1 is light green and level 2 is light red. Germany \u00b6 Image generated using http://geojson.io Pennsylvania \u00b6 Image generated using http://geojson.io NYC \u00b6 Image generated using http://geojson.io Sample Tile Code \u00b6 Below are some sample functions to help you obtain latitude and longitude coordinates, levels, tile ids, and list of tiles that intersect a bounding box. #!/usr/bin/env python valhalla_tiles = [{ 'level' : 2 , 'size' : 0 .25 } , { 'level' : 1 , 'size' : 1 .0 } , { 'level' : 0 , 'size' : 4 .0 }] LEVEL_BITS = 3 TILE_INDEX_BITS = 22 ID_INDEX_BITS = 21 LEVEL_MASK = ( 2 **LEVEL_BITS ) - 1 TILE_INDEX_MASK = ( 2 **TILE_INDEX_BITS ) - 1 ID_INDEX_MASK = ( 2 **ID_INDEX_BITS ) - 1 INVALID_ID = ( ID_INDEX_MASK << ( TILE_INDEX_BITS + LEVEL_BITS )) | ( TILE_INDEX_MASK << LEVEL_BITS) | LEVEL_MASK def get_tile_level(id): return id & LEVEL_MASK def get_tile_index(id): return (id >> LEVEL_BITS ) & TILE_INDEX_MASK def get_index ( id ) : return ( id >> ( LEVEL_BITS + TILE_INDEX_BITS )) & ID_INDEX_MASK def tiles_for_bounding_box ( left, bottom, right, top ) : #if this is crossing the anti meridian split it up and combine if left > right: east = tiles_for_bounding_box ( left, bottom, 180 .0, top ) west = tiles_for_bounding_box ( -180.0, bottom, right, top ) return east + west #move these so we can compute percentages left += 180 right += 180 bottom += 90 top += 90 tiles = [] #for each size of tile for tile_set in valhalla_tiles: #for each column for x in range ( int ( left/tile_set [ 'size' ]) , int ( right/tile_set [ 'size' ]) + 1 ) : #for each row for y in range ( int ( bottom/tile_set [ 'size' ]) , int ( top/tile_set [ 'size' ]) + 1 ) : #give back the level and the tile index tiles.append (( tile_set [ 'level' ] , int ( y * ( 360 .0/tile_set [ 'size' ]) + x ))) return tiles def get_tile_id ( tile_level, lat, lon ) : level = list ( filter ( lambda x: x [ 'level' ] == tile_level, valhalla_tiles ))[ 0 ] width = int ( 360 / level [ 'size' ]) return int (( lat + 90 ) / level [ 'size' ]) * width + int (( lon + 180 ) / level [ 'size' ]) def get_ll ( id ) : tile_level = get_tile_level ( id ) tile_index = get_tile_index ( id ) level = list ( filter ( lambda x: x [ 'level' ] == tile_level, valhalla_tiles ))[ 0 ] width = int ( 360 / level [ 'size' ]) height = int ( 180 / level [ 'size' ]) return int ( tile_index / width ) * level [ 'size' ] - 90 , ( tile_index % width ) * level [ 'size' ] - 180 Get the Level or Hierarchy \u00b6 get_tile_level(73160266) returns a level of 2. 73160266 is a Valhalla Graphid. get_tile_level(142438865769) returns a level of 1. 142438865769 is an Open Traffic Segment id. Get the Latitude and Longitude from an ID \u00b6 get_ll(73160266) returns the bottom left corner of the level 2 tile. (41.25, -73.75) get_ll(142438865769) returns the bottom left corner of the level 1 tile. (14.0, 121.0) Get the Tile ID from a Latitude, Longitude, and Level \u00b6 get_tile_id(0, 14.601879, 120.972545) 2415 Tile would be on disk with the directory structure of /0/002/415.gph get_tile_id(1, 14.601879, 120.972545) 37740 Tile would be on disk with the directory structure of /1/037/740.gph get_tile_id(2, 41.413203, -73.623787) 756425 Tile would be on disk with the directory structure of /2/000/756/425.gph Get Tile ID from an ID \u00b6 get_tile_index(73160266) Returns the tile id 756425. get_tile_index(142438865769) Returns the tile id 37741. Get Tiles That Intersect a Bounding Box \u00b6 tiles_for_bounding_box(-74.251961,40.512764,-73.755405,40.903125) Returns a list of tiles for the NYC bounding box at each level. [(2, 752102), (2, 753542), (2, 752103), (2, 753543), (2, 752104), (2, 753544), (1, 46905), (1, 46906), (0, 2906)]","title":"Tile structure"},{"location":"tiles/#tile-specifications","text":"","title":"Tile Specifications"},{"location":"tiles/#hierarchieslevels","text":"Tiles are split up into three levels or hierarchies. Hierarchy 0 contains edges pertaining to roads that are considered highway (motorway, trunk, and primary) roads and are stored in 4 degree tiles. Hierarchy 1 contains roads that are at a arterial level (secondary and tertiary) and are saved in 1 degree tiles. Finally, Hierarchy 2 contains roads that are considered at a local level (unclassified, residential, and service or other). These tiles are saved in .25 degree tiles. So in python, the levels are defined as: valhalla_tiles = [{'level': 2, 'size': 0.25}, {'level': 1, 'size': 1.0}, {'level': 0, 'size': 4.0}]","title":"Hierarchies/Levels"},{"location":"tiles/#the-world-at-level-0","text":"The following image shows the world at level 0. Using a world bounding box (-180, -90, 180, 90) the world is split up into 4 degree tiles. The rows and columns start from the bottom left and increase to the top right. Tiles are row ordered increasing from west to east. Image generated using http://geojson.io Using a bounding box for Germany, Pennsylvania, and NYC we can show how the regions would be split up into the 3 levels. Level 0 is colored in light blue. Level 1 is light green and level 2 is light red.","title":"The World at Level 0"},{"location":"tiles/#germany","text":"Image generated using http://geojson.io","title":"Germany"},{"location":"tiles/#pennsylvania","text":"Image generated using http://geojson.io","title":"Pennsylvania"},{"location":"tiles/#nyc","text":"Image generated using http://geojson.io","title":"NYC"},{"location":"tiles/#sample-tile-code","text":"Below are some sample functions to help you obtain latitude and longitude coordinates, levels, tile ids, and list of tiles that intersect a bounding box. #!/usr/bin/env python valhalla_tiles = [{ 'level' : 2 , 'size' : 0 .25 } , { 'level' : 1 , 'size' : 1 .0 } , { 'level' : 0 , 'size' : 4 .0 }] LEVEL_BITS = 3 TILE_INDEX_BITS = 22 ID_INDEX_BITS = 21 LEVEL_MASK = ( 2 **LEVEL_BITS ) - 1 TILE_INDEX_MASK = ( 2 **TILE_INDEX_BITS ) - 1 ID_INDEX_MASK = ( 2 **ID_INDEX_BITS ) - 1 INVALID_ID = ( ID_INDEX_MASK << ( TILE_INDEX_BITS + LEVEL_BITS )) | ( TILE_INDEX_MASK << LEVEL_BITS) | LEVEL_MASK def get_tile_level(id): return id & LEVEL_MASK def get_tile_index(id): return (id >> LEVEL_BITS ) & TILE_INDEX_MASK def get_index ( id ) : return ( id >> ( LEVEL_BITS + TILE_INDEX_BITS )) & ID_INDEX_MASK def tiles_for_bounding_box ( left, bottom, right, top ) : #if this is crossing the anti meridian split it up and combine if left > right: east = tiles_for_bounding_box ( left, bottom, 180 .0, top ) west = tiles_for_bounding_box ( -180.0, bottom, right, top ) return east + west #move these so we can compute percentages left += 180 right += 180 bottom += 90 top += 90 tiles = [] #for each size of tile for tile_set in valhalla_tiles: #for each column for x in range ( int ( left/tile_set [ 'size' ]) , int ( right/tile_set [ 'size' ]) + 1 ) : #for each row for y in range ( int ( bottom/tile_set [ 'size' ]) , int ( top/tile_set [ 'size' ]) + 1 ) : #give back the level and the tile index tiles.append (( tile_set [ 'level' ] , int ( y * ( 360 .0/tile_set [ 'size' ]) + x ))) return tiles def get_tile_id ( tile_level, lat, lon ) : level = list ( filter ( lambda x: x [ 'level' ] == tile_level, valhalla_tiles ))[ 0 ] width = int ( 360 / level [ 'size' ]) return int (( lat + 90 ) / level [ 'size' ]) * width + int (( lon + 180 ) / level [ 'size' ]) def get_ll ( id ) : tile_level = get_tile_level ( id ) tile_index = get_tile_index ( id ) level = list ( filter ( lambda x: x [ 'level' ] == tile_level, valhalla_tiles ))[ 0 ] width = int ( 360 / level [ 'size' ]) height = int ( 180 / level [ 'size' ]) return int ( tile_index / width ) * level [ 'size' ] - 90 , ( tile_index % width ) * level [ 'size' ] - 180","title":"Sample Tile Code"},{"location":"tiles/#get-the-level-or-hierarchy","text":"get_tile_level(73160266) returns a level of 2. 73160266 is a Valhalla Graphid. get_tile_level(142438865769) returns a level of 1. 142438865769 is an Open Traffic Segment id.","title":"Get the Level or Hierarchy"},{"location":"tiles/#get-the-latitude-and-longitude-from-an-id","text":"get_ll(73160266) returns the bottom left corner of the level 2 tile. (41.25, -73.75) get_ll(142438865769) returns the bottom left corner of the level 1 tile. (14.0, 121.0)","title":"Get the Latitude and Longitude from an ID"},{"location":"tiles/#get-the-tile-id-from-a-latitude-longitude-and-level","text":"get_tile_id(0, 14.601879, 120.972545) 2415 Tile would be on disk with the directory structure of /0/002/415.gph get_tile_id(1, 14.601879, 120.972545) 37740 Tile would be on disk with the directory structure of /1/037/740.gph get_tile_id(2, 41.413203, -73.623787) 756425 Tile would be on disk with the directory structure of /2/000/756/425.gph","title":"Get the Tile ID from a Latitude, Longitude, and Level"},{"location":"tiles/#get-tile-id-from-an-id","text":"get_tile_index(73160266) Returns the tile id 756425. get_tile_index(142438865769) Returns the tile id 37741.","title":"Get Tile ID from an ID"},{"location":"tiles/#get-tiles-that-intersect-a-bounding-box","text":"tiles_for_bounding_box(-74.251961,40.512764,-73.755405,40.903125) Returns a list of tiles for the NYC bounding box at each level. [(2, 752102), (2, 753542), (2, 752103), (2, 753543), (2, 752104), (2, 753544), (1, 46905), (1, 46906), (0, 2906)]","title":"Get Tiles That Intersect a Bounding Box"},{"location":"tyr/","text":"Tyr \u00b6 Tyr is a service layer taking locations and options as input and returning a route and maneuvers as output essentially linking together all other projects under the valhalla organization. In keeping with the Norse mythological theme, the name Tyr was chosen as backcronym standing for: Take Your Route. Since this software deals mostly with providing routes based on http requests, this seemed like a fitting name! Tyr is essentially a set of various data structures and alogrithms which deal with things like: data marshalling, http, request parsing, response serializing, and interprocess communication. Components \u00b6 What follows are some notable components of tyr.","title":"Tyr (service layer)"},{"location":"tyr/#tyr","text":"Tyr is a service layer taking locations and options as input and returning a route and maneuvers as output essentially linking together all other projects under the valhalla organization. In keeping with the Norse mythological theme, the name Tyr was chosen as backcronym standing for: Take Your Route. Since this software deals mostly with providing routes based on http requests, this seemed like a fitting name! Tyr is essentially a set of various data structures and alogrithms which deal with things like: data marshalling, http, request parsing, response serializing, and interprocess communication.","title":"Tyr"},{"location":"tyr/#components","text":"What follows are some notable components of tyr.","title":"Components"},{"location":"valhalla-intro/","text":"Valhalla open source routing \u00b6 This is the early history of Valhalla. Routing is a wily beast and many valiant efforts have been made to slay it, with limited success. However, we have brought a mighty new Mj\u00f6lnir-like weapon to bear on this beast: Open Source! After much intense battle development we are proud to take the wraps off of Valhalla. Valhalla is open source routing software using open source data (primarily Open Street Map), with a very liberal license. This should allow for transparency in development, encourage contribution and community input, and foster use in other projects. The name is inspired by key features of the routing engine: the core route engine is called THOR (Tiled, Hierarchical Open Routing), generation of trip information for the path is called ODIN (Open Directions and Improved Narrative) and the service component is called TYR (Take Your Route). Valhalla seemed like a fitting organization name -- previous efforts may have died but we all get to fight on in the great hall that is Open Source. Valhalla developers know routing. We have worked together as a team for over a decade and have complementary skills that allow efficient software development. Our experience includes both commercial and OSM routing. We are well versed in scaling routing services to handle millions of requests per day. Performance and scalability is important, but our primary focus will be creating high quality routes, guidance, and directions. Existing open-source routing engines derive from academic research, resulting in fast routing algorithms over large graphs/networks. There are many properties of road networks that must be considered to produce quality routes and guidance/narrative descriptions. Rather than wrap these decisions into a baked costing model we choose to add most attribution to the graph data and allow dynamic, run-time costing. This should allow others to contribute and apply costing models and also allow flexible use of alternate costing to produce routes with different characteristics. There are other key features that we hope distinguish Valhalla from other systems and encourage developers to build systems around the service and contribute back to the project. These features include: Multimodal and time-based routing \u00b6 While the initial development phase of Valhalla will focus on single mode trips, we want to quickly move to support mixing auto, pedestrian, bike and public transportation in the same route. Support for public transit requires time and schedule dependent routing and must support tracking time along a path and can potentially support setting a time by which one must arrive at a location. From day one the design of Valhalla has been influenced by multi-modal considerations. Tiled, hierarchical data \u00b6 Lets face it, building routing data sets from OSM is not easy. We wondered why routing data couldn\u2019t be treated like vector map data - use a tiled data structure to allow easy downloading and updating of regions. Graph (the route data structure) tiles can be downloaded for use by client-side routing applications or by hosted services that don\u2019t want to go through the pain of data creation. A structured graph hierarchy (e.g., highways, arterials, local, transit) along with shortcut edges will ensure high performance. THOR should allow for smaller memory footprints on memory constrained devices and provide a means for regional extracts and partial updates. Take your route (TYR) \u00b6 Tyr signifies another fitting theme both from Norse mythology and from our open approach. Initially, Tyr will be our routing service where users can generate routes for mobile or web use. We plan to build methods to download tiled route data to allow unconnected, client-side features like off-line routing where users can \"take your route\" on the road or download graph tiles for a region and be able to use their device in places they might not have connectivity. Features like client-side \u201creturn to route\u201d and off-line routing are possible. Flexibility and extensibility \u00b6 We want to encourage others to contribute their expertise and local knowledge to routing and guidance/narrative. What makes a good route in one country/region may not hold true in another country. Having the ability to create dynamic and extensible \u201cplug-in\u201d code to perform costing/weighting may encourage others to use and extend Valhalla. Dynamic costing will also help create alternate route paths (at run time - without generating different data sets) and allow new costing methods for specialized use cases: truck routing, green/eco routing, and perhaps least cost routing. Within narrative and guidance generation software we want to provide means of adding custom narrative phrases and perhaps other means of extending or adding custom plug-ins to tailor the output to a user\u2019s need. Open directions and improved narrative (ODIN) \u00b6 A quality route result is more than just a path shape and long list of road names with simple turns and dreaded \"continue\" instructions. ODIN will be responsible for transforming path information into guidance and narrative directions that are easy to understand, useful, and assist users during their trip. Exit information and directional information on highways will help remove ambiguity at key decision points along the route. For example: - Take exit 51B on the right onto I 81 North toward I 78/Hazleton/Allentown ODIN collapses maneuvers using common base street names and simplifies transitions at complex intersections. Landmarks and other related information are also planned. Guidance and route explication must also be able to be tailored to different languages and potential uses - so extensibility and contributions from others are key.","title":"Introduction for Users"},{"location":"valhalla-intro/#valhalla-open-source-routing","text":"This is the early history of Valhalla. Routing is a wily beast and many valiant efforts have been made to slay it, with limited success. However, we have brought a mighty new Mj\u00f6lnir-like weapon to bear on this beast: Open Source! After much intense battle development we are proud to take the wraps off of Valhalla. Valhalla is open source routing software using open source data (primarily Open Street Map), with a very liberal license. This should allow for transparency in development, encourage contribution and community input, and foster use in other projects. The name is inspired by key features of the routing engine: the core route engine is called THOR (Tiled, Hierarchical Open Routing), generation of trip information for the path is called ODIN (Open Directions and Improved Narrative) and the service component is called TYR (Take Your Route). Valhalla seemed like a fitting organization name -- previous efforts may have died but we all get to fight on in the great hall that is Open Source. Valhalla developers know routing. We have worked together as a team for over a decade and have complementary skills that allow efficient software development. Our experience includes both commercial and OSM routing. We are well versed in scaling routing services to handle millions of requests per day. Performance and scalability is important, but our primary focus will be creating high quality routes, guidance, and directions. Existing open-source routing engines derive from academic research, resulting in fast routing algorithms over large graphs/networks. There are many properties of road networks that must be considered to produce quality routes and guidance/narrative descriptions. Rather than wrap these decisions into a baked costing model we choose to add most attribution to the graph data and allow dynamic, run-time costing. This should allow others to contribute and apply costing models and also allow flexible use of alternate costing to produce routes with different characteristics. There are other key features that we hope distinguish Valhalla from other systems and encourage developers to build systems around the service and contribute back to the project. These features include:","title":"Valhalla open source routing"},{"location":"valhalla-intro/#multimodal-and-time-based-routing","text":"While the initial development phase of Valhalla will focus on single mode trips, we want to quickly move to support mixing auto, pedestrian, bike and public transportation in the same route. Support for public transit requires time and schedule dependent routing and must support tracking time along a path and can potentially support setting a time by which one must arrive at a location. From day one the design of Valhalla has been influenced by multi-modal considerations.","title":"Multimodal and time-based routing"},{"location":"valhalla-intro/#tiled-hierarchical-data","text":"Lets face it, building routing data sets from OSM is not easy. We wondered why routing data couldn\u2019t be treated like vector map data - use a tiled data structure to allow easy downloading and updating of regions. Graph (the route data structure) tiles can be downloaded for use by client-side routing applications or by hosted services that don\u2019t want to go through the pain of data creation. A structured graph hierarchy (e.g., highways, arterials, local, transit) along with shortcut edges will ensure high performance. THOR should allow for smaller memory footprints on memory constrained devices and provide a means for regional extracts and partial updates.","title":"Tiled, hierarchical data"},{"location":"valhalla-intro/#take-your-route-tyr","text":"Tyr signifies another fitting theme both from Norse mythology and from our open approach. Initially, Tyr will be our routing service where users can generate routes for mobile or web use. We plan to build methods to download tiled route data to allow unconnected, client-side features like off-line routing where users can \"take your route\" on the road or download graph tiles for a region and be able to use their device in places they might not have connectivity. Features like client-side \u201creturn to route\u201d and off-line routing are possible.","title":"Take your route (TYR)"},{"location":"valhalla-intro/#flexibility-and-extensibility","text":"We want to encourage others to contribute their expertise and local knowledge to routing and guidance/narrative. What makes a good route in one country/region may not hold true in another country. Having the ability to create dynamic and extensible \u201cplug-in\u201d code to perform costing/weighting may encourage others to use and extend Valhalla. Dynamic costing will also help create alternate route paths (at run time - without generating different data sets) and allow new costing methods for specialized use cases: truck routing, green/eco routing, and perhaps least cost routing. Within narrative and guidance generation software we want to provide means of adding custom narrative phrases and perhaps other means of extending or adding custom plug-ins to tailor the output to a user\u2019s need.","title":"Flexibility and extensibility"},{"location":"valhalla-intro/#open-directions-and-improved-narrative-odin","text":"A quality route result is more than just a path shape and long list of road names with simple turns and dreaded \"continue\" instructions. ODIN will be responsible for transforming path information into guidance and narrative directions that are easy to understand, useful, and assist users during their trip. Exit information and directional information on highways will help remove ambiguity at key decision points along the route. For example: - Take exit 51B on the right onto I 81 North toward I 78/Hazleton/Allentown ODIN collapses maneuvers using common base street names and simplifies transitions at complex intersections. Landmarks and other related information are also planned. Guidance and route explication must also be able to be tailored to different languages and potential uses - so extensibility and contributions from others are key.","title":"Open directions and improved narrative (ODIN)"},{"location":"api/","text":"Valhalla is an open-source toolkit for multimodal transportation, powered by open data. The APIs use the standard REST model of interaction with JSON serving as both the request and response formats. Please refer to a specific service's API documentation to learn about the various request/response properties. In addition to JSON request/response formats Valhalla also supports protocol buffers as request/response format. For more information regarding protocol buffer support see here . The route service guides you between points by car, bike, foot, and multimodal combinations involving walking and riding public transit. Your apps can use the results from the route service to plan multimodal journeys with narratives to guide users by text and by voice. Valhalla draws data from OpenStreetMap and from Transitland , the open transit data aggregation project. See the api documentation . Trying to run more than one errand in the day or start your own delivery service? The optimized route service computes the times and distances between many origins and destinations and provides you with an optimized path between the locations. See the api documentation . If you want only a table of the times and distances, start with the matrix service. See the api documentation . Use the isochrone service to get a computation of areas that are reachable within specified time periods from a location or set of locations. See the api documentation . The map-matching service matches coordinates to known roads so you can turn a path into a route with narrative instructions and get the attribute values from that matched line. See the api documentation . Use the elevation service to find the elevation along a path or at specified locations. See the api documentation . You can use the expansion service to return a geojson representation of a graph traversal at a given location. See the api documentation . The locate service allows you to get detailed metadata about the nodes and edges in the graph. See the api documentation . The status service is a simple service that returns information about the running server or valhalla instance. See the api documentation . The centroid service allows you to find the least cost convergence point of routes from multiple locations. Documentation coming soonish.","title":"API Overview"},{"location":"api/protocol-buffers/","text":"Support for Protocol Buffers as Request/Response Formats (BETA) \u00b6 Valhalla allows users to interact with its service (and bindings/library) directly using pbf objects/bytes in addition to the conventional JSON request/response formats. This feature is currently in beta meaning that we are still actively developing it and there are likely still some bugs to work out before it's ready for widespread use. Most importantly, we reserve the right to make organizational changes to the protobuf schema while the label beta is still in effect. Valhalla keeps track of the state of a \"request\" as it is being processed through our various APIs using protobuf messages. In fact, when you call into our top level APIs like route locate isochrones etc, we parse your json directly into a protobuf object. We then pass that object around to different parts of the library adding to it as we fulfill the request. We extended this functionality such that, instead of passing json to the service/bindings/library you can pass protobuf bytes or objects and get back protobuf bytes or objects. Motivations \u00b6 There are a couple good reasons for this. As formats go, protobuf has many benefits over json: speed of serialization and deserialization over the wire size backward/forward compatibility working with an object on both sides of the network which eventually leads to gRPC The major drawback is that protobuf is a binary format so if you have just the bytes they aren't much good to you. Request \u00b6 To use protobuf as a request/input to the HTTP API you need to do two things: Send the proper HTTP header to signal a protobuf payload. The header should be: Content-Type: application/x-protobuf Send protocol buffer's serialized bytes as the body of the HTTP request The message we use for the entire transaction is the Api message, whose definition you can find here . All of the request parameters should be filled out via the Options message attached to the Api message. Most importantly, you will want to set your format to pbf and your action to the relevant API you are calling (though the HTTP request path also provides the latter). The options object also contains a subobject named pbf_field_selector which can be used to turn on/off the top level fields in the response. For example, if you only want the directions part of the protobuf response to be present (much smaller payload) then turn on only that flag in the field selector. The rest of the request options depend on which API you are calling. For more information about what and which options to set for a given API please read that APIs specific docs regarding its request options. Response \u00b6 As with the request/input, the response/output will again be the Api message but will have more parts of it filled out. Depending on which API you are calling different parts of the response object will be filled out. Route-like responses will have Trip and Directions objects filled out whereas non-route APIs will have different parts of the message filled out. Not all APIs support protobuf output. Those that don't, will return JSON as they do today. Currently, the following APIs support protobuf as output: route, trace_route, optimized_route, centroid, trace_attributes, status Future Work \u00b6 There are a few more things we should do before we can remove the beta label from this feature: Add Native PBF Support to Python Bindings : We can support, in addition to JSON strings, the ability for python to work directly with protobuf objects (those generated with protoc) across the python/c++ barrier. This would be a very natural way for python users to interact with Valhalla. Support for All APIs : As mentioned above we only support a certain subset Valhalla's APIs, over time we can add the rest of the APIs to the Api message.","title":"Protocol Buffers"},{"location":"api/protocol-buffers/#support-for-protocol-buffers-as-requestresponse-formats-beta","text":"Valhalla allows users to interact with its service (and bindings/library) directly using pbf objects/bytes in addition to the conventional JSON request/response formats. This feature is currently in beta meaning that we are still actively developing it and there are likely still some bugs to work out before it's ready for widespread use. Most importantly, we reserve the right to make organizational changes to the protobuf schema while the label beta is still in effect. Valhalla keeps track of the state of a \"request\" as it is being processed through our various APIs using protobuf messages. In fact, when you call into our top level APIs like route locate isochrones etc, we parse your json directly into a protobuf object. We then pass that object around to different parts of the library adding to it as we fulfill the request. We extended this functionality such that, instead of passing json to the service/bindings/library you can pass protobuf bytes or objects and get back protobuf bytes or objects.","title":"Support for Protocol Buffers as Request/Response Formats (BETA)"},{"location":"api/protocol-buffers/#motivations","text":"There are a couple good reasons for this. As formats go, protobuf has many benefits over json: speed of serialization and deserialization over the wire size backward/forward compatibility working with an object on both sides of the network which eventually leads to gRPC The major drawback is that protobuf is a binary format so if you have just the bytes they aren't much good to you.","title":"Motivations"},{"location":"api/protocol-buffers/#request","text":"To use protobuf as a request/input to the HTTP API you need to do two things: Send the proper HTTP header to signal a protobuf payload. The header should be: Content-Type: application/x-protobuf Send protocol buffer's serialized bytes as the body of the HTTP request The message we use for the entire transaction is the Api message, whose definition you can find here . All of the request parameters should be filled out via the Options message attached to the Api message. Most importantly, you will want to set your format to pbf and your action to the relevant API you are calling (though the HTTP request path also provides the latter). The options object also contains a subobject named pbf_field_selector which can be used to turn on/off the top level fields in the response. For example, if you only want the directions part of the protobuf response to be present (much smaller payload) then turn on only that flag in the field selector. The rest of the request options depend on which API you are calling. For more information about what and which options to set for a given API please read that APIs specific docs regarding its request options.","title":"Request"},{"location":"api/protocol-buffers/#response","text":"As with the request/input, the response/output will again be the Api message but will have more parts of it filled out. Depending on which API you are calling different parts of the response object will be filled out. Route-like responses will have Trip and Directions objects filled out whereas non-route APIs will have different parts of the message filled out. Not all APIs support protobuf output. Those that don't, will return JSON as they do today. Currently, the following APIs support protobuf as output: route, trace_route, optimized_route, centroid, trace_attributes, status","title":"Response"},{"location":"api/protocol-buffers/#future-work","text":"There are a few more things we should do before we can remove the beta label from this feature: Add Native PBF Support to Python Bindings : We can support, in addition to JSON strings, the ability for python to work directly with protobuf objects (those generated with protoc) across the python/c++ barrier. This would be a very natural way for python users to interact with Valhalla. Support for All APIs : As mentioned above we only support a certain subset Valhalla's APIs, over time we can add the rest of the APIs to the Api message.","title":"Future Work"},{"location":"api/elevation/api-reference/","text":"Elevation service API reference \u00b6 Valhalla's elevation lookup service provides digital elevation model (DEM) data as the result of a query. The elevation service data has many applications when combined with other routing and navigation data, including computing the steepness of roads and paths or generating an elevation profile chart along a route. For example, you can get elevation data for a point, a trail, or a trip. You might use the results to consider hills for your bicycle trip, or when estimating battery usage for trips in electric vehicles. View an interactive demo here . Inputs of the elevation service \u00b6 The elevation service currently has a single action, /height? , that can be requested. The height provides the elevation at a set of input locations, which are specified as either a shape or an encoded_polyline . The shape option uses an ordered list of one or more locations within a JSON array, while an encoded polyline stores multiple locations within a single string. If you include a range parameter and set it to true , both the height and cumulative distance are returned for each point. The elevation service also supports sampling the input shape or encoded polyline in uniform intervals along the path defined by the successive locations. If you include a resample_distance parameter with a distance in meters the elevation service will resample the input polyline at the requested resample_distance and return heights (and cumulative distance if requested) at the resampled locations. The resampled polyline is also returned. An elevation service request takes the form of servername/height?json={} , where the JSON inputs inside the {} includes location information and the optional range parameter. There is an option to name your elevation request. You can do this by appending the following to your request &id= . The id is returned with the response so a user could match to the corresponding request. Height Precision \u00b6 By default, all height values are returned as integer values. This works fine for most cases. However, using integer precision when charting elevation results along a nearly flat road can lead to \"stair step\" changes in elevation. Height data can be returned with 1 or 2 digits decimal precision by specifying height_precision . Height precision Description height_precision Specifies the precision (number of decimal places) of all returned height values. Values of 0 , 1 , or 2 are admissable. Defaults to 0 (integer precision). Any other value will result in integer precision (0 decimal places). Use a shape list for input locations \u00b6 The elevation request run locally takes the form of localhost:8002/height?json={} , where the JSON inputs inside the {} are described below. A shape request must include a latitude and longitude in decimal degrees, and the locations are visited in the order specified. The input coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. These parameters are available for shape . Shape parameters Description lat Latitude of the location in degrees. lon Longitude of the location in degrees. Here is an example JSON payload for a profile request using shape : { \"range\" : true , \"shape\" :[{ \"lat\" : 40.712431 , \"lon\" : -76.504916 },{ \"lat\" : 40.712275 , \"lon\" : -76.605259 },{ \"lat\" : 40.712122 , \"lon\" : -76.805694 },{ \"lat\" : 40.722431 , \"lon\" : -76.884916 },{ \"lat\" : 40.812275 , \"lon\" : -76.905259 },{ \"lat\" : 40.912122 , \"lon\" : -76.965694 }]} &id=Po tts ville This request provides shape points near Pottsville, Pennsylvania. The resulting profile response displays the input shape, as well as the range and height (as range_height in the response) for each point. { \"shape\" :[{ \"lat\" : 40.712433 , \"lon\" : -76.504913 },{ \"lat\" : 40.712276 , \"lon\" : -76.605263 },{ \"lat\" : 40.712124 , \"lon\" : -76.805695 },{ \"lat\" : 40.722431 , \"lon\" : -76.884918 },{ \"lat\" : 40.812275 , \"lon\" : -76.905258 },{ \"lat\" : 40.912121 , \"lon\" : -76.965691 }], \"range_height\" :[[ 0 , 307 ],[ 8467 , 272 ],[ 25380 , 204 ],[ 32162 , 204 ],[ 42309 , 180 ],[ 54533 , 198 ]]} Without the range , the result looks something like this, with only a height : { \"shape\" :[{ \"lat\" : 40.712433 , \"lon\" : -76.504913 },{ \"lat\" : 40.712276 , \"lon\" : -76.605263 },{ \"lat\" : 40.712124 , \"lon\" : -76.805695 },{ \"lat\" : 40.722431 , \"lon\" : -76.884918 },{ \"lat\" : 40.812275 , \"lon\" : -76.905258 },{ \"lat\" : 40.912121 , \"lon\" : -76.965691 }], \"height\" :[ 307 , 272 , 204 , 204 , 180 , 198 ]} Use an encoded polyline for input locations \u00b6 The encoded_polyline parameter is a string of a polyline-encoded, with the specified precision , shape and has the following parameters. Details on polyline encoding and decoding can be found here . Encoded polyline parameters Description shape_format polyline6 or polyline5 . Specifies whether the polyline is encoded with 6 digit precision (polyline6) or 5 digit precision (polyline5). If shape_format is not specified, the encoded polyline is expected to be 6 digit precision. encoded_polyline A set of encoded latitude, longitude pairs of a line or shape. Here is an example of the JSON payload for an encoded_polyline POST request: { \"range\" : true , \"encoded_polyline\" : \"s{cplAfiz{pCa]xBxBx`AhC|gApBrz@{[hBsZhB_c@rFodDbRaG\\\\ypAfDec@l@mrBnHg|@?}TzAia@dFw^xKqWhNe^hWegBfvAcGpG{dAdy@_`CpoBqGfC_SnI{KrFgx@?ofA_Tus@c[qfAgw@s_Agc@}^}JcF{@_Dz@eFfEsArEs@pHm@pg@wDpkEx\\\\vjT}Djj@eUppAeKzj@eZpuE_IxaIcF~|@cBngJiMjj@_I`HwXlJuO^kKj@gJkAeaBy`AgNoHwDkAeELwD|@uDfC_i@bq@mOjUaCvDqBrEcAbGWbG|@jVd@rPkAbGsAfDqBvCaIrFsP~RoNjWajBlnD{OtZoNfXyBtE{B~HyAtEsFhL_DvDsGrF_I`HwDpGoH|T_IzLaMzKuOrFqfAbPwCl@_h@fN}OnI\" } Get height and distance with the range parameter \u00b6 The range parameter is a boolean value that controls whether or not the returned array is one-dimensional (height only) or two-dimensional (with a range and height). This can be used to generate a graph along a route, because a 2D-array has values for x (the range) and y (the height) at each shape point. Steepness or gradient can also be computed from a profile request (e.g. when range = true ). The range is optional and assumed to be false if omitted. Range parameters Description range true or false . Defaults to false . Resampling \u00b6 The resample_distance parameter is a numeric value specifying the distance at which the input polyline is sampled in order to provide uniform distances between samples along the polyline. Sampling parameter Description resample_distance Numeric value indicating the sampling distance in meters. Other request options \u00b6 Options Description id Name your elevation request. If id is specified, the naming will be sent thru to the response. Outputs of the elevation service \u00b6 If an elevation request has been named using the optional &id= input, then the name will be returned as a string id . The profile results are returned with the form of shape (shape points or encoded polylines) that was supplied in the request, along with a 2D array representing the x and y of each input point in the elevation profile. Item Description shape The specified shape coordinates from the input request. encoded_polyline The specified encoded polyline, with six degrees of precision, coordinates from the input request. range_height The 2D array of range (x) and height (y) per input latitude, longitude coordinate. x coordinate The range or distance along the input locations. It is the cumulative distance along the previous latitiude, longitude coordinates up to the current coordinate. The x-value for the first coordinate in the shape will always be 0. y coordinate The height or elevation of the associated latitude, longitude pair. The height is returned as null if no height data exists for a given location. height An array of height for the associated latitude, longitude coordinates. warnings (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc. Data sources \u00b6 Elevation data is obtained from the Amazon Web Services Public Datasets .","title":"Elevation API"},{"location":"api/elevation/api-reference/#elevation-service-api-reference","text":"Valhalla's elevation lookup service provides digital elevation model (DEM) data as the result of a query. The elevation service data has many applications when combined with other routing and navigation data, including computing the steepness of roads and paths or generating an elevation profile chart along a route. For example, you can get elevation data for a point, a trail, or a trip. You might use the results to consider hills for your bicycle trip, or when estimating battery usage for trips in electric vehicles. View an interactive demo here .","title":"Elevation service API reference"},{"location":"api/elevation/api-reference/#inputs-of-the-elevation-service","text":"The elevation service currently has a single action, /height? , that can be requested. The height provides the elevation at a set of input locations, which are specified as either a shape or an encoded_polyline . The shape option uses an ordered list of one or more locations within a JSON array, while an encoded polyline stores multiple locations within a single string. If you include a range parameter and set it to true , both the height and cumulative distance are returned for each point. The elevation service also supports sampling the input shape or encoded polyline in uniform intervals along the path defined by the successive locations. If you include a resample_distance parameter with a distance in meters the elevation service will resample the input polyline at the requested resample_distance and return heights (and cumulative distance if requested) at the resampled locations. The resampled polyline is also returned. An elevation service request takes the form of servername/height?json={} , where the JSON inputs inside the {} includes location information and the optional range parameter. There is an option to name your elevation request. You can do this by appending the following to your request &id= . The id is returned with the response so a user could match to the corresponding request.","title":"Inputs of the elevation service"},{"location":"api/elevation/api-reference/#height-precision","text":"By default, all height values are returned as integer values. This works fine for most cases. However, using integer precision when charting elevation results along a nearly flat road can lead to \"stair step\" changes in elevation. Height data can be returned with 1 or 2 digits decimal precision by specifying height_precision . Height precision Description height_precision Specifies the precision (number of decimal places) of all returned height values. Values of 0 , 1 , or 2 are admissable. Defaults to 0 (integer precision). Any other value will result in integer precision (0 decimal places).","title":"Height Precision"},{"location":"api/elevation/api-reference/#use-a-shape-list-for-input-locations","text":"The elevation request run locally takes the form of localhost:8002/height?json={} , where the JSON inputs inside the {} are described below. A shape request must include a latitude and longitude in decimal degrees, and the locations are visited in the order specified. The input coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. These parameters are available for shape . Shape parameters Description lat Latitude of the location in degrees. lon Longitude of the location in degrees. Here is an example JSON payload for a profile request using shape : { \"range\" : true , \"shape\" :[{ \"lat\" : 40.712431 , \"lon\" : -76.504916 },{ \"lat\" : 40.712275 , \"lon\" : -76.605259 },{ \"lat\" : 40.712122 , \"lon\" : -76.805694 },{ \"lat\" : 40.722431 , \"lon\" : -76.884916 },{ \"lat\" : 40.812275 , \"lon\" : -76.905259 },{ \"lat\" : 40.912122 , \"lon\" : -76.965694 }]} &id=Po tts ville This request provides shape points near Pottsville, Pennsylvania. The resulting profile response displays the input shape, as well as the range and height (as range_height in the response) for each point. { \"shape\" :[{ \"lat\" : 40.712433 , \"lon\" : -76.504913 },{ \"lat\" : 40.712276 , \"lon\" : -76.605263 },{ \"lat\" : 40.712124 , \"lon\" : -76.805695 },{ \"lat\" : 40.722431 , \"lon\" : -76.884918 },{ \"lat\" : 40.812275 , \"lon\" : -76.905258 },{ \"lat\" : 40.912121 , \"lon\" : -76.965691 }], \"range_height\" :[[ 0 , 307 ],[ 8467 , 272 ],[ 25380 , 204 ],[ 32162 , 204 ],[ 42309 , 180 ],[ 54533 , 198 ]]} Without the range , the result looks something like this, with only a height : { \"shape\" :[{ \"lat\" : 40.712433 , \"lon\" : -76.504913 },{ \"lat\" : 40.712276 , \"lon\" : -76.605263 },{ \"lat\" : 40.712124 , \"lon\" : -76.805695 },{ \"lat\" : 40.722431 , \"lon\" : -76.884918 },{ \"lat\" : 40.812275 , \"lon\" : -76.905258 },{ \"lat\" : 40.912121 , \"lon\" : -76.965691 }], \"height\" :[ 307 , 272 , 204 , 204 , 180 , 198 ]}","title":"Use a shape list for input locations"},{"location":"api/elevation/api-reference/#use-an-encoded-polyline-for-input-locations","text":"The encoded_polyline parameter is a string of a polyline-encoded, with the specified precision , shape and has the following parameters. Details on polyline encoding and decoding can be found here . Encoded polyline parameters Description shape_format polyline6 or polyline5 . Specifies whether the polyline is encoded with 6 digit precision (polyline6) or 5 digit precision (polyline5). If shape_format is not specified, the encoded polyline is expected to be 6 digit precision. encoded_polyline A set of encoded latitude, longitude pairs of a line or shape. Here is an example of the JSON payload for an encoded_polyline POST request: { \"range\" : true , \"encoded_polyline\" : \"s{cplAfiz{pCa]xBxBx`AhC|gApBrz@{[hBsZhB_c@rFodDbRaG\\\\ypAfDec@l@mrBnHg|@?}TzAia@dFw^xKqWhNe^hWegBfvAcGpG{dAdy@_`CpoBqGfC_SnI{KrFgx@?ofA_Tus@c[qfAgw@s_Agc@}^}JcF{@_Dz@eFfEsArEs@pHm@pg@wDpkEx\\\\vjT}Djj@eUppAeKzj@eZpuE_IxaIcF~|@cBngJiMjj@_I`HwXlJuO^kKj@gJkAeaBy`AgNoHwDkAeELwD|@uDfC_i@bq@mOjUaCvDqBrEcAbGWbG|@jVd@rPkAbGsAfDqBvCaIrFsP~RoNjWajBlnD{OtZoNfXyBtE{B~HyAtEsFhL_DvDsGrF_I`HwDpGoH|T_IzLaMzKuOrFqfAbPwCl@_h@fN}OnI\" }","title":"Use an encoded polyline for input locations"},{"location":"api/elevation/api-reference/#get-height-and-distance-with-the-range-parameter","text":"The range parameter is a boolean value that controls whether or not the returned array is one-dimensional (height only) or two-dimensional (with a range and height). This can be used to generate a graph along a route, because a 2D-array has values for x (the range) and y (the height) at each shape point. Steepness or gradient can also be computed from a profile request (e.g. when range = true ). The range is optional and assumed to be false if omitted. Range parameters Description range true or false . Defaults to false .","title":"Get height and distance with the range parameter"},{"location":"api/elevation/api-reference/#resampling","text":"The resample_distance parameter is a numeric value specifying the distance at which the input polyline is sampled in order to provide uniform distances between samples along the polyline. Sampling parameter Description resample_distance Numeric value indicating the sampling distance in meters.","title":"Resampling"},{"location":"api/elevation/api-reference/#other-request-options","text":"Options Description id Name your elevation request. If id is specified, the naming will be sent thru to the response.","title":"Other request options"},{"location":"api/elevation/api-reference/#outputs-of-the-elevation-service","text":"If an elevation request has been named using the optional &id= input, then the name will be returned as a string id . The profile results are returned with the form of shape (shape points or encoded polylines) that was supplied in the request, along with a 2D array representing the x and y of each input point in the elevation profile. Item Description shape The specified shape coordinates from the input request. encoded_polyline The specified encoded polyline, with six degrees of precision, coordinates from the input request. range_height The 2D array of range (x) and height (y) per input latitude, longitude coordinate. x coordinate The range or distance along the input locations. It is the cumulative distance along the previous latitiude, longitude coordinates up to the current coordinate. The x-value for the first coordinate in the shape will always be 0. y coordinate The height or elevation of the associated latitude, longitude pair. The height is returned as null if no height data exists for a given location. height An array of height for the associated latitude, longitude coordinates. warnings (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc.","title":"Outputs of the elevation service"},{"location":"api/elevation/api-reference/#data-sources","text":"Elevation data is obtained from the Amazon Web Services Public Datasets .","title":"Data sources"},{"location":"api/expansion/api-reference/","text":"Expansion service API reference (BETA) \u00b6 Routing algorithms find the best path by expanding their search from start nodes/edges across the routing network until the destination is reached (unidirectional) or both search branches meet (bidirectional). This service could be subject to change in terms of API until we remove the BETA label. The expansion service wraps the route and isochrone services and returns a GeoJSON with all network edges (way segments) the underlying routing algorithm visited during the expansion with relevant properties for each edge (e.g. duration & distance ). A top-level algorithm propertry informs about the used algorithm: unidirectional & bidirectional A* (for route ) and unidirectional Dijkstra (for isochrone ). Note , for even moderately long routes or isochrones the /expansion action can produce gigantic GeoJSON responses of 10s of MB. Inputs of the Expansion service \u00b6 Since this service wraps other services, the request format mostly follows the ones of the route and isochrone . Additionally, it accepts the following parameters: Parameter Description action (required) The service whose expansion should be tracked. Currently one of route or isochrone . skip_opposites (optional) If set to true the output won't contain an edge's opposing edge. Opposing edges can be thought of as both directions of one road segment. Of the two, we discard the directional edge with higher cost and keep the one with less cost. Default false. expansion_properties (optional) A JSON array of strings of the GeoJSON property keys you'd like to have in the response. One or multiple of \"durations\", \"distances\", \"costs\", \"edge_ids\", \"statuses\". Note , that each additional property will increase the output size by minimum ~ 25%. By default an empty properties object is returned. The expansion_properties choices are as follows: Property Description distances Returns the accumulated distance in meters for each edge in order of graph traversal. durations Returns the accumulated duration in seconds for each edge in order of graph traversal. costs Returns the accumulated cost for each edge in order of graph traversal. edge_ids Returns the internal edge IDs for each edge in order of graph traversal. Mostly interesting for debugging. statuses Returns the edge states for each edge in order of graph traversal. Mostly interesting for debugging. Can be one of \"r\" (reached), \"s\" (settled), \"c\" (connected). An example request is: { \"expansion_properties\" :[ \"distances\" , \"durations\" , \"costs\" ], \"contours\" :[{ \"time\" : 1.0 }], \"locations\" :[{ \"lon\" : 0.00026949361342338066 , \"lat\" : -0.00017966240895360996 }], \"costing\" : \"auto\" , \"action\" : \"isochrone\" } Outputs of the Expansion service \u00b6 In the service response, the expanded way segments are returned as GeoJSON . The geometry is a single MultiLineString with each LineString representing one way segment (edge). Due to the verbosity of the GeoJSON format, single geometry features would produce prohibitively huge responses. However, that also means that the properties contain arrays of the tracked attributes, where the indices are correlating to the coordinates array, i.e. the 3 rd element in a properties array will correspond to the 3 rd LineString in the MultiLineString geometry. The output will only contain the properties which were specified in the expansion_properties request array. If the parameter was omitted in the request, the output will contain an empty properties object. An example response for \"action\": \"isochrone\" is: { \"properties\" :{ \"algorithm\" : \"unidirectional_dijkstra\" }, \"type\" : \"FeatureCollection\" , \"features\" :[{ \"type\" : \"Feature\" , \"geometry\" :{ \"type\" : \"MultiLineString\" , \"coordinates\" :[[[ 0.00027 , -0.00017 ],[ 0.00027 , 0.0 ]],[[ 0.00027 , -0.00017 ],[ 0.00027 , -0.00035 ]],[[ 0.00027 , -0.00035 ],[ 0.00027 , -0.00017 ]],[[ 0.00027 , 0.0 ],[ 0.00027 , -0.00017 ]],[[ 0.00027 , -0.00017 ],[ 0.00053 , -0.00017 ]],[[ 0.00027 , -0.00017 ],[ 0.0 , -0.00017 ]],[[ 0.0 , -0.00017 ],[ 0.00027 , -0.00017 ]],[[ 0.00053 , -0.00017 ],[ 0.0008 , -0.00017 ]],[[ 0.0008 , -0.00017 ],[ 0.00053 , -0.00017 ]],[[ 0.00053 , -0.00017 ],[ 0.00027 , -0.00017 ]],[[ 0.00053 , -0.00017 ],[ 0.0008 , 0.0 ]]]}, \"properties\" :{ \"distances\" :[ 20 , 20 , 40 , 40 , 30 , 30 , 60 , 60 , 90 , 120 , 80 ], \"durations\" :[ 0 , 0 , 29 , 29 , 1 , 1 , 30 , 2 , 31 , 33 , 5 ], \"costs\" :[ 0 , 0 , 1 , 1 , 1 , 1 , 2 , 2 , 3 , 4 , 11 ]}}]} Credits \u00b6 The image includes data from OpenStreetMap and the \"Positron\" basemap by Carto .","title":"Expansion API"},{"location":"api/expansion/api-reference/#expansion-service-api-reference-beta","text":"Routing algorithms find the best path by expanding their search from start nodes/edges across the routing network until the destination is reached (unidirectional) or both search branches meet (bidirectional). This service could be subject to change in terms of API until we remove the BETA label. The expansion service wraps the route and isochrone services and returns a GeoJSON with all network edges (way segments) the underlying routing algorithm visited during the expansion with relevant properties for each edge (e.g. duration & distance ). A top-level algorithm propertry informs about the used algorithm: unidirectional & bidirectional A* (for route ) and unidirectional Dijkstra (for isochrone ). Note , for even moderately long routes or isochrones the /expansion action can produce gigantic GeoJSON responses of 10s of MB.","title":"Expansion service API reference (BETA)"},{"location":"api/expansion/api-reference/#inputs-of-the-expansion-service","text":"Since this service wraps other services, the request format mostly follows the ones of the route and isochrone . Additionally, it accepts the following parameters: Parameter Description action (required) The service whose expansion should be tracked. Currently one of route or isochrone . skip_opposites (optional) If set to true the output won't contain an edge's opposing edge. Opposing edges can be thought of as both directions of one road segment. Of the two, we discard the directional edge with higher cost and keep the one with less cost. Default false. expansion_properties (optional) A JSON array of strings of the GeoJSON property keys you'd like to have in the response. One or multiple of \"durations\", \"distances\", \"costs\", \"edge_ids\", \"statuses\". Note , that each additional property will increase the output size by minimum ~ 25%. By default an empty properties object is returned. The expansion_properties choices are as follows: Property Description distances Returns the accumulated distance in meters for each edge in order of graph traversal. durations Returns the accumulated duration in seconds for each edge in order of graph traversal. costs Returns the accumulated cost for each edge in order of graph traversal. edge_ids Returns the internal edge IDs for each edge in order of graph traversal. Mostly interesting for debugging. statuses Returns the edge states for each edge in order of graph traversal. Mostly interesting for debugging. Can be one of \"r\" (reached), \"s\" (settled), \"c\" (connected). An example request is: { \"expansion_properties\" :[ \"distances\" , \"durations\" , \"costs\" ], \"contours\" :[{ \"time\" : 1.0 }], \"locations\" :[{ \"lon\" : 0.00026949361342338066 , \"lat\" : -0.00017966240895360996 }], \"costing\" : \"auto\" , \"action\" : \"isochrone\" }","title":"Inputs of the Expansion service"},{"location":"api/expansion/api-reference/#outputs-of-the-expansion-service","text":"In the service response, the expanded way segments are returned as GeoJSON . The geometry is a single MultiLineString with each LineString representing one way segment (edge). Due to the verbosity of the GeoJSON format, single geometry features would produce prohibitively huge responses. However, that also means that the properties contain arrays of the tracked attributes, where the indices are correlating to the coordinates array, i.e. the 3 rd element in a properties array will correspond to the 3 rd LineString in the MultiLineString geometry. The output will only contain the properties which were specified in the expansion_properties request array. If the parameter was omitted in the request, the output will contain an empty properties object. An example response for \"action\": \"isochrone\" is: { \"properties\" :{ \"algorithm\" : \"unidirectional_dijkstra\" }, \"type\" : \"FeatureCollection\" , \"features\" :[{ \"type\" : \"Feature\" , \"geometry\" :{ \"type\" : \"MultiLineString\" , \"coordinates\" :[[[ 0.00027 , -0.00017 ],[ 0.00027 , 0.0 ]],[[ 0.00027 , -0.00017 ],[ 0.00027 , -0.00035 ]],[[ 0.00027 , -0.00035 ],[ 0.00027 , -0.00017 ]],[[ 0.00027 , 0.0 ],[ 0.00027 , -0.00017 ]],[[ 0.00027 , -0.00017 ],[ 0.00053 , -0.00017 ]],[[ 0.00027 , -0.00017 ],[ 0.0 , -0.00017 ]],[[ 0.0 , -0.00017 ],[ 0.00027 , -0.00017 ]],[[ 0.00053 , -0.00017 ],[ 0.0008 , -0.00017 ]],[[ 0.0008 , -0.00017 ],[ 0.00053 , -0.00017 ]],[[ 0.00053 , -0.00017 ],[ 0.00027 , -0.00017 ]],[[ 0.00053 , -0.00017 ],[ 0.0008 , 0.0 ]]]}, \"properties\" :{ \"distances\" :[ 20 , 20 , 40 , 40 , 30 , 30 , 60 , 60 , 90 , 120 , 80 ], \"durations\" :[ 0 , 0 , 29 , 29 , 1 , 1 , 30 , 2 , 31 , 33 , 5 ], \"costs\" :[ 0 , 0 , 1 , 1 , 1 , 1 , 2 , 2 , 3 , 4 , 11 ]}}]}","title":"Outputs of the Expansion service"},{"location":"api/expansion/api-reference/#credits","text":"The image includes data from OpenStreetMap and the \"Positron\" basemap by Carto .","title":"Credits"},{"location":"api/isochrone/api-reference/","text":"Isochrone & Isodistance service API reference \u00b6 An isochrone is a line that connects points of equal travel time about a given location, from the Greek roots of iso for equal and chrone for time. Valhalla's isochrone service computes areas that are reachable within specified time intervals from a location, and returns the reachable regions as contours of polygons or lines that you can display on a map. Isodistances follow the same concept, but instead of time one specifies distance intervals. Isochrone maps share some of the same concepts and terminology with familiar topographic maps, which depict contour lines for points of equal elevation. For this reason other terms common in topography apply, such as contours or isolines. This is an example of 15, 30, 45 and 60 minute bicycle isochrones centered in Lancaster, PA. Inputs of the Isochrone service \u00b6 An isochrone request run locally takes the form of localhost:8002/isochrone?json={} , where the JSON inputs inside the {} includes an array of at least one location and options for the route costing model . For example, you can use the isochrone service to find out where you can travel within a 15-minute walk from your office building. The API request for this uses isochrone? as the request action, pedestrian costing, and a single contour for a 15-minute time interval. The response is GeoJSON, which you can display on a map to visualize where you might be able to walk. { \"locations\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 }], \"costing\" : \"pedestrian\" , \"contours\" :[{ \"time\" : 15.0 , \"color\" : \"ff0000\" }]} &id=Walk_From_O ff ice There is an option to name your isochrone request by appending &id= . The id is returned with the response so you can match it to your corresponding request. Location parameters \u00b6 The locations must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. External search services, such as Mapbox Geocoding can be used to find places and geocode addresses, whose coordinates can be used as input to the service. Location parameters Description lat Latitude of the location in degrees. lon Longitude of the location in degrees. Refer to the route location documentation for more information on specifying locations. Costing parameters \u00b6 The isochrone service uses the auto , bicycle , pedestrian , and multimodal costing models available in the Valhalla Turn-by-Turn service. Refer to the route costing models and costing options documentation for more on how to specify this input. Other request parameters \u00b6 Parameter Description date_time The local date and time at the location. These parameters apply only for multimodal requests and are not used with other costing methods. type 0 - Current departure time for multimodal requests. 1 - Specified departure time for multimodal requests. 2 - Specified arrival time. Note: This is not yet implemented. value - the date and time specified in ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. For example, \"2016-07-03T08:06\" id Name of the isochrone request. If id is specified, the name is returned with the response. contours A JSON array of contour objects with the time in minutes or distance in kilometers and color to use for each isochrone contour. You can specify up to four contours (by default). time - A floating point value specifying the time in minutes for the contour. distance - A floating point value specifying the distance in kilometers for the contour. color - The color for the output of the contour. Specify it as a Hex value , but without the # , such as \"color\":\"ff0000\" for red. If no color is specified, the isochrone service will assign a default color to the output. You can only specify one metric per contour , i.e. time or distance . polygons A Boolean value to determine whether to return geojson polygons or linestrings as the contours. The default is false , which returns lines; when true , polygons are returned. Note: When polygons is true , any contour that forms a ring is returned as a polygon. denoise A floating point value from 0 to 1 (default of 1 ) which can be used to remove smaller contours. A value of 1 will only return the largest contour for a given time value. A value of 0.5 drops any contours that are less than half the area of the largest contour in the set of contours for that same time value. generalize A floating point value in meters used as the tolerance for Douglas-Peucker generalization. Note: Generalization of contours can lead to self-intersections, as well as intersections of adjacent contours. show_locations A boolean indicating whether the input locations should be returned as MultiPoint features: one feature for the exact input coordinates and one feature for the coordinates of the network node it snapped to. Default false. Outputs of the Isochrone service \u00b6 In the service response, the isochrone contours are returned as GeoJSON , which can be integrated into mapping applications. The contours are calculated using rasters and are returned as either polygon or line features, depending on your input setting for the polygons parameter. If an isochrone request has been named using the optional &id= input, then the id is returned as a name property for the feature collection within the GeoJSON response. A metric attribute lets you know whether it's a distance or time contour. A warnings array may also be included. This array may contain warning objects informing about deprecated request parameters, clamped values etc. | See the HTTP return codes for more on messages you might receive from the service. Draw isochrones on a map \u00b6 Most JavaScript-based GeoJSON renderers, including Leaflet , can use the isochrone styling information directly from the response. At present, you cannot control the opacity through the API. When making a map, drawing the isochrone contours as lines is more straightforward than polygons, and, therefore, currently is the default and recommended method. When deciding between the output as lines and polygons, consider your use case and the additional styling considerations involved with polygons. For example, fills should be rendered as semi-transparent over the other map layers so they are visible, although you may have more flexibility when using a vector-based map. In addition, polygons from multiple contour levels do not have overlapping areas cut out or removed. In other words, the outer contours include the areas of any inner contours, causing the colors and transparencies to blend when multiple contour polygons are drawn at the same time. The Valhalla team has plans to improving the polygon isochrone output and rendering capabilities, including by demoting some rings to be inners of other rings and removing potential self-intersections in polygon geometries. Isochrone demonstration in Mobility Explorer \u00b6 The open-source Mobility Explorer tool helps you understand transportation networks around the world and has tools for adding isochrones to a map. Search for a location and add a point to the map, then generate isochrones for certain modes of transit from that location. Future work on the isochrone service \u00b6 The Isochrone service is in active development. To report software issues or suggest enhancements, open an issue in the Valhalla GitHub repository . Several other options are being considered as future service enhancements. These include: Using distance rather than time for each unit. Generating outer contours or contours with interior holes for regions that cannot be accessed within the specified time, including with options to control the minimum size of interior holes. Removing self intersections from polygonal contours. Allowing multiple locations to compute the region reachable from any of the locations within a specified time. Generating contours with reverse access logic to see the region that can reach a specific location within the specified time. Returning raster data for potential animation using OpenGL shaders. This also has analysis use for being able to query thousands of locations to determine the time to each location, including improvements with one-to-many requests to the Valhalla Time-Distance Matrix service. Data credits \u00b6 The image includes data from OpenStreetMap .","title":"Isochrone API"},{"location":"api/isochrone/api-reference/#isochrone-isodistance-service-api-reference","text":"An isochrone is a line that connects points of equal travel time about a given location, from the Greek roots of iso for equal and chrone for time. Valhalla's isochrone service computes areas that are reachable within specified time intervals from a location, and returns the reachable regions as contours of polygons or lines that you can display on a map. Isodistances follow the same concept, but instead of time one specifies distance intervals. Isochrone maps share some of the same concepts and terminology with familiar topographic maps, which depict contour lines for points of equal elevation. For this reason other terms common in topography apply, such as contours or isolines. This is an example of 15, 30, 45 and 60 minute bicycle isochrones centered in Lancaster, PA.","title":"Isochrone &amp; Isodistance service API reference"},{"location":"api/isochrone/api-reference/#inputs-of-the-isochrone-service","text":"An isochrone request run locally takes the form of localhost:8002/isochrone?json={} , where the JSON inputs inside the {} includes an array of at least one location and options for the route costing model . For example, you can use the isochrone service to find out where you can travel within a 15-minute walk from your office building. The API request for this uses isochrone? as the request action, pedestrian costing, and a single contour for a 15-minute time interval. The response is GeoJSON, which you can display on a map to visualize where you might be able to walk. { \"locations\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 }], \"costing\" : \"pedestrian\" , \"contours\" :[{ \"time\" : 15.0 , \"color\" : \"ff0000\" }]} &id=Walk_From_O ff ice There is an option to name your isochrone request by appending &id= . The id is returned with the response so you can match it to your corresponding request.","title":"Inputs of the Isochrone service"},{"location":"api/isochrone/api-reference/#location-parameters","text":"The locations must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. External search services, such as Mapbox Geocoding can be used to find places and geocode addresses, whose coordinates can be used as input to the service. Location parameters Description lat Latitude of the location in degrees. lon Longitude of the location in degrees. Refer to the route location documentation for more information on specifying locations.","title":"Location parameters"},{"location":"api/isochrone/api-reference/#costing-parameters","text":"The isochrone service uses the auto , bicycle , pedestrian , and multimodal costing models available in the Valhalla Turn-by-Turn service. Refer to the route costing models and costing options documentation for more on how to specify this input.","title":"Costing parameters"},{"location":"api/isochrone/api-reference/#other-request-parameters","text":"Parameter Description date_time The local date and time at the location. These parameters apply only for multimodal requests and are not used with other costing methods. type 0 - Current departure time for multimodal requests. 1 - Specified departure time for multimodal requests. 2 - Specified arrival time. Note: This is not yet implemented. value - the date and time specified in ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. For example, \"2016-07-03T08:06\" id Name of the isochrone request. If id is specified, the name is returned with the response. contours A JSON array of contour objects with the time in minutes or distance in kilometers and color to use for each isochrone contour. You can specify up to four contours (by default). time - A floating point value specifying the time in minutes for the contour. distance - A floating point value specifying the distance in kilometers for the contour. color - The color for the output of the contour. Specify it as a Hex value , but without the # , such as \"color\":\"ff0000\" for red. If no color is specified, the isochrone service will assign a default color to the output. You can only specify one metric per contour , i.e. time or distance . polygons A Boolean value to determine whether to return geojson polygons or linestrings as the contours. The default is false , which returns lines; when true , polygons are returned. Note: When polygons is true , any contour that forms a ring is returned as a polygon. denoise A floating point value from 0 to 1 (default of 1 ) which can be used to remove smaller contours. A value of 1 will only return the largest contour for a given time value. A value of 0.5 drops any contours that are less than half the area of the largest contour in the set of contours for that same time value. generalize A floating point value in meters used as the tolerance for Douglas-Peucker generalization. Note: Generalization of contours can lead to self-intersections, as well as intersections of adjacent contours. show_locations A boolean indicating whether the input locations should be returned as MultiPoint features: one feature for the exact input coordinates and one feature for the coordinates of the network node it snapped to. Default false.","title":"Other request parameters"},{"location":"api/isochrone/api-reference/#outputs-of-the-isochrone-service","text":"In the service response, the isochrone contours are returned as GeoJSON , which can be integrated into mapping applications. The contours are calculated using rasters and are returned as either polygon or line features, depending on your input setting for the polygons parameter. If an isochrone request has been named using the optional &id= input, then the id is returned as a name property for the feature collection within the GeoJSON response. A metric attribute lets you know whether it's a distance or time contour. A warnings array may also be included. This array may contain warning objects informing about deprecated request parameters, clamped values etc. | See the HTTP return codes for more on messages you might receive from the service.","title":"Outputs of the Isochrone service"},{"location":"api/isochrone/api-reference/#draw-isochrones-on-a-map","text":"Most JavaScript-based GeoJSON renderers, including Leaflet , can use the isochrone styling information directly from the response. At present, you cannot control the opacity through the API. When making a map, drawing the isochrone contours as lines is more straightforward than polygons, and, therefore, currently is the default and recommended method. When deciding between the output as lines and polygons, consider your use case and the additional styling considerations involved with polygons. For example, fills should be rendered as semi-transparent over the other map layers so they are visible, although you may have more flexibility when using a vector-based map. In addition, polygons from multiple contour levels do not have overlapping areas cut out or removed. In other words, the outer contours include the areas of any inner contours, causing the colors and transparencies to blend when multiple contour polygons are drawn at the same time. The Valhalla team has plans to improving the polygon isochrone output and rendering capabilities, including by demoting some rings to be inners of other rings and removing potential self-intersections in polygon geometries.","title":"Draw isochrones on a map"},{"location":"api/isochrone/api-reference/#isochrone-demonstration-in-mobility-explorer","text":"The open-source Mobility Explorer tool helps you understand transportation networks around the world and has tools for adding isochrones to a map. Search for a location and add a point to the map, then generate isochrones for certain modes of transit from that location.","title":"Isochrone demonstration in Mobility Explorer"},{"location":"api/isochrone/api-reference/#future-work-on-the-isochrone-service","text":"The Isochrone service is in active development. To report software issues or suggest enhancements, open an issue in the Valhalla GitHub repository . Several other options are being considered as future service enhancements. These include: Using distance rather than time for each unit. Generating outer contours or contours with interior holes for regions that cannot be accessed within the specified time, including with options to control the minimum size of interior holes. Removing self intersections from polygonal contours. Allowing multiple locations to compute the region reachable from any of the locations within a specified time. Generating contours with reverse access logic to see the region that can reach a specific location within the specified time. Returning raster data for potential animation using OpenGL shaders. This also has analysis use for being able to query thousands of locations to determine the time to each location, including improvements with one-to-many requests to the Valhalla Time-Distance Matrix service.","title":"Future work on the isochrone service"},{"location":"api/isochrone/api-reference/#data-credits","text":"The image includes data from OpenStreetMap .","title":"Data credits"},{"location":"api/locate/api-reference/","text":"Valhalla locate service API reference \u00b6 Valhalla's locate service, is an open-source service that provides detailed information about streets and intersections close to an input point with some added matching criteria. This allows for tight integration in routing and navigation applications on web or mobile. View an interactive demo The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page . Inputs of a locate request \u00b6 The locate request run locally takes the form of localhost:8002/locate?json={} , where the JSON inputs inside the {} include location information, name and options for the costing model, and output options. Here is the JSON payload for an example request: { \"verbose\" : true , \"locations\" :[{ \"lat\" : 42.358528 , \"lon\" : -83.271400 },{ \"lat\" : 42.996613 , \"lon\" : -78.749855 }], \"costing\" : \"bicycle\" , \"costing_options\" :{ \"bicycle\" :{ \"bicycle_type\" : \"road\" }}, \"directions_options\" :{ \"units\" : \"miles\" }, \"id\" : \"12abc3afe23984fe\" } This request provides detailed information about specific streets and intersections near the two input locations. Steets which do not have a surface type condusive to road bicycles will be excluded from the results. The units used for the lengths of the street sections will be displayed in miles. There is an option to name your request. You can do this by adding and id key to your request. The id is returned with the response so a user could match to the corresponding request. Because the locate service is designed to work in tandem with the route service API, the inputs for the two APIs are identical. For detailed options regarding specifiying locations, costing models, costing options, directions options please see the relevant sections in the routing API docs Other request options \u00b6 Options Description verbose Can be set to true or false , but defaults to false . If set to true dense attribution of the given street or intersection will be returned. id Name your route request. If id is specified, the naming will be sent through to the response. Outputs of a locate request \u00b6 If a request has been named using the optional id key, then this id key and value will be echoed in the JSON response object. The locate results are returned as a JSON array, with one JSON object per input location in the order specified. In verbose mode details about the streets and intersections includding mode of travel access, names, way ids, shape, side of street as well as the closest point to the input along these features will be returned. If verbose was not enabled only the closest point, way id and side of street will be returned. A warnings array may also be included. This array may contain warning objects informing about deprecated request parameters, clamped values etc. | Here are some sample results with verbose set to false : [ { \"input_lon\" : - 76.495743 , \"input_lat\" : 40.310555 , \"nodes\" : [ { \"lat\" : 40.313206 , \"lon\" : - 76.494987 } ], \"edges\" : [ { \"way_id\" : 12292268 , \"correlated_lat\" : 40.313206 , \"side_of_street\" : \"neither\" , \"percent_along\" : 0 , \"correlated_lon\" : - 76.494987 }, { \"way_id\" : 12292268 , \"correlated_lat\" : 40.313206 , \"side_of_street\" : \"neither\" , \"percent_along\" : 1 , \"correlated_lon\" : - 76.494987 } ], \"warnings\" : [ \"hov costing is deprecated and will be turned into auto costing with hov2=true costing option\" ] } ] Here are some sample results with verbose set to true : [ { \"input_lon\" : - 76.495743 , \"input_lat\" : 40.310555 , \"nodes\" : [ { \"traffic_signal\" : false , \"type\" : \"street_intersection\" , \"lat\" : 40.313206 , \"node_id\" : { \"id\" : 3080 , \"value\" : 103353655794 , \"tile_id\" : 750654 , \"level\" : 2 }, \"access\" : { \"wheelchair\" : true , \"taxi\" : false , \"HOV\" : true , \"truck\" : true , \"emergency\" : true , \"pedestrian\" : true , \"car\" : true , \"bus\" : true , \"bicycle\" : true }, \"lon\" : - 76.494987 , \"edge_count\" : 1 , \"administrative\" : { \"time_zone_posix\" : \"EST-05EDT+01,M3.2.0/02:00,M11.1.0/02:00\" , \"standard_time_zone_name\" : \"EST\" , \"iso_3166-1\" : \"US\" , \"daylight_savings_time_zone_name\" : \"EDT\" , \"country\" : \"United States of America\" , \"iso_3166-2\" : \"PA\" , \"state\" : \"Pennsylvania\" }, \"intersection_type\" : \"dead-end\" , \"density\" : 2 , \"local_edge_count\" : 1 , \"mode_change\" : false } ], \"edges\" : [ { \"edge_id\" : { \"id\" : 7660 , \"value\" : 257032954354 , \"tile_id\" : 750654 , \"level\" : 2 }, \"edge_info\" : { \"shape\" : \"ivo{kAvg{{pCiMlJ{FfDgDm@c_AqxBeFO}}@`]\" , \"way_id\" : 12292268 , \"names\" : [ \"Bomgardner Lane\" ] }, \"edge\" : { \"classification\" : { \"link\" : false , \"internal\" : false , \"surface\" : \"paved_smooth\" , \"classification\" : \"residential\" }, \"end_node\" : { \"id\" : 3081 , \"value\" : 103387210226 , \"tile_id\" : 750654 , \"level\" : 2 }, \"speed\" : 30 , \"traffic_signal\" : false , \"start_restriction\" : { \"moped\" : false , \"wheelchair\" : false , \"taxi\" : false , \"HOV\" : false , \"truck\" : false , \"emergency\" : false , \"pedestrian\" : false , \"car\" : false , \"bus\" : false , \"bicycle\" : false }, \"speed_limit\" : 0 , \"geo_attributes\" : { \"weighted_grade\" : 1.67 , \"length\" : 388 }, \"cycle_lane\" : \"none\" , \"access_restriction\" : false , \"part_of_complex_restriction\" : false , \"country_crossing\" : false , \"has_exit_sign\" : false , \"lane_count\" : 1 , \"speed_type\" : \"classified\" , \"drive_on_right\" : true , \"destination_only\" : false , \"seasonal\" : false , \"tunnel\" : false , \"bridge\" : false , \"access\" : { \"moped\" : true , \"wheelchair\" : true , \"taxi\" : false , \"HOV\" : true , \"truck\" : true , \"emergency\" : false , \"pedestrian\" : true , \"car\" : true , \"bus\" : true , \"bicycle\" : true }, \"toll\" : false , \"round_about\" : false , \"bike_network\" : { \"mountain\" : false , \"local\" : false , \"regional\" : false , \"national\" : false }, \"end_restriction\" : { \"moped\" : false , \"wheelchair\" : false , \"taxi\" : false , \"HOV\" : false , \"truck\" : false , \"emergency\" : false , \"pedestrian\" : false , \"car\" : false , \"bus\" : false , \"bicycle\" : false }, \"unreachable\" : false , \"forward\" : true , \"not_thru\" : false , \"truck_route\" : false , \"use\" : \"road\" }, \"minimum_reachability\" : 51 , \"score\" : 899846.4 , \"traffic_segments\" : [], \"percent_along\" : 0 , \"correlated_lon\" : - 76.494987 , \"side_of_street\" : \"neither\" , \"correlated_lat\" : 40.313206 }, { \"edge_id\" : { \"id\" : 7661 , \"value\" : 257066508786 , \"tile_id\" : 750654 , \"level\" : 2 }, \"edge_info\" : { \"shape\" : \"ivo{kAvg{{pCiMlJ{FfDgDm@c_AqxBeFO}}@`]\" , \"way_id\" : 12292268 , \"names\" : [ \"Bomgardner Lane\" ] }, \"edge\" : { \"classification\" : { \"link\" : false , \"internal\" : false , \"surface\" : \"paved_smooth\" , \"classification\" : \"residential\" }, \"end_node\" : { \"id\" : 3080 , \"value\" : 103353655794 , \"tile_id\" : 750654 , \"level\" : 2 }, \"speed\" : 30 , \"traffic_signal\" : false , \"start_restriction\" : { \"moped\" : false , \"wheelchair\" : false , \"taxi\" : false , \"HOV\" : false , \"truck\" : false , \"emergency\" : false , \"pedestrian\" : false , \"car\" : false , \"bus\" : false , \"bicycle\" : false }, \"speed_limit\" : 0 , \"geo_attributes\" : { \"weighted_grade\" : - 1.67 , \"length\" : 388 }, \"cycle_lane\" : \"none\" , \"access_restriction\" : false , \"part_of_complex_restriction\" : false , \"country_crossing\" : false , \"has_exit_sign\" : false , \"lane_count\" : 1 , \"speed_type\" : \"classified\" , \"drive_on_right\" : true , \"destination_only\" : false , \"seasonal\" : false , \"tunnel\" : false , \"bridge\" : false , \"access\" : { \"moped\" : true , \"wheelchair\" : true , \"taxi\" : false , \"HOV\" : true , \"truck\" : true , \"emergency\" : false , \"pedestrian\" : true , \"car\" : true , \"bus\" : true , \"bicycle\" : true }, \"toll\" : false , \"round_about\" : false , \"bike_network\" : { \"mountain\" : false , \"local\" : false , \"regional\" : false , \"national\" : false }, \"end_restriction\" : { \"moped\" : false , \"wheelchair\" : false , \"taxi\" : false , \"HOV\" : false , \"truck\" : false , \"emergency\" : false , \"pedestrian\" : false , \"car\" : false , \"bus\" : false , \"bicycle\" : false }, \"unreachable\" : false , \"forward\" : false , \"not_thru\" : true , \"truck_route\" : false , \"use\" : \"road\" }, \"minimum_reachability\" : 51 , \"score\" : 899846.4 , \"traffic_segments\" : [], \"percent_along\" : 1 , \"correlated_lon\" : - 76.494987 , \"side_of_street\" : \"neither\" , \"correlated_lat\" : 40.313206 } ], \"warnings\" : [ \"hov costing is deprecated and will be turned into auto costing with hov2=true costing option\" ] } ] Attribute Descriptions for Responses \u00b6 TODO: HTTP status codes and error messages \u00b6 Because the locate service API is so tightly integrated with the route service API the two share the same list of response codes and error messages. Please review the full lists in the routing service API documentation","title":"Locate API"},{"location":"api/locate/api-reference/#valhalla-locate-service-api-reference","text":"Valhalla's locate service, is an open-source service that provides detailed information about streets and intersections close to an input point with some added matching criteria. This allows for tight integration in routing and navigation applications on web or mobile. View an interactive demo The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page .","title":"Valhalla locate service API reference"},{"location":"api/locate/api-reference/#inputs-of-a-locate-request","text":"The locate request run locally takes the form of localhost:8002/locate?json={} , where the JSON inputs inside the {} include location information, name and options for the costing model, and output options. Here is the JSON payload for an example request: { \"verbose\" : true , \"locations\" :[{ \"lat\" : 42.358528 , \"lon\" : -83.271400 },{ \"lat\" : 42.996613 , \"lon\" : -78.749855 }], \"costing\" : \"bicycle\" , \"costing_options\" :{ \"bicycle\" :{ \"bicycle_type\" : \"road\" }}, \"directions_options\" :{ \"units\" : \"miles\" }, \"id\" : \"12abc3afe23984fe\" } This request provides detailed information about specific streets and intersections near the two input locations. Steets which do not have a surface type condusive to road bicycles will be excluded from the results. The units used for the lengths of the street sections will be displayed in miles. There is an option to name your request. You can do this by adding and id key to your request. The id is returned with the response so a user could match to the corresponding request. Because the locate service is designed to work in tandem with the route service API, the inputs for the two APIs are identical. For detailed options regarding specifiying locations, costing models, costing options, directions options please see the relevant sections in the routing API docs","title":"Inputs of a locate request"},{"location":"api/locate/api-reference/#other-request-options","text":"Options Description verbose Can be set to true or false , but defaults to false . If set to true dense attribution of the given street or intersection will be returned. id Name your route request. If id is specified, the naming will be sent through to the response.","title":"Other request options"},{"location":"api/locate/api-reference/#outputs-of-a-locate-request","text":"If a request has been named using the optional id key, then this id key and value will be echoed in the JSON response object. The locate results are returned as a JSON array, with one JSON object per input location in the order specified. In verbose mode details about the streets and intersections includding mode of travel access, names, way ids, shape, side of street as well as the closest point to the input along these features will be returned. If verbose was not enabled only the closest point, way id and side of street will be returned. A warnings array may also be included. This array may contain warning objects informing about deprecated request parameters, clamped values etc. | Here are some sample results with verbose set to false : [ { \"input_lon\" : - 76.495743 , \"input_lat\" : 40.310555 , \"nodes\" : [ { \"lat\" : 40.313206 , \"lon\" : - 76.494987 } ], \"edges\" : [ { \"way_id\" : 12292268 , \"correlated_lat\" : 40.313206 , \"side_of_street\" : \"neither\" , \"percent_along\" : 0 , \"correlated_lon\" : - 76.494987 }, { \"way_id\" : 12292268 , \"correlated_lat\" : 40.313206 , \"side_of_street\" : \"neither\" , \"percent_along\" : 1 , \"correlated_lon\" : - 76.494987 } ], \"warnings\" : [ \"hov costing is deprecated and will be turned into auto costing with hov2=true costing option\" ] } ] Here are some sample results with verbose set to true : [ { \"input_lon\" : - 76.495743 , \"input_lat\" : 40.310555 , \"nodes\" : [ { \"traffic_signal\" : false , \"type\" : \"street_intersection\" , \"lat\" : 40.313206 , \"node_id\" : { \"id\" : 3080 , \"value\" : 103353655794 , \"tile_id\" : 750654 , \"level\" : 2 }, \"access\" : { \"wheelchair\" : true , \"taxi\" : false , \"HOV\" : true , \"truck\" : true , \"emergency\" : true , \"pedestrian\" : true , \"car\" : true , \"bus\" : true , \"bicycle\" : true }, \"lon\" : - 76.494987 , \"edge_count\" : 1 , \"administrative\" : { \"time_zone_posix\" : \"EST-05EDT+01,M3.2.0/02:00,M11.1.0/02:00\" , \"standard_time_zone_name\" : \"EST\" , \"iso_3166-1\" : \"US\" , \"daylight_savings_time_zone_name\" : \"EDT\" , \"country\" : \"United States of America\" , \"iso_3166-2\" : \"PA\" , \"state\" : \"Pennsylvania\" }, \"intersection_type\" : \"dead-end\" , \"density\" : 2 , \"local_edge_count\" : 1 , \"mode_change\" : false } ], \"edges\" : [ { \"edge_id\" : { \"id\" : 7660 , \"value\" : 257032954354 , \"tile_id\" : 750654 , \"level\" : 2 }, \"edge_info\" : { \"shape\" : \"ivo{kAvg{{pCiMlJ{FfDgDm@c_AqxBeFO}}@`]\" , \"way_id\" : 12292268 , \"names\" : [ \"Bomgardner Lane\" ] }, \"edge\" : { \"classification\" : { \"link\" : false , \"internal\" : false , \"surface\" : \"paved_smooth\" , \"classification\" : \"residential\" }, \"end_node\" : { \"id\" : 3081 , \"value\" : 103387210226 , \"tile_id\" : 750654 , \"level\" : 2 }, \"speed\" : 30 , \"traffic_signal\" : false , \"start_restriction\" : { \"moped\" : false , \"wheelchair\" : false , \"taxi\" : false , \"HOV\" : false , \"truck\" : false , \"emergency\" : false , \"pedestrian\" : false , \"car\" : false , \"bus\" : false , \"bicycle\" : false }, \"speed_limit\" : 0 , \"geo_attributes\" : { \"weighted_grade\" : 1.67 , \"length\" : 388 }, \"cycle_lane\" : \"none\" , \"access_restriction\" : false , \"part_of_complex_restriction\" : false , \"country_crossing\" : false , \"has_exit_sign\" : false , \"lane_count\" : 1 , \"speed_type\" : \"classified\" , \"drive_on_right\" : true , \"destination_only\" : false , \"seasonal\" : false , \"tunnel\" : false , \"bridge\" : false , \"access\" : { \"moped\" : true , \"wheelchair\" : true , \"taxi\" : false , \"HOV\" : true , \"truck\" : true , \"emergency\" : false , \"pedestrian\" : true , \"car\" : true , \"bus\" : true , \"bicycle\" : true }, \"toll\" : false , \"round_about\" : false , \"bike_network\" : { \"mountain\" : false , \"local\" : false , \"regional\" : false , \"national\" : false }, \"end_restriction\" : { \"moped\" : false , \"wheelchair\" : false , \"taxi\" : false , \"HOV\" : false , \"truck\" : false , \"emergency\" : false , \"pedestrian\" : false , \"car\" : false , \"bus\" : false , \"bicycle\" : false }, \"unreachable\" : false , \"forward\" : true , \"not_thru\" : false , \"truck_route\" : false , \"use\" : \"road\" }, \"minimum_reachability\" : 51 , \"score\" : 899846.4 , \"traffic_segments\" : [], \"percent_along\" : 0 , \"correlated_lon\" : - 76.494987 , \"side_of_street\" : \"neither\" , \"correlated_lat\" : 40.313206 }, { \"edge_id\" : { \"id\" : 7661 , \"value\" : 257066508786 , \"tile_id\" : 750654 , \"level\" : 2 }, \"edge_info\" : { \"shape\" : \"ivo{kAvg{{pCiMlJ{FfDgDm@c_AqxBeFO}}@`]\" , \"way_id\" : 12292268 , \"names\" : [ \"Bomgardner Lane\" ] }, \"edge\" : { \"classification\" : { \"link\" : false , \"internal\" : false , \"surface\" : \"paved_smooth\" , \"classification\" : \"residential\" }, \"end_node\" : { \"id\" : 3080 , \"value\" : 103353655794 , \"tile_id\" : 750654 , \"level\" : 2 }, \"speed\" : 30 , \"traffic_signal\" : false , \"start_restriction\" : { \"moped\" : false , \"wheelchair\" : false , \"taxi\" : false , \"HOV\" : false , \"truck\" : false , \"emergency\" : false , \"pedestrian\" : false , \"car\" : false , \"bus\" : false , \"bicycle\" : false }, \"speed_limit\" : 0 , \"geo_attributes\" : { \"weighted_grade\" : - 1.67 , \"length\" : 388 }, \"cycle_lane\" : \"none\" , \"access_restriction\" : false , \"part_of_complex_restriction\" : false , \"country_crossing\" : false , \"has_exit_sign\" : false , \"lane_count\" : 1 , \"speed_type\" : \"classified\" , \"drive_on_right\" : true , \"destination_only\" : false , \"seasonal\" : false , \"tunnel\" : false , \"bridge\" : false , \"access\" : { \"moped\" : true , \"wheelchair\" : true , \"taxi\" : false , \"HOV\" : true , \"truck\" : true , \"emergency\" : false , \"pedestrian\" : true , \"car\" : true , \"bus\" : true , \"bicycle\" : true }, \"toll\" : false , \"round_about\" : false , \"bike_network\" : { \"mountain\" : false , \"local\" : false , \"regional\" : false , \"national\" : false }, \"end_restriction\" : { \"moped\" : false , \"wheelchair\" : false , \"taxi\" : false , \"HOV\" : false , \"truck\" : false , \"emergency\" : false , \"pedestrian\" : false , \"car\" : false , \"bus\" : false , \"bicycle\" : false }, \"unreachable\" : false , \"forward\" : false , \"not_thru\" : true , \"truck_route\" : false , \"use\" : \"road\" }, \"minimum_reachability\" : 51 , \"score\" : 899846.4 , \"traffic_segments\" : [], \"percent_along\" : 1 , \"correlated_lon\" : - 76.494987 , \"side_of_street\" : \"neither\" , \"correlated_lat\" : 40.313206 } ], \"warnings\" : [ \"hov costing is deprecated and will be turned into auto costing with hov2=true costing option\" ] } ]","title":"Outputs of a locate request"},{"location":"api/locate/api-reference/#attribute-descriptions-for-responses","text":"TODO:","title":"Attribute Descriptions for Responses"},{"location":"api/locate/api-reference/#http-status-codes-and-error-messages","text":"Because the locate service API is so tightly integrated with the route service API the two share the same list of response codes and error messages. Please review the full lists in the routing service API documentation","title":"HTTP status codes and error messages"},{"location":"api/map-matching/api-reference/","text":"Map Matching service API reference \u00b6 With Valhalla's Map Matching service, you can match coordinates, such as GPS locations, to roads and paths that have been mapped in OpenStreetMap. By doing this, you can turn a path into a route with narrative instructions and also get the attribute values from that matched line. You can view an interactive demo or use Mobility Explorer . There are two separate Map Matching calls that perform different operations on an input set of latitude,longitude coordinates. The trace_route action returns the shape snapped to the road network and narrative directions, while trace_attributes returns detailed attribution along the portion of the route. It is important to note that all service requests should be POST because shape or encoded_polyline can be fairly large. Trace route action \u00b6 The trace_route action takes the costing mode and a list of latitude,longitude coordinates, for example, from a GPS trace, to turn them into a route with the shape snapped to the road network and a set of guidance directions. You might use this to take a GPS trace from a bike route into a set of narrative instructions so you can re-create your trip or share it with others. By default a single trip leg is returned in a trace_route response. You can split the route response into multiple legs by setting \"type\":\"break\" on any of the input shape objects in the shape parameter of your query. The first and last locations should always have type break. Note that setting breaks is not supported for encoded_polyline input, and is only supported for map_snap mode of the trace_route endpoint. Trace attributes action \u00b6 The trace_attributes action takes the costing mode and a GPS trace or latitude,longitude positions and returns detailed attribution along the portion of the route. This includes details for each section of road along the path, as well as any intersections along the path. Some of the use cases for trace_attributes include getting: just-in-time information for navigation. Getting attributes only for portions of the upcoming route can improve performance because returning full details along an entire route can create a very large payload. For example, regular route responses include shape and a set of maneuvers along each route leg. The maneuvers are a generalization of the path to simplify the description. Detailed attributes and localization of attributes along a maneuver would require significant additions to the route response. For long and even moderate length routes this can be wasteful, as the chances of re-routing along a long route are high. speed limits. Speed limits along a path are a good example of just-in-time information that can be used for navigation. A single maneuver in a route (US-1, for example) may have many different speed limits along the full length of the maneuver. The trace_attributes action allows speed limits along each road segment to be determined and associated to portions of a maneuver. way IDs. You can turn a GPS trace into a set of way IDs that match the trace. the current road. A map-matching call with a recent set of GPS locations can be useful to find information about the current road, even if not doing navigation or having a route loaded on device. Note that the attributes that are returned are Valhalla routing attributes, not the base OSM tags or base data. Valhalla imports OSM tags and normalizes many of them to a standard set of values used for routing. The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page . To get the base OSM tags along a path, you need to take the OSM way IDs that are returned as attributes along the path and query OSM directly through a process such as the Overpass API . Inputs of the Map Matching service \u00b6 Shape-matching parameters \u00b6 shape_match is an optional string input parameter. It allows some control of the matching algorithm based on the type of input. shape_match type Description edge_walk Indicates an edge walking algorithm can be used. This algorithm requires nearly exact shape matching, so it should only be used when the shape is from a prior Valhalla route. map_snap Indicates that a map-matching algorithm should be used because the input shape might not closely match Valhalla edges. This algorithm is more expensive. walk_or_snap Also the default option. This will try edge walking and if this does not succeed, it will fall back and use map matching. Costing models and other options \u00b6 Valhalla Map Matching uses the auto , auto_shorter , bicycle , bus , and pedestrian costing models available in the Valhalla route service. Refer to the route costing models and costing options documentation for more on how to specify this input. Costing for multimodal is not supported for map matching because it would be difficult to get favorable GPS traces. You can also set directions_options to specify output units, language, and whether or not to return directions in a narrative form. Refer to the route options documentation for examples. trace_route has additional options that allow more flexibility in specifying timestamps (when using encoded polyline input for the trace) and for using timestamps when computing elapsed time along the matched path. These options are: Option Description begin_time Begin timestamp for the trace. This is used along with the durations so that timestamps can be specified for a trace that is specified using an encoded polyline. durations List of durations (seconds) between each successive pair of input trace points. This allows trace points to be supplied as an encoded polyline and timestamps to be created by using this list of \"delta\" times along with the begin_time of the trace. use_timestamps A boolean value indicating whether the input timestamps or durations should be used when computing elapsed time at each edge along the matched path. If true, timestamps are used. If false (default), internal costing is applied to compute elapsed times. trace_options Additional options. trace_options.search_radius Search radius in meters associated with supplied trace points. trace_options.gps_accuracy GPS accuracy in meters associated with supplied trace points. trace_options.breakage_distance Breaking distance in meters between trace points. trace_options.interpolation_distance Interpolation distance in meters beyond which trace points are merged together. linear_references When present and true , the successful trace_route response will include a key linear_references . Its value is an array of base64-encoded OpenLR location references , one for each graph edge of the road network matched by the input trace. Attribute filters ( trace_attributes only) \u00b6 The trace_attributes action allows you to apply filters to include or exclude specific attribute filter keys in your response. These filters are optional and can be added to the action string inside of the filters object. If no filters are used, all attributes are enabled and returned in the trace_attributes response. These are the available filter keys. Review their descriptions for more information. // Edge filter Keys edge.names edge.length edge.speed edge.road_class edge.begin_heading edge.end_heading edge.begin_shape_index edge.end_shape_index edge.traversability edge.use edge.toll edge.unpaved edge.tunnel edge.bridge edge.roundabout edge.internal_intersection edge.drive_on_right edge.surface edge.sign.exit_number edge.sign.exit_branch edge.sign.exit_toward edge.sign.exit_name edge.travel_mode edge.vehicle_type edge.pedestrian_type edge.bicycle_type edge.transit_type edge.id edge.indoor edge.way_id edge.weighted_grade edge.max_upward_grade edge.max_downward_grade edge.mean_elevation edge.lane_count edge.cycle_lane edge.bicycle_network edge.sac_scale edge.shoulder edge.sidewalk edge.density edge.speed_limit edge.truck_speed edge.truck_route // Node filter keys node.intersecting_edge.begin_heading node.intersecting_edge.from_edge_name_consistency node.intersecting_edge.to_edge_name_consistency node.intersecting_edge.driveability node.intersecting_edge.cyclability node.intersecting_edge.walkability node.intersecting_edge.use node.intersecting_edge.road_class node.intersecting_edge.lane_count node.elapsed_time node.admin_index node.type node.fork node.time_zone // Other filter keys osm_changeset shape admin.country_code admin.country_text admin.state_code admin.state_text matched.point matched.type matched.edge_index matched.begin_route_discontinuity matched.end_route_discontinuity matched.distance_along_edge matched.distance_from_trace_point Outputs of the Map Matching service \u00b6 Outputs of trace_route \u00b6 The outputs of the trace_route action are the same as the outputs of a route action. Outputs of trace_attributes \u00b6 The trace_attributes results contains a list of edges and, optionally, the following items: osm_changeset , list of admins , shape , matched_points , and units . Result item Description edges List of edges associated with input shape. See the list of edge items for details. osm_changeset Identifier of the OpenStreetMap base data version. admins List of the administrative codes and names. See the list of admin items for details. shape The encoded polyline of the matched path. matched_points List of match results when using the map_snap shape match algorithm. There is a one-to-one correspondence with the input set of latitude, longitude coordinates and this list of match results. See the list of matched point items for details. units The specified units with the request, in either kilometers or miles. warnings A warnings array. This array may contain descriptive text about notices of deprecated request parameters, clamped values etc. Edge items \u00b6 Each edge may include: Edge item Description names List of names. length Edge length in the units specified. The default is kilometers. speed Edge speed in the units specified. The default is kilometers per hour. road_class Road class values: motorway trunk primary secondary tertiary unclassified residential service_other begin_heading The direction at the beginning of an edge. The units are degrees from north in a clockwise direction. end_heading The direction at the end of an edge. The units are degrees from north in a clockwise direction.. begin_shape_index Index into the list of shape points for the start of the edge. end_shape_index Index into the list of shape points for the end of the edge. traversability Traversability values, if available: forward backward both use Use values: tram road ramp turn_channel track driveway alley parking_aisle emergency_access drive_through culdesac cycleway mountain_bike sidewalk footway steps other rail-ferry ferry rail bus rail_connection bus_connnection transit_connection toll True if the edge has any toll. unpaved True if the edge is unpaved or rough pavement. tunnel True if the edge is a tunnel. bridge True if the edge is a bridge. roundabout True if the edge is a roundabout. internal_intersection True if the edge is an internal intersection. drive_on_right True if the flag is enabled for driving on the right side of the street. surface Surface values: paved_smooth paved paved_rough compacted dirt gravel path impassable sign Contains the interchange guide information associated with this edge. See the list of sign items for details. travel_mode Travel mode values: drive pedestrian bicycle transit vehicle_type Vehicle type values: car motorcycle bus tractor_trailer pedestrian_type Pedestrian type values: foot wheelchair segway bicycle_type Bicycle type values: road cross hybrid mountain transit_type Transit type values: tram metro rail bus ferry cable_car gondola funicular id Identifier of an edge within the tiled, hierarchical graph. indoor Whether or not the edge is inside of a building or structure or not. way_id Way identifier of the OpenStreetMap base data. weighted_grade The weighted grade factor. Valhalla manufactures a weighted_grade from elevation data. It is a measure used for hill avoidance in routing - sort of a relative energy use along an edge. But since an edge in Valhalla can possibly go up and down over several hills it might not equate to what most folks think of as grade. max_upward_grade The maximum upward slope. A value of 32768 indicates no elevation data is available for this edge. max_downward_grade The maximum downward slope. A value of 32768 indicates no elevation data is available for this edge. mean_elevation The mean or average elevation along the edge. Units are meters by default. If the units are specified as miles, then the mean elevation is returned in feet. A value of 32768 indicates no elevation data is available for this edge. lane_count The number of lanes for this edge. cycle_lane The type (if any) of bicycle lane along this edge. bicycle_network The bike network for this edge. sac_scale Classification of hiking trails based on difficulty. Values: 0 - No Sac Scale 1 - Hiking 2 - Mountain hiking 3 - Demanding mountain hiking 4 - Alpine hiking 5 - Demanding alpine hiking 6 - Difficult alpine hiking shoulder True if the edge has a shoulder. sidewalk Sidewalk values: left right both density The relative density along the edge. speed_limit Edge speed limit in the units specified. The default is kilometers per hour. truck_speed Edge truck speed in the units specified. The default is kilometers per hour. truck_route True if edge is part of a truck network/route. end_node The node at the end of this edge. See the list of end node items for details. Sign items \u00b6 Each sign may include: Sign item Description exit_number List of exit number elements. If an exit number element exists, it is typically just one value. Element example: 91B exit_branch List of exit branch elements. An exit branch element is the subsequent road name or route number after the sign. Element example: I 95 North exit_toward List of exit toward elements. The exit toward element is the location where the road ahead goes; the location is typically a control city, but may also be a future road name or route number. Element example: New York exit_name List of exit name elements. The exit name element is the interchange identifier, although typically not used in the United States. Element example: Gettysburg Pike End node items \u00b6 Each end_node may include: Node item Description intersecting_edges List of intersecting edges at this node. See the list of intersecting edge items for details. elapsed_time Elapsed time of the path to arrive at this node. admin_index Index value in the admin list. type Node type values: street_intersection gate bollard toll_booth multi_use_transit_stop bike_share parking motor_way_junction border_control fork True if this node is a fork. time_zone Time zone string for this node. Intersecting edge items \u00b6 Each intersecting_edge may include: Intersecting edge item Description begin_heading The direction at the beginning of this intersecting edge. The units are degrees from north in a clockwise direction. from_edge_name_consistency True if this intersecting edge at the end node has consistent names with the path from edge . to_edge_name_consistency True if this intersecting edge at the end node has consistent names with the path to edge . driveability Driveability values, if available: forward backward both cyclability Cyclability values, if available: forward backward both walkability Walkability values, if available: forward backward both use Use values: tram road ramp turn_channel track driveway alley parking_aisle emergency_access drive_through culdesac cycleway mountain_bike sidewalk footway steps other rail-ferry ferry rail bus rail_connection bus_connnection transit_connection road_class Road class values: motorway trunk primary secondary tertiary unclassified residential service_other Admin items \u00b6 Each admin may include: Admin item Description country_code Country ISO 3166-1 alpha-2 code. country_text Country name. state_code State code. state_text State name. Matched point items \u00b6 Each matched_point may include: Matched point item Description lat The latitude of the matched point. lon The longitude of the matched point. type Describes the type of this match result - possible values include: unmatched interpolated matched edge_index The index of the edge in the list of edges that this matched point is associated with. This value will not exist if this point was unmatched. begin_route_discontinuity The boolean value is true if this match result is the begin location of a route disconnect. This value will not exist if this is false. end_route_discontinuity The boolean value is true if this match result is the end location of a route disconnect. This value will not exist if this is false. distance_along_edge The distance along the associated edge for this matched point. For example, if the matched point is halfway along the edge then the value would be 0.5. This value will not exist if this point was unmatched. distance_from_trace_point The distance in meters from the trace point to the matched point. This value will not exist if this point was unmatched. Get better results \u00b6 Follow these guidelines to improve the Map Matching results. You should have good GPS accuracy, meaning that there are few obstructions affecting GPS signals. This can be difficult in urban areas. Make sure the trace point density is within the approximate range of one per second and one per 10 seconds. The greater the range between them, the more chance of inaccurate results. Have each trace represent one continuous path. Verify that there is a corresponding match with the OpenStreetMap network. You can use certain parameters to tune the response. Unless otherwise noted, each of these options is specified within a root-level trace_options object. Use turn_penalty_factor to penalize turns from one road segment to next. For a pedestrian trace_route , you may see a back-and-forth motion along the streets of your path. Try increasing the turn penalty factor to 500 to smooth out jittering of points. Note that if GPS accuracy is already good, increasing this will have a negative affect on your results. Set the gps_accuracy to indicate the accuracy in meters. Apply a search_radius to specify the search radius (in meters) within which to search road candidates for each measurement. The maximum search radius is 100 meters. Note that performance may decrease with a higher search radius value. Add a time component to your GPS data to inform the map matching algorithm about when the point was measured. Providing a time attribute is not available for encoded_polyline data and can only be specified with GPS data provided by the shape attribute. time is specified in seconds and can be a UNIX epoch time or any increasing sequence: { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 , \"time\" : 0 },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 , \"time\" : 2 },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 , \"time\" : 6 }, ... ]} Example Map Matching requests \u00b6 Example trace_route requests \u00b6 The following are example JSON payloads for POST requests for the trace_routes action. trace_route with shape parameter { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 , \"type\" : \"break\" },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 , \"type\" : \"via\" },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 , \"type\" : \"via\" },{ \"lat\" : 39.983551 , \"lon\" : -76.734253 , \"type\" : \"break\" },{ \"lat\" : 39.983555 , \"lon\" : -76.734116 , \"type\" : \"via\" },{ \"lat\" : 39.983589 , \"lon\" : -76.733315 , \"type\" : \"via\" },{ \"lat\" : 39.983719 , \"lon\" : -76.732445 , \"type\" : \"via\" },{ \"lat\" : 39.983818 , \"lon\" : -76.731712 , \"type\" : \"via\" },{ \"lat\" : 39.983776 , \"lon\" : -76.731506 , \"type\" : \"via\" },{ \"lat\" : 39.983696 , \"lon\" : -76.731369 , \"type\" : \"break\" }], \"costing\" : \"auto\" , \"shape_match\" : \"map_snap\" }} trace_route with encoded polyline parameter { \"encoded_polyline\" : \"_grbgAh~{nhF?lBAzBFvBHxBEtBKdB?fB@dBZdBb@hBh@jBb@x@\\\\|@x@pB\\\\x@v@hBl@nBPbCXtBn@|@z@ZbAEbAa@~@q@z@QhA]pAUpAVhAPlAWtASpAAdA[dASdAQhAIlARjANnAZhAf@n@`A?lB^nCRbA\\\\xB`@vBf@tBTbCFbARzBZvBThBRnBNrBP`CHbCF`CNdCb@vBX`ARlAJfADhA@dAFdAP`AR`Ah@hBd@bBl@rBV|B?vB]tBCvBBhAF`CFnBXtAVxAVpAVtAb@|AZ`Bd@~BJfA@fAHdADhADhABjAGzAInAAjAB|BNbCR|BTjBZtB`@lBh@lB\\\\|Bl@rBXtBN`Al@g@t@?nAA~AKvACvAAlAMdAU`Ac@hAShAI`AJ`AIdAi@bAu@|@k@p@]p@a@bAc@z@g@~@Ot@Bz@f@X`BFtBXdCLbAf@zBh@fBb@xAb@nATjAKjAW`BI|AEpAHjAPdAAfAGdAFjAv@p@XlAVnA?~A?jAInAPtAVxAXnAf@tBDpBJpBXhBJfBDpAZ|Ax@pAz@h@~@lA|@bAnAd@hAj@tAR~AKxAc@xAShA]hAIdAAjA]~A[v@BhB?dBSv@Ct@CvAI~@Oz@Pv@dAz@lAj@~A^`B^|AXvAVpAXdBh@~Ap@fCh@hB\\\\zBN`Aj@xBFdA@jALbAPbAJdAHdAJbAHbAHfAJhALbA\\\\lBTvBAdC@bC@jCKjASbC?`CM`CDpB\\\\xAj@tB\\\\fA\\\\bAVfAJdAJbAXz@L|BO`AOdCDdA@~B\\\\z@l@v@l@v@l@r@j@t@b@x@b@r@z@jBVfCJdAJdANbCPfCF|BRhBS~BS`AYbAe@~BQdA\" , \"shape_match\" : \"map_snap\" , \"costing\" : \"pedestrian\" , \"directions_options\" :{ \"units\" : \"miles\" }} trace_route with additional trace options { \"encoded_polyline\" : \"{gmagAp~_nhF[_AZqAjAaB`AkB\\\\cAZeAPcAHiAKiCQaAUeAe@cA]qAQsACqAF}AIsAg@{@s@i@sAw@i@uANyAPsAv@cAZ_ALqA_@cA_Ai@q@w@[uAm@}AaAqAs@s@m@u@c@oA]mAMiAIkAYqBRyATsANsBKyBAiA?iAFsALuAPsAXaBGgCg@oBKiBf@iBGiBg@oBHqA?{Ai@cA@oAbAgAj@g@j@k@n@q@p@e@n@k@d@}@\\\\cAFgAIoBg@m@y@[_ASu@K{AHgBP{@@w@Jy@L}@JsAMoAe@kAq@kAk@gAg@y@a@m@g@q@mAo@e@gAc@sAA_AI_BFu@LiALaALaAHoAFiAF{A@yABkAKmAKcAMiBU}AYu@MaBUqBu@{As@iAaAaA_Ao@aAi@s@q@{@{@a@sAi@oAGeAD}@[YiAmA[u@BgBXaBHgAQ}@]s@S]x@_BbC}@lAw@dAs@dAk@dAm@z@s@n@y@p@{@`Ao@z@_@z@u@jA_Af@aANiAAcBPsAl@s@X}@T{@PoAPeAl@{@t@_AbAgAjBk@r@e@~AY~@U~@YhAi@lAo@t@kBb@u@NyAX{@k@MoAi@{@eAx@aArAmBt@_ALgAPiAXkAf@w@j@u@p@_A^aA\\\\aA`@eAt@eATcAGcAG}@AeAX_Aj@q@r@aAp@wAt@sARk@xA?pBAvAu@Ps@_Bk@i@y@\\\\s@f@o@j@u@f@{@RwAb@mAZaARkATqANyAImAK}@C_AFqADiAC_AUs@[}Ao@eBm@q@_@_Bg@iAm@kAaAc@s@c@w@y@{AWcAc@{Am@c@yBF{@AkAYmA_@uBD{@B{@Gu@ScBIu@NaB^_B`@sAC{Ac@}A]yAg@aBHuAJ_BAaAEgAA_AAy@@eBX_AFw@JcB^s@VuA`AuAl@kBl@_AFeAJcAB{ABwAj@o@l@q@b@u@Z{AXmAaAm@o@oAwAsAcAsAu@u@cAe@iAy@eAk@iAc@gAOgAWgBe@wAo@}Ai@sBY{@u@s@y@Y{@[aA]s@oB\\\\eCPoARwAXgBV{Ab@sAf@oAb@kAFsA?kACeADeA^aABeAO_Be@gB]}@eAaB_AoAw@aAm@o@q@cBp@eBz@a@fAi@|@o@LiBAyAIoAu@qBkAuAiAa@gAa@cB_@eAQm@c@o@{ANaBf@{@h@_BV}@XcBz@?{@s@o@y@u@}@mAaBw@qCm@mG}@uJLoBVkBVaBh@iB`@gBXgBZ_BZaBNgACwASyAUqAGuBGsBTcBRiB^eCTmBTaBNoAVaB@kAMiBZcAd@eAf@q@z@mAVgB[gAq@aAk@s@UkAG{B_@sAW}ASoBMwBSuB]gBq@eBs@eBaAuAaAeAo@{@i@}@e@{@g@{@m@m@y@_@y@[aBk@a@cBFsB[iAaAGoA`@IcC^yA`@}AVkBNwBBmBR_Cr@{CrAyD|@mCf@kBXeB\\\\eBl@aCf@cBc@sBg@qAUkBe@sBw@eBi@uA{@gAyAc@qAk@[wB@gARqANgAPiAJsAAeAa@mBKmB@uBBwB@oBZoBJkCJkANaCY}Ac@aBa@iBc@iBu@qBu@sBu@sB_AiBcA}AiAqAaAqAeAaA}@]iANgAj@}@dAcAhAeAfAyAfAo@`@k@f@o@f@s@d@o@f@k@h@o@`@s@V_Br@wAv@{An@uAt@qAj@wAl@iAv@gA~@qAbA{A`AcBz@o@^{A`AmAhAo@b@sAxA_@z@]x@a@t@qAxAk@j@qAfAm@b@m@b@kAfAuA~@eAhAcAbAiAr@qA|@gAdAcA`A{@bA_AhAgA|@mAr@qA|@mAlA\" , \"shape_match\" : \"map_snap\" , \"costing\" : \"pedestrian\" , \"trace_options\" :{ \"turn_penalty_factor\" : 500 }, \"directions_options\" :{ \"units\" : \"miles\" }} Example trace_attributes requests \u00b6 The following are example JSON payloads for POST requests for the trace_attributes action. trace_attributes with shape parameter { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 },{ \"lat\" : 39.983551 , \"lon\" : -76.734253 },{ \"lat\" : 39.983555 , \"lon\" : -76.734116 },{ \"lat\" : 39.983589 , \"lon\" : -76.733315 },{ \"lat\" : 39.983719 , \"lon\" : -76.732445 },{ \"lat\" : 39.983818 , \"lon\" : -76.731712 },{ \"lat\" : 39.983776 , \"lon\" : -76.731506 },{ \"lat\" : 39.983696 , \"lon\" : -76.731369 }], \"costing\" : \"auto\" , \"shape_match\" : \"walk_or_snap\" , \"filters\" :{ \"attributes\" :[ \"edge.names\" , \"edge.id\" , \"edge.weighted_grade\" , \"edge.speed\" ], \"action\" : \"include\" }} trace_attributes with encoded polyline parameter { \"encoded_polyline\" : \"_grbgAh~{nhF?lBAzBFvBHxBEtBKdB?fB@dBZdBb@hBh@jBb@x@\\\\|@x@pB\\\\x@v@hBl@nBPbCXtBn@|@z@ZbAEbAa@~@q@z@QhA]pAUpAVhAPlAWtASpAAdA[dASdAQhAIlARjANnAZhAf@n@`A?lB^nCRbA\\\\xB`@vBf@tBTbCFbARzBZvBThBRnBNrBP`CHbCF`CNdCb@vBX`ARlAJfADhA@dAFdAP`AR`Ah@hBd@bBl@rBV|B?vB]tBCvBBhAF`CFnBXtAVxAVpAVtAb@|AZ`Bd@~BJfA@fAHdADhADhABjAGzAInAAjAB|BNbCR|BTjBZtB`@lBh@lB\\\\|Bl@rBXtBN`Al@g@t@?nAA~AKvACvAAlAMdAU`Ac@hAShAI`AJ`AIdAi@bAu@|@k@p@]p@a@bAc@z@g@~@Ot@Bz@f@X`BFtBXdCLbAf@zBh@fBb@xAb@nATjAKjAW`BI|AEpAHjAPdAAfAGdAFjAv@p@XlAVnA?~A?jAInAPtAVxAXnAf@tBDpBJpBXhBJfBDpAZ|Ax@pAz@h@~@lA|@bAnAd@hAj@tAR~AKxAc@xAShA]hAIdAAjA]~A[v@BhB?dBSv@Ct@CvAI~@Oz@Pv@dAz@lAj@~A^`B^|AXvAVpAXdBh@~Ap@fCh@hB\\\\zBN`Aj@xBFdA@jALbAPbAJdAHdAJbAHbAHfAJhALbA\\\\lBTvBAdC@bC@jCKjASbC?`CM`CDpB\\\\xAj@tB\\\\fA\\\\bAVfAJdAJbAXz@L|BO`AOdCDdA@~B\\\\z@l@v@l@v@l@r@j@t@b@x@b@r@z@jBVfCJdAJdANbCPfCF|BRhBS~BS`AYbAe@~BQdA\" , \"shape_match\" : \"map_snap\" , \"costing\" : \"pedestrian\" , \"directions_options\" :{ \"units\" : \"miles\" }} trace_attributes with include attribute filter { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 },{ \"lat\" : 39.983551 , \"lon\" : -76.734253 },{ \"lat\" : 39.983555 , \"lon\" : -76.734116 },{ \"lat\" : 39.983589 , \"lon\" : -76.733315 },{ \"lat\" : 39.983719 , \"lon\" : -76.732445 },{ \"lat\" : 39.983818 , \"lon\" : -76.731712 },{ \"lat\" : 39.983776 , \"lon\" : -76.731506 },{ \"lat\" : 39.983696 , \"lon\" : -76.731369 }], \"costing\" : \"auto\" , \"shape_match\" : \"walk_or_snap\" , \"filters\" :{ \"attributes\" :[ \"edge.names\" , \"edge.id\" , \"edge.weighted_grade\" , \"edge.speed\" ], \"action\" : \"include\" }} trace_attributes with exclude attribute filter { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 },{ \"lat\" : 39.983551 , \"lon\" : -76.734253 },{ \"lat\" : 39.983555 , \"lon\" : -76.734116 },{ \"lat\" : 39.983589 , \"lon\" : -76.733315 },{ \"lat\" : 39.983719 , \"lon\" : -76.732445 },{ \"lat\" : 39.983818 , \"lon\" : -76.731712 },{ \"lat\" : 39.983776 , \"lon\" : -76.731506 },{ \"lat\" : 39.983696 , \"lon\" : -76.731369 }], \"costing\" : \"auto\" , \"shape_match\" : \"walk_or_snap\" , \"filters\" :{ \"attributes\" :[ \"edge.names\" , \"edge.begin_shape_index\" , \"edge.end_shape_index\" , \"shape\" ], \"action\" : \"exclude\" }} If you would like to visualize the map matched points that correlate to specified input locations - use the following filter \"filters\" :{ \"attributes\" :[ \"edge.id\" , \"matched.point\" , \"matched.type\" , \"matched.edge_index\" , \"matched.begin_route_discontinuity\" , \"matched.end_route_discontinuity\" , \"matched.distance_along_edge\" ], \"action\" : \"include\" }","title":"Map Matching API"},{"location":"api/map-matching/api-reference/#map-matching-service-api-reference","text":"With Valhalla's Map Matching service, you can match coordinates, such as GPS locations, to roads and paths that have been mapped in OpenStreetMap. By doing this, you can turn a path into a route with narrative instructions and also get the attribute values from that matched line. You can view an interactive demo or use Mobility Explorer . There are two separate Map Matching calls that perform different operations on an input set of latitude,longitude coordinates. The trace_route action returns the shape snapped to the road network and narrative directions, while trace_attributes returns detailed attribution along the portion of the route. It is important to note that all service requests should be POST because shape or encoded_polyline can be fairly large.","title":"Map Matching service API reference"},{"location":"api/map-matching/api-reference/#trace-route-action","text":"The trace_route action takes the costing mode and a list of latitude,longitude coordinates, for example, from a GPS trace, to turn them into a route with the shape snapped to the road network and a set of guidance directions. You might use this to take a GPS trace from a bike route into a set of narrative instructions so you can re-create your trip or share it with others. By default a single trip leg is returned in a trace_route response. You can split the route response into multiple legs by setting \"type\":\"break\" on any of the input shape objects in the shape parameter of your query. The first and last locations should always have type break. Note that setting breaks is not supported for encoded_polyline input, and is only supported for map_snap mode of the trace_route endpoint.","title":"Trace route action"},{"location":"api/map-matching/api-reference/#trace-attributes-action","text":"The trace_attributes action takes the costing mode and a GPS trace or latitude,longitude positions and returns detailed attribution along the portion of the route. This includes details for each section of road along the path, as well as any intersections along the path. Some of the use cases for trace_attributes include getting: just-in-time information for navigation. Getting attributes only for portions of the upcoming route can improve performance because returning full details along an entire route can create a very large payload. For example, regular route responses include shape and a set of maneuvers along each route leg. The maneuvers are a generalization of the path to simplify the description. Detailed attributes and localization of attributes along a maneuver would require significant additions to the route response. For long and even moderate length routes this can be wasteful, as the chances of re-routing along a long route are high. speed limits. Speed limits along a path are a good example of just-in-time information that can be used for navigation. A single maneuver in a route (US-1, for example) may have many different speed limits along the full length of the maneuver. The trace_attributes action allows speed limits along each road segment to be determined and associated to portions of a maneuver. way IDs. You can turn a GPS trace into a set of way IDs that match the trace. the current road. A map-matching call with a recent set of GPS locations can be useful to find information about the current road, even if not doing navigation or having a route loaded on device. Note that the attributes that are returned are Valhalla routing attributes, not the base OSM tags or base data. Valhalla imports OSM tags and normalizes many of them to a standard set of values used for routing. The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page . To get the base OSM tags along a path, you need to take the OSM way IDs that are returned as attributes along the path and query OSM directly through a process such as the Overpass API .","title":"Trace attributes action"},{"location":"api/map-matching/api-reference/#inputs-of-the-map-matching-service","text":"","title":"Inputs of the Map Matching service"},{"location":"api/map-matching/api-reference/#shape-matching-parameters","text":"shape_match is an optional string input parameter. It allows some control of the matching algorithm based on the type of input. shape_match type Description edge_walk Indicates an edge walking algorithm can be used. This algorithm requires nearly exact shape matching, so it should only be used when the shape is from a prior Valhalla route. map_snap Indicates that a map-matching algorithm should be used because the input shape might not closely match Valhalla edges. This algorithm is more expensive. walk_or_snap Also the default option. This will try edge walking and if this does not succeed, it will fall back and use map matching.","title":"Shape-matching parameters"},{"location":"api/map-matching/api-reference/#costing-models-and-other-options","text":"Valhalla Map Matching uses the auto , auto_shorter , bicycle , bus , and pedestrian costing models available in the Valhalla route service. Refer to the route costing models and costing options documentation for more on how to specify this input. Costing for multimodal is not supported for map matching because it would be difficult to get favorable GPS traces. You can also set directions_options to specify output units, language, and whether or not to return directions in a narrative form. Refer to the route options documentation for examples. trace_route has additional options that allow more flexibility in specifying timestamps (when using encoded polyline input for the trace) and for using timestamps when computing elapsed time along the matched path. These options are: Option Description begin_time Begin timestamp for the trace. This is used along with the durations so that timestamps can be specified for a trace that is specified using an encoded polyline. durations List of durations (seconds) between each successive pair of input trace points. This allows trace points to be supplied as an encoded polyline and timestamps to be created by using this list of \"delta\" times along with the begin_time of the trace. use_timestamps A boolean value indicating whether the input timestamps or durations should be used when computing elapsed time at each edge along the matched path. If true, timestamps are used. If false (default), internal costing is applied to compute elapsed times. trace_options Additional options. trace_options.search_radius Search radius in meters associated with supplied trace points. trace_options.gps_accuracy GPS accuracy in meters associated with supplied trace points. trace_options.breakage_distance Breaking distance in meters between trace points. trace_options.interpolation_distance Interpolation distance in meters beyond which trace points are merged together. linear_references When present and true , the successful trace_route response will include a key linear_references . Its value is an array of base64-encoded OpenLR location references , one for each graph edge of the road network matched by the input trace.","title":"Costing models and other options"},{"location":"api/map-matching/api-reference/#attribute-filters-trace_attributes-only","text":"The trace_attributes action allows you to apply filters to include or exclude specific attribute filter keys in your response. These filters are optional and can be added to the action string inside of the filters object. If no filters are used, all attributes are enabled and returned in the trace_attributes response. These are the available filter keys. Review their descriptions for more information. // Edge filter Keys edge.names edge.length edge.speed edge.road_class edge.begin_heading edge.end_heading edge.begin_shape_index edge.end_shape_index edge.traversability edge.use edge.toll edge.unpaved edge.tunnel edge.bridge edge.roundabout edge.internal_intersection edge.drive_on_right edge.surface edge.sign.exit_number edge.sign.exit_branch edge.sign.exit_toward edge.sign.exit_name edge.travel_mode edge.vehicle_type edge.pedestrian_type edge.bicycle_type edge.transit_type edge.id edge.indoor edge.way_id edge.weighted_grade edge.max_upward_grade edge.max_downward_grade edge.mean_elevation edge.lane_count edge.cycle_lane edge.bicycle_network edge.sac_scale edge.shoulder edge.sidewalk edge.density edge.speed_limit edge.truck_speed edge.truck_route // Node filter keys node.intersecting_edge.begin_heading node.intersecting_edge.from_edge_name_consistency node.intersecting_edge.to_edge_name_consistency node.intersecting_edge.driveability node.intersecting_edge.cyclability node.intersecting_edge.walkability node.intersecting_edge.use node.intersecting_edge.road_class node.intersecting_edge.lane_count node.elapsed_time node.admin_index node.type node.fork node.time_zone // Other filter keys osm_changeset shape admin.country_code admin.country_text admin.state_code admin.state_text matched.point matched.type matched.edge_index matched.begin_route_discontinuity matched.end_route_discontinuity matched.distance_along_edge matched.distance_from_trace_point","title":"Attribute filters (trace_attributes only)"},{"location":"api/map-matching/api-reference/#outputs-of-the-map-matching-service","text":"","title":"Outputs of the Map Matching service"},{"location":"api/map-matching/api-reference/#outputs-of-trace_route","text":"The outputs of the trace_route action are the same as the outputs of a route action.","title":"Outputs of trace_route"},{"location":"api/map-matching/api-reference/#outputs-of-trace_attributes","text":"The trace_attributes results contains a list of edges and, optionally, the following items: osm_changeset , list of admins , shape , matched_points , and units . Result item Description edges List of edges associated with input shape. See the list of edge items for details. osm_changeset Identifier of the OpenStreetMap base data version. admins List of the administrative codes and names. See the list of admin items for details. shape The encoded polyline of the matched path. matched_points List of match results when using the map_snap shape match algorithm. There is a one-to-one correspondence with the input set of latitude, longitude coordinates and this list of match results. See the list of matched point items for details. units The specified units with the request, in either kilometers or miles. warnings A warnings array. This array may contain descriptive text about notices of deprecated request parameters, clamped values etc.","title":"Outputs of trace_attributes"},{"location":"api/map-matching/api-reference/#edge-items","text":"Each edge may include: Edge item Description names List of names. length Edge length in the units specified. The default is kilometers. speed Edge speed in the units specified. The default is kilometers per hour. road_class Road class values: motorway trunk primary secondary tertiary unclassified residential service_other begin_heading The direction at the beginning of an edge. The units are degrees from north in a clockwise direction. end_heading The direction at the end of an edge. The units are degrees from north in a clockwise direction.. begin_shape_index Index into the list of shape points for the start of the edge. end_shape_index Index into the list of shape points for the end of the edge. traversability Traversability values, if available: forward backward both use Use values: tram road ramp turn_channel track driveway alley parking_aisle emergency_access drive_through culdesac cycleway mountain_bike sidewalk footway steps other rail-ferry ferry rail bus rail_connection bus_connnection transit_connection toll True if the edge has any toll. unpaved True if the edge is unpaved or rough pavement. tunnel True if the edge is a tunnel. bridge True if the edge is a bridge. roundabout True if the edge is a roundabout. internal_intersection True if the edge is an internal intersection. drive_on_right True if the flag is enabled for driving on the right side of the street. surface Surface values: paved_smooth paved paved_rough compacted dirt gravel path impassable sign Contains the interchange guide information associated with this edge. See the list of sign items for details. travel_mode Travel mode values: drive pedestrian bicycle transit vehicle_type Vehicle type values: car motorcycle bus tractor_trailer pedestrian_type Pedestrian type values: foot wheelchair segway bicycle_type Bicycle type values: road cross hybrid mountain transit_type Transit type values: tram metro rail bus ferry cable_car gondola funicular id Identifier of an edge within the tiled, hierarchical graph. indoor Whether or not the edge is inside of a building or structure or not. way_id Way identifier of the OpenStreetMap base data. weighted_grade The weighted grade factor. Valhalla manufactures a weighted_grade from elevation data. It is a measure used for hill avoidance in routing - sort of a relative energy use along an edge. But since an edge in Valhalla can possibly go up and down over several hills it might not equate to what most folks think of as grade. max_upward_grade The maximum upward slope. A value of 32768 indicates no elevation data is available for this edge. max_downward_grade The maximum downward slope. A value of 32768 indicates no elevation data is available for this edge. mean_elevation The mean or average elevation along the edge. Units are meters by default. If the units are specified as miles, then the mean elevation is returned in feet. A value of 32768 indicates no elevation data is available for this edge. lane_count The number of lanes for this edge. cycle_lane The type (if any) of bicycle lane along this edge. bicycle_network The bike network for this edge. sac_scale Classification of hiking trails based on difficulty. Values: 0 - No Sac Scale 1 - Hiking 2 - Mountain hiking 3 - Demanding mountain hiking 4 - Alpine hiking 5 - Demanding alpine hiking 6 - Difficult alpine hiking shoulder True if the edge has a shoulder. sidewalk Sidewalk values: left right both density The relative density along the edge. speed_limit Edge speed limit in the units specified. The default is kilometers per hour. truck_speed Edge truck speed in the units specified. The default is kilometers per hour. truck_route True if edge is part of a truck network/route. end_node The node at the end of this edge. See the list of end node items for details.","title":"Edge items"},{"location":"api/map-matching/api-reference/#sign-items","text":"Each sign may include: Sign item Description exit_number List of exit number elements. If an exit number element exists, it is typically just one value. Element example: 91B exit_branch List of exit branch elements. An exit branch element is the subsequent road name or route number after the sign. Element example: I 95 North exit_toward List of exit toward elements. The exit toward element is the location where the road ahead goes; the location is typically a control city, but may also be a future road name or route number. Element example: New York exit_name List of exit name elements. The exit name element is the interchange identifier, although typically not used in the United States. Element example: Gettysburg Pike","title":"Sign items"},{"location":"api/map-matching/api-reference/#end-node-items","text":"Each end_node may include: Node item Description intersecting_edges List of intersecting edges at this node. See the list of intersecting edge items for details. elapsed_time Elapsed time of the path to arrive at this node. admin_index Index value in the admin list. type Node type values: street_intersection gate bollard toll_booth multi_use_transit_stop bike_share parking motor_way_junction border_control fork True if this node is a fork. time_zone Time zone string for this node.","title":"End node items"},{"location":"api/map-matching/api-reference/#intersecting-edge-items","text":"Each intersecting_edge may include: Intersecting edge item Description begin_heading The direction at the beginning of this intersecting edge. The units are degrees from north in a clockwise direction. from_edge_name_consistency True if this intersecting edge at the end node has consistent names with the path from edge . to_edge_name_consistency True if this intersecting edge at the end node has consistent names with the path to edge . driveability Driveability values, if available: forward backward both cyclability Cyclability values, if available: forward backward both walkability Walkability values, if available: forward backward both use Use values: tram road ramp turn_channel track driveway alley parking_aisle emergency_access drive_through culdesac cycleway mountain_bike sidewalk footway steps other rail-ferry ferry rail bus rail_connection bus_connnection transit_connection road_class Road class values: motorway trunk primary secondary tertiary unclassified residential service_other","title":"Intersecting edge items"},{"location":"api/map-matching/api-reference/#admin-items","text":"Each admin may include: Admin item Description country_code Country ISO 3166-1 alpha-2 code. country_text Country name. state_code State code. state_text State name.","title":"Admin items"},{"location":"api/map-matching/api-reference/#matched-point-items","text":"Each matched_point may include: Matched point item Description lat The latitude of the matched point. lon The longitude of the matched point. type Describes the type of this match result - possible values include: unmatched interpolated matched edge_index The index of the edge in the list of edges that this matched point is associated with. This value will not exist if this point was unmatched. begin_route_discontinuity The boolean value is true if this match result is the begin location of a route disconnect. This value will not exist if this is false. end_route_discontinuity The boolean value is true if this match result is the end location of a route disconnect. This value will not exist if this is false. distance_along_edge The distance along the associated edge for this matched point. For example, if the matched point is halfway along the edge then the value would be 0.5. This value will not exist if this point was unmatched. distance_from_trace_point The distance in meters from the trace point to the matched point. This value will not exist if this point was unmatched.","title":"Matched point items"},{"location":"api/map-matching/api-reference/#get-better-results","text":"Follow these guidelines to improve the Map Matching results. You should have good GPS accuracy, meaning that there are few obstructions affecting GPS signals. This can be difficult in urban areas. Make sure the trace point density is within the approximate range of one per second and one per 10 seconds. The greater the range between them, the more chance of inaccurate results. Have each trace represent one continuous path. Verify that there is a corresponding match with the OpenStreetMap network. You can use certain parameters to tune the response. Unless otherwise noted, each of these options is specified within a root-level trace_options object. Use turn_penalty_factor to penalize turns from one road segment to next. For a pedestrian trace_route , you may see a back-and-forth motion along the streets of your path. Try increasing the turn penalty factor to 500 to smooth out jittering of points. Note that if GPS accuracy is already good, increasing this will have a negative affect on your results. Set the gps_accuracy to indicate the accuracy in meters. Apply a search_radius to specify the search radius (in meters) within which to search road candidates for each measurement. The maximum search radius is 100 meters. Note that performance may decrease with a higher search radius value. Add a time component to your GPS data to inform the map matching algorithm about when the point was measured. Providing a time attribute is not available for encoded_polyline data and can only be specified with GPS data provided by the shape attribute. time is specified in seconds and can be a UNIX epoch time or any increasing sequence: { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 , \"time\" : 0 },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 , \"time\" : 2 },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 , \"time\" : 6 }, ... ]}","title":"Get better results"},{"location":"api/map-matching/api-reference/#example-map-matching-requests","text":"","title":"Example Map Matching requests"},{"location":"api/map-matching/api-reference/#example-trace_route-requests","text":"The following are example JSON payloads for POST requests for the trace_routes action. trace_route with shape parameter { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 , \"type\" : \"break\" },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 , \"type\" : \"via\" },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 , \"type\" : \"via\" },{ \"lat\" : 39.983551 , \"lon\" : -76.734253 , \"type\" : \"break\" },{ \"lat\" : 39.983555 , \"lon\" : -76.734116 , \"type\" : \"via\" },{ \"lat\" : 39.983589 , \"lon\" : -76.733315 , \"type\" : \"via\" },{ \"lat\" : 39.983719 , \"lon\" : -76.732445 , \"type\" : \"via\" },{ \"lat\" : 39.983818 , \"lon\" : -76.731712 , \"type\" : \"via\" },{ \"lat\" : 39.983776 , \"lon\" : -76.731506 , \"type\" : \"via\" },{ \"lat\" : 39.983696 , \"lon\" : -76.731369 , \"type\" : \"break\" }], \"costing\" : \"auto\" , \"shape_match\" : \"map_snap\" }} trace_route with encoded polyline parameter { \"encoded_polyline\" : \"_grbgAh~{nhF?lBAzBFvBHxBEtBKdB?fB@dBZdBb@hBh@jBb@x@\\\\|@x@pB\\\\x@v@hBl@nBPbCXtBn@|@z@ZbAEbAa@~@q@z@QhA]pAUpAVhAPlAWtASpAAdA[dASdAQhAIlARjANnAZhAf@n@`A?lB^nCRbA\\\\xB`@vBf@tBTbCFbARzBZvBThBRnBNrBP`CHbCF`CNdCb@vBX`ARlAJfADhA@dAFdAP`AR`Ah@hBd@bBl@rBV|B?vB]tBCvBBhAF`CFnBXtAVxAVpAVtAb@|AZ`Bd@~BJfA@fAHdADhADhABjAGzAInAAjAB|BNbCR|BTjBZtB`@lBh@lB\\\\|Bl@rBXtBN`Al@g@t@?nAA~AKvACvAAlAMdAU`Ac@hAShAI`AJ`AIdAi@bAu@|@k@p@]p@a@bAc@z@g@~@Ot@Bz@f@X`BFtBXdCLbAf@zBh@fBb@xAb@nATjAKjAW`BI|AEpAHjAPdAAfAGdAFjAv@p@XlAVnA?~A?jAInAPtAVxAXnAf@tBDpBJpBXhBJfBDpAZ|Ax@pAz@h@~@lA|@bAnAd@hAj@tAR~AKxAc@xAShA]hAIdAAjA]~A[v@BhB?dBSv@Ct@CvAI~@Oz@Pv@dAz@lAj@~A^`B^|AXvAVpAXdBh@~Ap@fCh@hB\\\\zBN`Aj@xBFdA@jALbAPbAJdAHdAJbAHbAHfAJhALbA\\\\lBTvBAdC@bC@jCKjASbC?`CM`CDpB\\\\xAj@tB\\\\fA\\\\bAVfAJdAJbAXz@L|BO`AOdCDdA@~B\\\\z@l@v@l@v@l@r@j@t@b@x@b@r@z@jBVfCJdAJdANbCPfCF|BRhBS~BS`AYbAe@~BQdA\" , \"shape_match\" : \"map_snap\" , \"costing\" : \"pedestrian\" , \"directions_options\" :{ \"units\" : \"miles\" }} trace_route with additional trace options { \"encoded_polyline\" : \"{gmagAp~_nhF[_AZqAjAaB`AkB\\\\cAZeAPcAHiAKiCQaAUeAe@cA]qAQsACqAF}AIsAg@{@s@i@sAw@i@uANyAPsAv@cAZ_ALqA_@cA_Ai@q@w@[uAm@}AaAqAs@s@m@u@c@oA]mAMiAIkAYqBRyATsANsBKyBAiA?iAFsALuAPsAXaBGgCg@oBKiBf@iBGiBg@oBHqA?{Ai@cA@oAbAgAj@g@j@k@n@q@p@e@n@k@d@}@\\\\cAFgAIoBg@m@y@[_ASu@K{AHgBP{@@w@Jy@L}@JsAMoAe@kAq@kAk@gAg@y@a@m@g@q@mAo@e@gAc@sAA_AI_BFu@LiALaALaAHoAFiAF{A@yABkAKmAKcAMiBU}AYu@MaBUqBu@{As@iAaAaA_Ao@aAi@s@q@{@{@a@sAi@oAGeAD}@[YiAmA[u@BgBXaBHgAQ}@]s@S]x@_BbC}@lAw@dAs@dAk@dAm@z@s@n@y@p@{@`Ao@z@_@z@u@jA_Af@aANiAAcBPsAl@s@X}@T{@PoAPeAl@{@t@_AbAgAjBk@r@e@~AY~@U~@YhAi@lAo@t@kBb@u@NyAX{@k@MoAi@{@eAx@aArAmBt@_ALgAPiAXkAf@w@j@u@p@_A^aA\\\\aA`@eAt@eATcAGcAG}@AeAX_Aj@q@r@aAp@wAt@sARk@xA?pBAvAu@Ps@_Bk@i@y@\\\\s@f@o@j@u@f@{@RwAb@mAZaARkATqANyAImAK}@C_AFqADiAC_AUs@[}Ao@eBm@q@_@_Bg@iAm@kAaAc@s@c@w@y@{AWcAc@{Am@c@yBF{@AkAYmA_@uBD{@B{@Gu@ScBIu@NaB^_B`@sAC{Ac@}A]yAg@aBHuAJ_BAaAEgAA_AAy@@eBX_AFw@JcB^s@VuA`AuAl@kBl@_AFeAJcAB{ABwAj@o@l@q@b@u@Z{AXmAaAm@o@oAwAsAcAsAu@u@cAe@iAy@eAk@iAc@gAOgAWgBe@wAo@}Ai@sBY{@u@s@y@Y{@[aA]s@oB\\\\eCPoARwAXgBV{Ab@sAf@oAb@kAFsA?kACeADeA^aABeAO_Be@gB]}@eAaB_AoAw@aAm@o@q@cBp@eBz@a@fAi@|@o@LiBAyAIoAu@qBkAuAiAa@gAa@cB_@eAQm@c@o@{ANaBf@{@h@_BV}@XcBz@?{@s@o@y@u@}@mAaBw@qCm@mG}@uJLoBVkBVaBh@iB`@gBXgBZ_BZaBNgACwASyAUqAGuBGsBTcBRiB^eCTmBTaBNoAVaB@kAMiBZcAd@eAf@q@z@mAVgB[gAq@aAk@s@UkAG{B_@sAW}ASoBMwBSuB]gBq@eBs@eBaAuAaAeAo@{@i@}@e@{@g@{@m@m@y@_@y@[aBk@a@cBFsB[iAaAGoA`@IcC^yA`@}AVkBNwBBmBR_Cr@{CrAyD|@mCf@kBXeB\\\\eBl@aCf@cBc@sBg@qAUkBe@sBw@eBi@uA{@gAyAc@qAk@[wB@gARqANgAPiAJsAAeAa@mBKmB@uBBwB@oBZoBJkCJkANaCY}Ac@aBa@iBc@iBu@qBu@sBu@sB_AiBcA}AiAqAaAqAeAaA}@]iANgAj@}@dAcAhAeAfAyAfAo@`@k@f@o@f@s@d@o@f@k@h@o@`@s@V_Br@wAv@{An@uAt@qAj@wAl@iAv@gA~@qAbA{A`AcBz@o@^{A`AmAhAo@b@sAxA_@z@]x@a@t@qAxAk@j@qAfAm@b@m@b@kAfAuA~@eAhAcAbAiAr@qA|@gAdAcA`A{@bA_AhAgA|@mAr@qA|@mAlA\" , \"shape_match\" : \"map_snap\" , \"costing\" : \"pedestrian\" , \"trace_options\" :{ \"turn_penalty_factor\" : 500 }, \"directions_options\" :{ \"units\" : \"miles\" }}","title":"Example trace_route requests"},{"location":"api/map-matching/api-reference/#example-trace_attributes-requests","text":"The following are example JSON payloads for POST requests for the trace_attributes action. trace_attributes with shape parameter { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 },{ \"lat\" : 39.983551 , \"lon\" : -76.734253 },{ \"lat\" : 39.983555 , \"lon\" : -76.734116 },{ \"lat\" : 39.983589 , \"lon\" : -76.733315 },{ \"lat\" : 39.983719 , \"lon\" : -76.732445 },{ \"lat\" : 39.983818 , \"lon\" : -76.731712 },{ \"lat\" : 39.983776 , \"lon\" : -76.731506 },{ \"lat\" : 39.983696 , \"lon\" : -76.731369 }], \"costing\" : \"auto\" , \"shape_match\" : \"walk_or_snap\" , \"filters\" :{ \"attributes\" :[ \"edge.names\" , \"edge.id\" , \"edge.weighted_grade\" , \"edge.speed\" ], \"action\" : \"include\" }} trace_attributes with encoded polyline parameter { \"encoded_polyline\" : \"_grbgAh~{nhF?lBAzBFvBHxBEtBKdB?fB@dBZdBb@hBh@jBb@x@\\\\|@x@pB\\\\x@v@hBl@nBPbCXtBn@|@z@ZbAEbAa@~@q@z@QhA]pAUpAVhAPlAWtASpAAdA[dASdAQhAIlARjANnAZhAf@n@`A?lB^nCRbA\\\\xB`@vBf@tBTbCFbARzBZvBThBRnBNrBP`CHbCF`CNdCb@vBX`ARlAJfADhA@dAFdAP`AR`Ah@hBd@bBl@rBV|B?vB]tBCvBBhAF`CFnBXtAVxAVpAVtAb@|AZ`Bd@~BJfA@fAHdADhADhABjAGzAInAAjAB|BNbCR|BTjBZtB`@lBh@lB\\\\|Bl@rBXtBN`Al@g@t@?nAA~AKvACvAAlAMdAU`Ac@hAShAI`AJ`AIdAi@bAu@|@k@p@]p@a@bAc@z@g@~@Ot@Bz@f@X`BFtBXdCLbAf@zBh@fBb@xAb@nATjAKjAW`BI|AEpAHjAPdAAfAGdAFjAv@p@XlAVnA?~A?jAInAPtAVxAXnAf@tBDpBJpBXhBJfBDpAZ|Ax@pAz@h@~@lA|@bAnAd@hAj@tAR~AKxAc@xAShA]hAIdAAjA]~A[v@BhB?dBSv@Ct@CvAI~@Oz@Pv@dAz@lAj@~A^`B^|AXvAVpAXdBh@~Ap@fCh@hB\\\\zBN`Aj@xBFdA@jALbAPbAJdAHdAJbAHbAHfAJhALbA\\\\lBTvBAdC@bC@jCKjASbC?`CM`CDpB\\\\xAj@tB\\\\fA\\\\bAVfAJdAJbAXz@L|BO`AOdCDdA@~B\\\\z@l@v@l@v@l@r@j@t@b@x@b@r@z@jBVfCJdAJdANbCPfCF|BRhBS~BS`AYbAe@~BQdA\" , \"shape_match\" : \"map_snap\" , \"costing\" : \"pedestrian\" , \"directions_options\" :{ \"units\" : \"miles\" }} trace_attributes with include attribute filter { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 },{ \"lat\" : 39.983551 , \"lon\" : -76.734253 },{ \"lat\" : 39.983555 , \"lon\" : -76.734116 },{ \"lat\" : 39.983589 , \"lon\" : -76.733315 },{ \"lat\" : 39.983719 , \"lon\" : -76.732445 },{ \"lat\" : 39.983818 , \"lon\" : -76.731712 },{ \"lat\" : 39.983776 , \"lon\" : -76.731506 },{ \"lat\" : 39.983696 , \"lon\" : -76.731369 }], \"costing\" : \"auto\" , \"shape_match\" : \"walk_or_snap\" , \"filters\" :{ \"attributes\" :[ \"edge.names\" , \"edge.id\" , \"edge.weighted_grade\" , \"edge.speed\" ], \"action\" : \"include\" }} trace_attributes with exclude attribute filter { \"shape\" :[{ \"lat\" : 39.983841 , \"lon\" : -76.735741 },{ \"lat\" : 39.983704 , \"lon\" : -76.735298 },{ \"lat\" : 39.983578 , \"lon\" : -76.734848 },{ \"lat\" : 39.983551 , \"lon\" : -76.734253 },{ \"lat\" : 39.983555 , \"lon\" : -76.734116 },{ \"lat\" : 39.983589 , \"lon\" : -76.733315 },{ \"lat\" : 39.983719 , \"lon\" : -76.732445 },{ \"lat\" : 39.983818 , \"lon\" : -76.731712 },{ \"lat\" : 39.983776 , \"lon\" : -76.731506 },{ \"lat\" : 39.983696 , \"lon\" : -76.731369 }], \"costing\" : \"auto\" , \"shape_match\" : \"walk_or_snap\" , \"filters\" :{ \"attributes\" :[ \"edge.names\" , \"edge.begin_shape_index\" , \"edge.end_shape_index\" , \"shape\" ], \"action\" : \"exclude\" }} If you would like to visualize the map matched points that correlate to specified input locations - use the following filter \"filters\" :{ \"attributes\" :[ \"edge.id\" , \"matched.point\" , \"matched.type\" , \"matched.edge_index\" , \"matched.begin_route_discontinuity\" , \"matched.end_route_discontinuity\" , \"matched.distance_along_edge\" ], \"action\" : \"include\" }","title":"Example trace_attributes requests"},{"location":"api/matrix/api-reference/","text":"Time-Distance Matrix service API reference \u00b6 Valhalla's time-distance matrix service provides a quick computation of time and distance between a set of locations and returns them to you in the resulting matrix table. Matrix service \u00b6 The time distance matrix service takes a sources and targets to list locations. This allows you to set the source (origin) locations separately from the target (destination) locations. The set of origins may be disjoint (not overlapping) with the set of destinations. In other words, the target locations do not have to include any locations from source locations. The time-distance matrix can return a row matrix, a column matrix, or a general matrix of computed time and distance, depending on your input for the sources and targets parameters. The general case is a row ordered matrix with the time and distance from each source location to each target location. A row vector is considered a one_to_many time-distance matrix where there is one source location and multiple target locations. The time and distance from the source location to all target locations is returned. A column matrix represents a many_to_one time-distance matrix where there are many sources and one target. Another special case is when the source location list is the same as the target location list. Here, a diagonal (square matrix with [0,0.00] on the diagonal elements) matrix is returned. The is special case is often used as the input to optimized routing problems. Inputs of the matrix service \u00b6 The matrix request run locally takes the form of localhost:8002/sources_to_targets?json={} , where the JSON inputs inside the {} includes at least one location for both sources and for targets as well as the route costing type and options for the route costing model. For example, while at your office, you want to know the times and distances to walk to several restaurants where you could have dinner, as well as the times and distances from each restaurant to the train station for your commute home. This will help you determine where to eat. one-to-many using /sources_to_targets? { \"sources\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 }], \"targets\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 },{ \"lat\" : 40.739735 , \"lon\" : -73.979713 },{ \"lat\" : 40.752522 , \"lon\" : -73.985015 },{ \"lat\" : 40.750117 , \"lon\" : -73.983704 },{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"costing\" : \"pedestrian\" } &id=Ma n yToMa n y_NYC_work_di nner many-to-one using /sources_to_targets? { \"sources\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 },{ \"lat\" : 40.739735 , \"lon\" : -73.979713 },{ \"lat\" : 40.752522 , \"lon\" : -73.985015 },{ \"lat\" : 40.750117 , \"lon\" : -73.983704 },{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"targets\" :[{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"costing\" : \"pedestrian\" } &id=Ma n yToMa n y_NYC_work_di nner many-to-many using /sources_to_targets? { \"sources\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 },{ \"lat\" : 40.739735 , \"lon\" : -73.979713 },{ \"lat\" : 40.752522 , \"lon\" : -73.985015 },{ \"lat\" : 40.750117 , \"lon\" : -73.983704 },{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"targets\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 },{ \"lat\" : 40.739735 , \"lon\" : -73.979713 },{ \"lat\" : 40.752522 , \"lon\" : -73.985015 },{ \"lat\" : 40.750117 , \"lon\" : -73.983704 },{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"costing\" : \"pedestrian\" } &id=Ma n yToMa n y_NYC_work_di nner Source and target parameters \u00b6 When using the sources_to_targets action, you specify sources and targets as ordered lists of one or more locations within a JSON array, depending on the type of matrix result you are expecting. A source and target must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. Source and target parameters Description lat Latitude of the source/target in degrees. lon Longitude of the source/target in degrees. date_time Expected date/time for the user to be at the location using the ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. date_time as location input offers more granularity over setting time than the global date_time object (see below). You can refer to the route location documentation for more information on specifying locations. Note : date_time strings behave differently for sources_to_targets than for route . If set on the sources and there's more targets than sources , it'll behave like a \"Specified departure time\" on the sources . If set on the targets and there's less targets than sources , it'll behave like a \"Specified arrival time\" on the targets . Also, using type in addition to the lat and lon within the location parameter has no meaning for matrices. Costing parameters \u00b6 The Time-Distance Matrix service uses the auto , bicycle , pedestrian and bikeshare and other costing models available in the route service. Exception: multimodal costing is not supported for the time-distance matrix service at this time. Refer to the route costing models and costing options documentation for more on how to specify this input. Other request options \u00b6 Options Description id Name your matrix request. If id is specified, the naming will be sent thru to the response. matrix_locations For one-to-many or many-to-one requests this specifies the minimum number of locations that satisfy the request. However, when specified, this option allows a partial result to be returned. This is basically equivalent to \"find the closest/best matrix_locations locations out of the full location set\". date_time This is the local date and time at the location. type 0 - Current departure time. 1 - Specified departure time 2 - Specified arrival time. Not yet implemented for multimodal costing method. value - the date and time is specified in ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. For example \"2016-07-03T08:06\" Time-dependent matrices \u00b6 Most control can be achieved when setting a date_time string on each source or target. When setting the global date_time object as a shortcut instead, Valhalla will translate that to setting the date_time.value on all source locations when date_time.type = 0/1 and on all target locations when date_time.type = 2 . However, there are important limitations of the /sources_to_targets service's time awareness. Due to algorithmic complexity, we disallow time-dependence for certain combinations of date_time on locations, if - date_time.type = 0/1 or date_time on any source, when there's more sources than targets - date_time.type = 2 or date_time on any target, when there's more or equal amount of targets than/as sources Outputs of the matrix service \u00b6 If a matrix request has been named using the optional &id= input, then the name will be returned as a string id . These are the results of a request to the Time-Distance Matrix service. Item Description sources_to_targets Returns an array of time and distance between the sources and the targets. The array is row-ordered . This means that the time and distance from the first location to all others forms the first row of the array, followed by the time and distance from the second source location to all target locations, etc. distance The computed distance between each set of points. Distance will always be 0.00 for the first element of the time-distance array for one_to_many , the last element in a many_to_one , and the first and last elements of a many_to_many . time The computed time between each set of points. Time will always be 0 for the first element of the time-distance array for one_to_many , the last element in a many_to_one , and the first and last elements of a many_to_many . to_index The destination index into the locations array. from_index The origin index into the locations array. date_time (optional) If the date_time was valid for an origin, date_time will return the local time at the destination. locations The specified array of lat/lngs from the input request. units Distance units for output. Allowable unit types are mi (miles) and km (kilometers). If no unit type is specified, the units default to kilometers. warnings (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc. See the HTTP return codes for more on messages you might receive from the service. Demonstration \u00b6 View an interactive demo .","title":"Matrix API"},{"location":"api/matrix/api-reference/#time-distance-matrix-service-api-reference","text":"Valhalla's time-distance matrix service provides a quick computation of time and distance between a set of locations and returns them to you in the resulting matrix table.","title":"Time-Distance Matrix service API reference"},{"location":"api/matrix/api-reference/#matrix-service","text":"The time distance matrix service takes a sources and targets to list locations. This allows you to set the source (origin) locations separately from the target (destination) locations. The set of origins may be disjoint (not overlapping) with the set of destinations. In other words, the target locations do not have to include any locations from source locations. The time-distance matrix can return a row matrix, a column matrix, or a general matrix of computed time and distance, depending on your input for the sources and targets parameters. The general case is a row ordered matrix with the time and distance from each source location to each target location. A row vector is considered a one_to_many time-distance matrix where there is one source location and multiple target locations. The time and distance from the source location to all target locations is returned. A column matrix represents a many_to_one time-distance matrix where there are many sources and one target. Another special case is when the source location list is the same as the target location list. Here, a diagonal (square matrix with [0,0.00] on the diagonal elements) matrix is returned. The is special case is often used as the input to optimized routing problems.","title":"Matrix service"},{"location":"api/matrix/api-reference/#inputs-of-the-matrix-service","text":"The matrix request run locally takes the form of localhost:8002/sources_to_targets?json={} , where the JSON inputs inside the {} includes at least one location for both sources and for targets as well as the route costing type and options for the route costing model. For example, while at your office, you want to know the times and distances to walk to several restaurants where you could have dinner, as well as the times and distances from each restaurant to the train station for your commute home. This will help you determine where to eat. one-to-many using /sources_to_targets? { \"sources\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 }], \"targets\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 },{ \"lat\" : 40.739735 , \"lon\" : -73.979713 },{ \"lat\" : 40.752522 , \"lon\" : -73.985015 },{ \"lat\" : 40.750117 , \"lon\" : -73.983704 },{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"costing\" : \"pedestrian\" } &id=Ma n yToMa n y_NYC_work_di nner many-to-one using /sources_to_targets? { \"sources\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 },{ \"lat\" : 40.739735 , \"lon\" : -73.979713 },{ \"lat\" : 40.752522 , \"lon\" : -73.985015 },{ \"lat\" : 40.750117 , \"lon\" : -73.983704 },{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"targets\" :[{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"costing\" : \"pedestrian\" } &id=Ma n yToMa n y_NYC_work_di nner many-to-many using /sources_to_targets? { \"sources\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 },{ \"lat\" : 40.739735 , \"lon\" : -73.979713 },{ \"lat\" : 40.752522 , \"lon\" : -73.985015 },{ \"lat\" : 40.750117 , \"lon\" : -73.983704 },{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"targets\" :[{ \"lat\" : 40.744014 , \"lon\" : -73.990508 },{ \"lat\" : 40.739735 , \"lon\" : -73.979713 },{ \"lat\" : 40.752522 , \"lon\" : -73.985015 },{ \"lat\" : 40.750117 , \"lon\" : -73.983704 },{ \"lat\" : 40.750552 , \"lon\" : -73.993519 }], \"costing\" : \"pedestrian\" } &id=Ma n yToMa n y_NYC_work_di nner","title":"Inputs of the matrix service"},{"location":"api/matrix/api-reference/#source-and-target-parameters","text":"When using the sources_to_targets action, you specify sources and targets as ordered lists of one or more locations within a JSON array, depending on the type of matrix result you are expecting. A source and target must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. Source and target parameters Description lat Latitude of the source/target in degrees. lon Longitude of the source/target in degrees. date_time Expected date/time for the user to be at the location using the ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. date_time as location input offers more granularity over setting time than the global date_time object (see below). You can refer to the route location documentation for more information on specifying locations. Note : date_time strings behave differently for sources_to_targets than for route . If set on the sources and there's more targets than sources , it'll behave like a \"Specified departure time\" on the sources . If set on the targets and there's less targets than sources , it'll behave like a \"Specified arrival time\" on the targets . Also, using type in addition to the lat and lon within the location parameter has no meaning for matrices.","title":"Source and target parameters"},{"location":"api/matrix/api-reference/#costing-parameters","text":"The Time-Distance Matrix service uses the auto , bicycle , pedestrian and bikeshare and other costing models available in the route service. Exception: multimodal costing is not supported for the time-distance matrix service at this time. Refer to the route costing models and costing options documentation for more on how to specify this input.","title":"Costing parameters"},{"location":"api/matrix/api-reference/#other-request-options","text":"Options Description id Name your matrix request. If id is specified, the naming will be sent thru to the response. matrix_locations For one-to-many or many-to-one requests this specifies the minimum number of locations that satisfy the request. However, when specified, this option allows a partial result to be returned. This is basically equivalent to \"find the closest/best matrix_locations locations out of the full location set\". date_time This is the local date and time at the location. type 0 - Current departure time. 1 - Specified departure time 2 - Specified arrival time. Not yet implemented for multimodal costing method. value - the date and time is specified in ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. For example \"2016-07-03T08:06\"","title":"Other request options"},{"location":"api/matrix/api-reference/#time-dependent-matrices","text":"Most control can be achieved when setting a date_time string on each source or target. When setting the global date_time object as a shortcut instead, Valhalla will translate that to setting the date_time.value on all source locations when date_time.type = 0/1 and on all target locations when date_time.type = 2 . However, there are important limitations of the /sources_to_targets service's time awareness. Due to algorithmic complexity, we disallow time-dependence for certain combinations of date_time on locations, if - date_time.type = 0/1 or date_time on any source, when there's more sources than targets - date_time.type = 2 or date_time on any target, when there's more or equal amount of targets than/as sources","title":"Time-dependent matrices"},{"location":"api/matrix/api-reference/#outputs-of-the-matrix-service","text":"If a matrix request has been named using the optional &id= input, then the name will be returned as a string id . These are the results of a request to the Time-Distance Matrix service. Item Description sources_to_targets Returns an array of time and distance between the sources and the targets. The array is row-ordered . This means that the time and distance from the first location to all others forms the first row of the array, followed by the time and distance from the second source location to all target locations, etc. distance The computed distance between each set of points. Distance will always be 0.00 for the first element of the time-distance array for one_to_many , the last element in a many_to_one , and the first and last elements of a many_to_many . time The computed time between each set of points. Time will always be 0 for the first element of the time-distance array for one_to_many , the last element in a many_to_one , and the first and last elements of a many_to_many . to_index The destination index into the locations array. from_index The origin index into the locations array. date_time (optional) If the date_time was valid for an origin, date_time will return the local time at the destination. locations The specified array of lat/lngs from the input request. units Distance units for output. Allowable unit types are mi (miles) and km (kilometers). If no unit type is specified, the units default to kilometers. warnings (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc. See the HTTP return codes for more on messages you might receive from the service.","title":"Outputs of the matrix service"},{"location":"api/matrix/api-reference/#demonstration","text":"View an interactive demo .","title":"Demonstration"},{"location":"api/optimized/api-reference/","text":"Optimized Route service API reference \u00b6 The Optimized Route service provides a quick computation of time and distance between a set of location sources and location targets and returns them in an optimized route order, along with the shape. View an interactive demo Optimized route service action \u00b6 You can request the following action from the Optimized Route service: /optimized_route? . Since an optimized route is really an extension of the many_to_many matrix (where the source locations are the same as the target locations), the first step is to compute a cost matrix by sending a matrix request. Then, we send our resulting cost matrix (resulting time or distance) to the optimizer which will return our optimized path. Optimized type Description optimized_route Returns an optimized route stopping at each destination location exactly one time, always starting at the first location in the list and ending at the last location. This will result in a route with multiple legs. Inputs of the optimized route service \u00b6 The optimized route request run locally takes the form of localhost:8002/optimized_route?json={} , where the JSON inputs inside the {} includes location information (at least four locations), as well as the name and options for the costing model Here is an example of an Optimized Route scenario: Given a list of cities and the distances and times between each pair, a salesperson wants to visit each city one time by taking the most optimized route and end at a destination (either return to origin or a different destination). { \"locations\" :[{ \"lat\" : 40.042072 , \"lon\" : -76.306572 },{ \"lat\" : 39.992115 , \"lon\" : -76.781559 },{ \"lat\" : 39.984519 , \"lon\" : -76.6956 },{ \"lat\" : 39.996586 , \"lon\" : -76.769028 },{ \"lat\" : 39.984322 , \"lon\" : -76.706672 }], \"costing\" : \"auto\" , \"directions_options\" :{ \"units\" : \"miles\" }} There is an option to name your optimized route request. You can do this by appending the following to your request &id= . The id is returned with the response so a user could match to the corresponding request. Location parameters \u00b6 A location must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. External search/geocoding services can be used to find places and geocode addresses, whose coordinates can be used as input to the service. Location parameters Description lat Latitude of the location in degrees. lon Longitude of the location in degrees. Refer to the route location documentation for more information on specifying locations. Costing parameters \u00b6 The Optimized Route service uses the auto , bicycle and pedestrian costing models available in the Valhalla route service. The multimodal costing is not supported for the Optimized Route service at this time. Refer to the route costing models and costing options documentation for more on how to specify this input. Other request options \u00b6 Options Description id Name your optimized request. If id is specified, the naming will be sent thru to the response. Outputs of the optimized route service \u00b6 If an optimized request has been named using the optional &id= input, then the name will be returned as a string id . These are the results of a request to the Optimized Route service. Item Description optimized_route Returns an optimized route path from point 'a' to point 'n'. Given a list of locations, an optimized route with stops at each intermediate location exactly one time, always starting at the first location in the list and ending at the last location. locations The specified array of lat/lngs from the input request. The first and last locations in the array will remain the same as the input request. The intermediate locations may be returned reordered in the response. Due to the reordering of the intermediate locations, an original_index is also part of the locations object within the response. This is an identifier of the location index that will allow a user to easily correlate input locations with output locations. units Distance units for output. Allowable unit types are mi (miles) and km (kilometers). If no unit type is specified, the units default to kilometers. warnings (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc. Error checking \u00b6 The service checks the return to see that all locations can be reached. If one or more cannot be reached, it returns an error and lists the location number that cannot be reached. Currently, one location is listed at this time, even if more than one have an issue. This is an example which should return: 400::Location at index 3 is unreachable { \"locations\" :[{ \"lat\" : 40.306600 , \"lon\" : -76.900022 },{ \"lat\" : 40.293246 , \"lon\" : -76.936230 },{ \"lat\" : 40.448678 , \"lon\" : -76.932885 },{ \"lat\" : 40.419753 , \"lon\" : -76.999632 },{ \"lat\" : 40.211050 , \"lon\" : -76.777071 },{ \"lat\" : 40.306600 , \"lon\" : -76.900022 }], \"costing\" : \"auto\" } See the HTTP return codes for more on messages you might receive from the service.","title":"Optimized Route API"},{"location":"api/optimized/api-reference/#optimized-route-service-api-reference","text":"The Optimized Route service provides a quick computation of time and distance between a set of location sources and location targets and returns them in an optimized route order, along with the shape. View an interactive demo","title":"Optimized Route service API reference"},{"location":"api/optimized/api-reference/#optimized-route-service-action","text":"You can request the following action from the Optimized Route service: /optimized_route? . Since an optimized route is really an extension of the many_to_many matrix (where the source locations are the same as the target locations), the first step is to compute a cost matrix by sending a matrix request. Then, we send our resulting cost matrix (resulting time or distance) to the optimizer which will return our optimized path. Optimized type Description optimized_route Returns an optimized route stopping at each destination location exactly one time, always starting at the first location in the list and ending at the last location. This will result in a route with multiple legs.","title":"Optimized route service action"},{"location":"api/optimized/api-reference/#inputs-of-the-optimized-route-service","text":"The optimized route request run locally takes the form of localhost:8002/optimized_route?json={} , where the JSON inputs inside the {} includes location information (at least four locations), as well as the name and options for the costing model Here is an example of an Optimized Route scenario: Given a list of cities and the distances and times between each pair, a salesperson wants to visit each city one time by taking the most optimized route and end at a destination (either return to origin or a different destination). { \"locations\" :[{ \"lat\" : 40.042072 , \"lon\" : -76.306572 },{ \"lat\" : 39.992115 , \"lon\" : -76.781559 },{ \"lat\" : 39.984519 , \"lon\" : -76.6956 },{ \"lat\" : 39.996586 , \"lon\" : -76.769028 },{ \"lat\" : 39.984322 , \"lon\" : -76.706672 }], \"costing\" : \"auto\" , \"directions_options\" :{ \"units\" : \"miles\" }} There is an option to name your optimized route request. You can do this by appending the following to your request &id= . The id is returned with the response so a user could match to the corresponding request.","title":"Inputs of the optimized route service"},{"location":"api/optimized/api-reference/#location-parameters","text":"A location must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. External search/geocoding services can be used to find places and geocode addresses, whose coordinates can be used as input to the service. Location parameters Description lat Latitude of the location in degrees. lon Longitude of the location in degrees. Refer to the route location documentation for more information on specifying locations.","title":"Location parameters"},{"location":"api/optimized/api-reference/#costing-parameters","text":"The Optimized Route service uses the auto , bicycle and pedestrian costing models available in the Valhalla route service. The multimodal costing is not supported for the Optimized Route service at this time. Refer to the route costing models and costing options documentation for more on how to specify this input.","title":"Costing parameters"},{"location":"api/optimized/api-reference/#other-request-options","text":"Options Description id Name your optimized request. If id is specified, the naming will be sent thru to the response.","title":"Other request options"},{"location":"api/optimized/api-reference/#outputs-of-the-optimized-route-service","text":"If an optimized request has been named using the optional &id= input, then the name will be returned as a string id . These are the results of a request to the Optimized Route service. Item Description optimized_route Returns an optimized route path from point 'a' to point 'n'. Given a list of locations, an optimized route with stops at each intermediate location exactly one time, always starting at the first location in the list and ending at the last location. locations The specified array of lat/lngs from the input request. The first and last locations in the array will remain the same as the input request. The intermediate locations may be returned reordered in the response. Due to the reordering of the intermediate locations, an original_index is also part of the locations object within the response. This is an identifier of the location index that will allow a user to easily correlate input locations with output locations. units Distance units for output. Allowable unit types are mi (miles) and km (kilometers). If no unit type is specified, the units default to kilometers. warnings (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc.","title":"Outputs of the optimized route service"},{"location":"api/optimized/api-reference/#error-checking","text":"The service checks the return to see that all locations can be reached. If one or more cannot be reached, it returns an error and lists the location number that cannot be reached. Currently, one location is listed at this time, even if more than one have an issue. This is an example which should return: 400::Location at index 3 is unreachable { \"locations\" :[{ \"lat\" : 40.306600 , \"lon\" : -76.900022 },{ \"lat\" : 40.293246 , \"lon\" : -76.936230 },{ \"lat\" : 40.448678 , \"lon\" : -76.932885 },{ \"lat\" : 40.419753 , \"lon\" : -76.999632 },{ \"lat\" : 40.211050 , \"lon\" : -76.777071 },{ \"lat\" : 40.306600 , \"lon\" : -76.900022 }], \"costing\" : \"auto\" } See the HTTP return codes for more on messages you might receive from the service.","title":"Error checking"},{"location":"api/status/api-reference/","text":"Status service API reference \u00b6 By default the /status endpoint will return a HTTP status code of 200 with version and tileset_last_modified (as UNIX timestamp) info, which can also be used as a health endpoint for the HTTP API. However, if \"verbose\": true is passed as a request parameter it will return additional information about the loaded tileset. Note that gathering this additional information can be computationally expensive, hence the verbose flag can be disallowed in the configuration JSON ( service_limits.status.allow_verbose , default false ). Outputs of the Status service \u00b6 If \"verbose\": true is passed as a parameter, the service will output the following response: Response key Type Description version string The current Valhalla version, e.g. 3.1.4 . tileset_last_modified integer The time the tile_extract or tile_dir were last modified as UNIX timestamp, e.g. 1634903519. has_tiles bool Whether a valid tileset is currently loaded. has_admins bool Whether the current tileset was built using the admin database. has_timezones bool Whether the current tileset was built using the timezone database. has_live_traffic bool Whether live traffic tiles are currently available. bbox object GeoJSON of the tileset extent. warnings (optional) array This array may contain warning objects informing about deprecated request parameters, clamped values etc.","title":"Status API"},{"location":"api/status/api-reference/#status-service-api-reference","text":"By default the /status endpoint will return a HTTP status code of 200 with version and tileset_last_modified (as UNIX timestamp) info, which can also be used as a health endpoint for the HTTP API. However, if \"verbose\": true is passed as a request parameter it will return additional information about the loaded tileset. Note that gathering this additional information can be computationally expensive, hence the verbose flag can be disallowed in the configuration JSON ( service_limits.status.allow_verbose , default false ).","title":"Status service API reference"},{"location":"api/status/api-reference/#outputs-of-the-status-service","text":"If \"verbose\": true is passed as a parameter, the service will output the following response: Response key Type Description version string The current Valhalla version, e.g. 3.1.4 . tileset_last_modified integer The time the tile_extract or tile_dir were last modified as UNIX timestamp, e.g. 1634903519. has_tiles bool Whether a valid tileset is currently loaded. has_admins bool Whether the current tileset was built using the admin database. has_timezones bool Whether the current tileset was built using the timezone database. has_live_traffic bool Whether live traffic tiles are currently available. bbox object GeoJSON of the tileset extent. warnings (optional) array This array may contain warning objects informing about deprecated request parameters, clamped values etc.","title":"Outputs of the Status service"},{"location":"api/turn-by-turn/add-routing-to-a-map/","text":"Add Turn-by-Turn routing to a map \u00b6 The result of a routing request is a special format that needs some processing to show in a JavaScript-based web map application. For Leaflet , the Leaflet Routing Machine via the lrm-valhalla plugin helps. Please note that mapzen urls are no longer available, so one must set the serviceUrl within the options of the L.Routing.mapzen router to point to a valid Valhalla route service! You can review the documentation to learn more about routing with Turn-by-Turn.","title":"Add Turn-by-Turn routing to a map"},{"location":"api/turn-by-turn/add-routing-to-a-map/#add-turn-by-turn-routing-to-a-map","text":"The result of a routing request is a special format that needs some processing to show in a JavaScript-based web map application. For Leaflet , the Leaflet Routing Machine via the lrm-valhalla plugin helps. Please note that mapzen urls are no longer available, so one must set the serviceUrl within the options of the L.Routing.mapzen router to point to a valid Valhalla route service! You can review the documentation to learn more about routing with Turn-by-Turn.","title":"Add Turn-by-Turn routing to a map"},{"location":"api/turn-by-turn/api-reference/","text":"Valhalla routing service API reference \u00b6 Valhalla's routing service (a.k.a. turn-by-turn), is an open-source routing service that lets you integrate routing and navigation into a web or mobile application. View an interactive demo The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page . Inputs of a route \u00b6 The route request run locally takes the form of localhost:8002/route?json={} , where the JSON inputs inside the {} include location information, name and options for the costing model, and output options. Here is the JSON payload for an example request: { \"locations\" :[{ \"lat\" : 42.358528 , \"lon\" : -83.271400 , \"street\" : \"Appleton\" },{ \"lat\" : 42.996613 , \"lon\" : -78.749855 , \"street\" : \"Ranch Trail\" }], \"costing\" : \"auto\" , \"costing_options\" :{ \"auto\" :{ \"country_crossing_penalty\" : 2000.0 }}, \"units\" : \"miles\" , \"id\" : \"my_work_route\" } This request provides automobile routing between the Detroit, Michigan area and Buffalo, New York, with an optional street name parameter to improve navigation at the start and end points. It attempts to avoid routing north through Canada by adding a penalty for crossing international borders. The resulting route is displayed in miles. There is an option to name your route request. You can do this by appending the following to your request &id= . The id is returned with the response so a user could match to the corresponding request. Locations \u00b6 You specify locations as an ordered list of two or more locations within a JSON array. Locations are visited in the order specified. A location must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. Note that the Valhalla cannot search for names or addresses or perform geocoding or reverse geocoding. External search services, such as Mapbox Geocoding , can be used to find places and geocode addresses, which must be converted to coordinates for input. To build a route, you need to specify two break locations. In addition, you can include through , via or break_through locations to influence the route path. Location parameters Description lat Latitude of the location in degrees. This is assumed to be both the routing location and the display location if no display_lat and display_lon are provided. lon Longitude of the location in degrees. This is assumed to be both the routing location and the display location if no display_lat and display_lon are provided. type Type of location, either break , through , via or break_through . Each type controls two characteristics: whether or not to allow a u-turn at the location and whether or not to generate guidance/legs at the location. A break is a location at which we allows u-turns and generate legs and arrival/departure maneuvers. A through location is a location at which we neither allow u-turns nor generate legs or arrival/departure maneuvers. A via location is a location at which we allow u-turns but do not generate legs or arrival/departure maneuvers. A break_through location is a location at which we do not allow u-turns but do generate legs and arrival/departure maneuvers. If no type is provided, the type is assumed to be a break . The types of the first and last locations are ignored and are treated as break s. heading (optional) Preferred direction of travel for the start from the location. This can be useful for mobile routing where a vehicle is traveling in a specific direction along a road, and the route should start in that direction. The heading is indicated in degrees from north in a clockwise direction, where north is 0\u00b0, east is 90\u00b0, south is 180\u00b0, and west is 270\u00b0. heading_tolerance (optional) How close in degrees a given street's angle must be in order for it to be considered as in the same direction of the heading parameter. The default value is 60 degrees. street (optional) Street name. The street name may be used to assist finding the correct routing location at the specified latitude, longitude. This is not currently implemented. way_id (optional) OpenStreetMap identification number for a polyline way . The way ID may be used to assist finding the correct routing location at the specified latitude, longitude. This is not currently implemented. minimum_reachability Minimum number of nodes (intersections) reachable for a given edge (road between intersections) to consider that edge as belonging to a connected region. When correlating this location to the route network, try to find candidates who are reachable from this many or more nodes (intersections). If a given candidate edge reaches less than this number of nodes its considered to be a disconnected island and we'll search for more candidates until we find at least one that isn't considered a disconnected island. If this value is larger than the configured service limit it will be clamped to that limit. The default is a minimum of 50 reachable nodes. radius The number of meters about this input location within which edges (roads between intersections) will be considered as candidates for said location. When correlating this location to the route network, try to only return results within this distance (meters) from this location. If there are no candidates within this distance it will return the closest candidate within reason. If this value is larger than the configured service limit it will be clamped to that limit. The default is 0 meters. rank_candidates Whether or not to rank the edge candidates for this location. The ranking is used as a penalty within the routing algorithm so that some edges will be penalized more heavily than others. If true candidates will be ranked according to their distance from the input and various other attributes. If false the candidates will all be treated as equal which should lead to routes that are just the most optimal path with emphasis about which edges were selected. preferred_side If the location is not offset from the road centerline or is closest to an intersection this option has no effect. Otherwise the determined side of street is used to determine whether or not the location should be visited from the same , opposite or either side of the road with respect to the side of the road the given locale drives on. In Germany (driving on the right side of the road), passing a value of same will only allow you to leave from or arrive at a location such that the location will be on your right. In Australia (driving on the left side of the road), passing a value of same will force the location to be on your left. A value of opposite will enforce arriving/departing from a location on the opposite side of the road from that which you would be driving on while a value of either will make no attempt limit the side of street that is available for the route. display_lat Latitude of the map location in degrees. If provided the lat and lon parameters will be treated as the routing location and the display_lat and display_lon will be used to determine the side of street. Both display_lat and display_lon must be provided and valid to achieve the desired effect. display_lon Longitude of the map location in degrees. If provided the lat and lon parameters will be treated as the routing location and the display_lat and display_lon will be used to determine the side of street. Both display_lat and display_lon must be provided and valid to achieve the desired effect. search_cutoff The cutoff at which we will assume the input is too far away from civilisation to be worth correlating to the nearest graph elements node_snap_tolerance During edge correlation this is the tolerance used to determine whether or not to snap to the intersection rather than along the street, if the snap location is within this distance from the intersection the intersection is used instead. The default is 5 meters street_side_tolerance If your input coordinate is less than this tolerance away from the edge centerline then we set your side of street to none otherwise your side of street will be left or right depending on direction of travel street_side_max_distance The max distance in meters that the input coordinates or display ll can be from the edge centerline for them to be used for determining the side of street. Beyond this distance the side of street is set to none search_filter A set of optional filters to exclude candidate edges based on their attribution. The following exclusion filters are supported: exclude_tunnel (boolean, defaults to false ): whether to exclude roads marked as tunnels exclude_bridge (boolean, defaults to false ): whether to exclude roads marked as bridges exclude_ramp (boolean, defaults to false ): whether to exclude link roads marked as ramps, note that some turn channels are also marked as ramps exclude_closures (boolean, defaults to true ): whether to exclude roads considered closed due to live traffic closure. Note: This option cannot be set if costing_options.<costing>.ignore_closures is also specified. An error is returned if both options are specified. Note 2: Ignoring closures at destination and source locations does NOT work for date_time type 0/1 & 2 respectively min_road_class (string, defaults to \"service_other\" ): lowest road class allowed max_road_class (string, defaults to \"motorway\" ): highest road class allowed Road classes from highest to lowest are: motorway, trunk, primary, secondary, tertiary, unclassified, residential, service_other. Optionally, you can include the following location information without impacting the routing. This information is carried through the request and returned as a convenience. name = Location or business name. The name may be used in the route narration directions, such as \"You have arrived at <business name> .\") city = City name. state = State name. postal_code = Postal code. country = Country name. phone = Telephone number. url = URL for the place or location. waiting : The waiting time in seconds at this location. E.g. when the route describes a pizza delivery tour, each location has a service time, which can be respected by setting waiting on the location, then the departure will be delayed by this amount in seconds. Only works for break or break_through types. side_of_street = (response only) The side of street of a break location that is determined based on the actual route when the location is offset from the street. The possible values are left and right . date_time = (response only for /route ) Expected date/time for the user to be at the location using the ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. For example \"2015-12-29T08:00\". If waiting was set on this location in the request, and it's an intermediate location, the date_time will describe the departure time at this location. Future development work includes adding location options and information related to time at each location. This will allow routes to specify a start time or an arrive by time at each location. There is also ongoing work to improve support for through locations. Costing models \u00b6 Valhalla's routing service uses dynamic, run-time costing to generate the route path. The route request must include the name of the costing model and can include optional parameters available for the chosen costing model. Costing model Description auto Standard costing for driving routes by car, motorcycle, truck, and so on that obeys automobile driving rules, such as access and turn restrictions. Auto provides a short time path (though not guaranteed to be shortest time) and uses intersection costing to minimize turns and maneuvers or road name changes. Routes also tend to favor highways and higher classification roads, such as motorways and trunks. bicycle Standard costing for travel by bicycle, with a slight preference for using cycleways or roads with bicycle lanes. Bicycle routes follow regular roads when needed, but avoid roads without bicycle access. bus Standard costing for bus routes. Bus costing inherits the auto costing behaviors, but checks for bus access on the roads. BETA bikeshare A combination of pedestrian and bicycle. Use bike share station( amenity:bicycle_rental ) to change the travel mode truck Standard costing for trucks. Truck costing inherits the auto costing behaviors, but checks for truck access, width and height restrictions, and weight limits on the roads. hov DEPRECATED: use auto cost with HOV costing options. taxi Standard costing for taxi routes. Taxi costing inherits the auto costing behaviors, but checks for taxi lane access on the roads and favors those roads. motor_scooter Standard costing for travel by motor scooter or moped. By default, motor_scooter costing will avoid higher class roads unless the country overrides allows motor scooters on these roads. Motor scooter routes follow regular roads when needed, but avoid roads without motor_scooter, moped, or mofa access. BETA motorcycle Standard costing for travel by motorcycle. This costing model provides options to tune the route to take roadways (road touring) vs. tracks and trails (adventure motorcycling). multimodal Currently supports pedestrian and transit. In the future, multimodal will support a combination of all of the above. pedestrian Standard walking route that excludes roads without pedestrian access. In general, pedestrian routes are shortest distance with the following exceptions: walkways and footpaths are slightly favored, while steps or stairs and alleys are slightly avoided. Costing options \u00b6 Costing methods can have several options that can be adjusted to develop the route path, as well as for estimating time along the path. Specify costing model options in your request using the format of costing_options.type , such as costing_options.auto . Cost options are fixed costs in seconds that are added to both the path cost and the estimated time. Examples of costs are gate_costs and toll_booth_costs , where a fixed amount of time is added. Costs are not generally used to influence the route path; instead, use penalties to do this. Costs must be in the range of 0.0 seconds to 43200.0 seconds (12 hours), otherwise a default value will be assigned. Penalty options are fixed costs in seconds that are only added to the path cost. Penalties can influence the route path determination but do not add to the estimated time along the path. For example, add a toll_booth_penalty to create route paths that tend to avoid toll booths. Penalties must be in the range of 0.0 seconds to 43200.0 seconds (12 hours), otherwise a default value will be assigned. Factor options are used to multiply the cost along an edge or road section in a way that influences the path to favor or avoid a particular attribute. Factor options do not impact estimated time along the path, though. Factors must be in the range 0.1 to 100000.0, where factors of 1.0 have no influence on cost. Anything outside of this range will be assigned a default value. Use a factor less than 1.0 to attempt to favor paths containing preferred attributes, and a value greater than 1.0 to avoid paths with undesirable attributes. Avoidance factors are more effective than favor factors at influencing a path. A factor's impact also depends on the length of road containing the specified attribute, as longer roads have more impact on the costing than very short roads. For this reason, penalty options tend to be better at influencing paths. A special costing option is shortest , which, when true , will solely use distance as cost and disregard all other costs, penalties and factors. It's available for all costing models except multimodal & bikeshare . Automobile and bus costing options \u00b6 These options are available for auto , bus , and truck costing methods. Automobile options Description maneuver_penalty A penalty applied when transitioning between roads that do not have consistent naming\u2013in other words, no road names in common. This penalty can be used to create simpler routes that tend to have fewer maneuvers or narrative guidance instructions. The default maneuver penalty is five seconds. gate_cost A cost applied when a gate with undefined or private access is encountered. This cost is added to the estimated time / elapsed time. The default gate cost is 30 seconds. gate_penalty A penalty applied when a gate with no access information is on the road. The default gate penalty is 300 seconds. private_access_penalty A penalty applied when a gate or bollard with access=private is encountered. The default private access penalty is 450 seconds. toll_booth_cost A cost applied when a toll booth is encountered. This cost is added to the estimated and elapsed times. The default cost is 15 seconds. toll_booth_penalty A penalty applied to the cost when a toll booth is encountered. This penalty can be used to create paths that avoid toll roads. The default toll booth penalty is 0. ferry_cost A cost applied when entering a ferry. This cost is added to the estimated and elapsed times. The default cost is 300 seconds (5 minutes). use_ferry This value indicates the willingness to take ferries. This is a range of values between 0 and 1. Values near 0 attempt to avoid ferries and values near 1 will favor ferries. The default value is 0.5. Note that sometimes ferries are required to complete a route so values of 0 are not guaranteed to avoid ferries entirely. use_highways This value indicates the willingness to take highways. This is a range of values between 0 and 1. Values near 0 attempt to avoid highways and values near 1 will favor highways. The default value is 1.0. Note that sometimes highways are required to complete a route so values of 0 are not guaranteed to avoid highways entirely. use_tolls This value indicates the willingness to take roads with tolls. This is a range of values between 0 and 1. Values near 0 attempt to avoid tolls and values near 1 will not attempt to avoid them. The default value is 0.5. Note that sometimes roads with tolls are required to complete a route so values of 0 are not guaranteed to avoid them entirely. use_living_streets This value indicates the willingness to take living streets. This is a range of values between 0 and 1. Values near 0 attempt to avoid living streets and values near 1 will favor living streets. The default value is 0 for trucks, 0.1 for cars, buses, motor scooters and motorcycles. Note that sometimes living streets are required to complete a route so values of 0 are not guaranteed to avoid living streets entirely. use_tracks This value indicates the willingness to take track roads. This is a range of values between 0 and 1. Values near 0 attempt to avoid tracks and values near 1 will favor tracks a little bit. The default value is 0 for autos, 0.5 for motor scooters and motorcycles. Note that sometimes tracks are required to complete a route so values of 0 are not guaranteed to avoid tracks entirely. service_penalty A penalty applied for transition to generic service road. The default penalty is 0 trucks and 15 for cars, buses, motor scooters and motorcycles. service_factor A factor that modifies (multiplies) the cost when generic service roads are encountered. The default service_factor is 1. country_crossing_cost A cost applied when encountering an international border. This cost is added to the estimated and elapsed times. The default cost is 600 seconds. country_crossing_penalty A penalty applied for a country crossing. This penalty can be used to create paths that avoid spanning country boundaries. The default penalty is 0. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false . top_speed Top speed the vehicle can go. Also used to avoid roads with higher speeds than this value. top_speed must be between 10 and 252 KPH. The default value is 140 KPH. fixed_speed Fixed speed the vehicle can go. Used to override the calculated speed. Can be useful if speed of vehicle is known. fixed_speed must be between 1 and 252 KPH. The default value is 0 KPH which disables fixed speed and falls back to the standard calculated speed based on the road attribution. ignore_closures If set to true , ignores all closures, marked due to live traffic closures, during routing. Note: This option cannot be set if location.search_filter.exclude_closures is also specified in the request and will return an error if it is closure_factor A factor that penalizes the cost when traversing a closed edge (eg: if search_filter.exclude_closures is false for origin and/or destination location and the route starts/ends on closed edges). Its value can range from 1.0 - don't penalize closed edges, to 10.0 - apply high cost penalty to closed edges. Default value is 9.0 . Note: This factor is applicable only for motorized modes of transport, i.e auto , motorcycle , motor_scooter , bus , truck & taxi . Other costing options \u00b6 The following options are available for auto , bus , taxi , and truck costing methods. Vehicle Options Description height The height of the vehicle (in meters). Default 1.9 for car, bus, taxi and 4.11 for truck. width The width of the vehicle (in meters). Default 1.6 for car, bus, taxi and 2.6 for truck. exclude_unpaved This value indicates whether or not the path may include unpaved roads. If exclude_unpaved is set to 1 it is allowed to start and end with unpaved roads, but is not allowed to have them in the middle of the route path, otherwise they are allowed. Default false. exclude_cash_only_tolls A boolean value which indicates the desire to avoid routes with cash-only tolls. Default false. include_hov2 A boolean value which indicates the desire to include HOV roads with a 2-occupant requirement in the route when advantageous. Default false. include_hov3 A boolean value which indicates the desire to include HOV roads with a 3-occupant requirement in the route when advantageous. Default false. include_hot A boolean value which indicates the desire to include tolled HOV roads which require the driver to pay a toll if the occupant requirement isn't met. Default false. The following options are available for truck costing. Truck options Description length The length of the truck (in meters). Default 21.64. weight The weight of the truck (in metric tons). Default 21.77. axle_load The axle load of the truck (in metric tons). Default 9.07. axle_count The axle count of the truck. Default 5. hazmat A value indicating if the truck is carrying hazardous materials. Default false. Bicycle costing options \u00b6 The default bicycle costing is tuned toward road bicycles with a slight preference for using cycleways or roads with bicycle lanes. Bicycle routes use regular roads where needed or where no direct bicycle lane options exist, but avoid roads without bicycle access. The costing model recognizes several factors unique to bicycle travel and offers several options for tuning bicycle routes. Several factors unique to travel by bicycle influence the resulting route. The types of roads suitable for bicycling depend on the type of bicycle. Road bicycles (skinny or narrow tires) generally are suited to paved roads or perhaps very short sections of compacted gravel. They are not designed for riding on coarse gravel or most paths and tracks through wooded areas or farmland. Mountain bikes, on the other hand, are able to traverse a wider set of surfaces. Average travel speed can be highly variable and can depend on bicycle type, fitness and experience of the cyclist, road surface, and hills. The costing model assumes a default speed on smooth, flat roads for each supported bicycle type. This speed can be overridden by an input option. The base speed is modulated by surface type (in conjunction with the bicycle type). In addition, speed is modified based on the hilliness of a road section. Bicyclists vary in their tolerance for riding on roads. Most novice bicyclists, and even other bicyclists, prefer cycleways and dedicated cycling paths and would rather avoid all but the quietest neighborhood roads. Other cyclists may be experienced riding on roads and prefer to take roadways because they often provide the fastest way to get between two places. The bicycle costing model accounts for this with a use_roads factor to indicate a cyclist's tolerance for riding on roads. Bicyclists vary in their fitness level and experience level, and many want to avoid hilly roads, and especially roads with very steep uphill or even downhill sections. Even if the fastest path is over a mountain, many cyclists prefer a flatter path that avoids the climb and descent up and over the mountain. The following options described above for autos also apply to bicycle costing methods: maneuver_penalty , gate_cost , gate_penalty , country_crossing_cost , country_costing_penalty , and service_penalty . These additional options are available for bicycle costing methods. Bicycle options Description bicycle_type The type of bicycle. The default type is Hybrid . Road : a road-style bicycle with narrow tires that is generally lightweight and designed for speed on paved surfaces. Hybrid or City : a bicycle made mostly for city riding or casual riding on roads and paths with good surfaces. Cross : a cyclo-cross bicycle, which is similar to a road bicycle but with wider tires suitable to rougher surfaces. Mountain : a mountain bicycle suitable for most surfaces but generally heavier and slower on paved surfaces. cycling_speed Cycling speed is the average travel speed along smooth, flat roads. This is meant to be the speed a rider can comfortably maintain over the desired distance of the route. It can be modified (in the costing method) by surface type in conjunction with bicycle type and (coming soon) by hilliness of the road section. When no speed is specifically provided, the default speed is determined by the bicycle type and are as follows: Road = 25 KPH (15.5 MPH), Cross = 20 KPH (13 MPH), Hybrid/City = 18 KPH (11.5 MPH), and Mountain = 16 KPH (10 MPH). use_roads A cyclist's propensity to use roads alongside other vehicles. This is a range of values from 0 to 1, where 0 attempts to avoid roads and stay on cycleways and paths, and 1 indicates the rider is more comfortable riding on roads. Based on the use_roads factor, roads with certain classifications and higher speeds are penalized in an attempt to avoid them when finding the best path. The default value is 0.5. use_hills A cyclist's desire to tackle hills in their routes. This is a range of values from 0 to 1, where 0 attempts to avoid hills and steep grades even if it means a longer (time and distance) path, while 1 indicates the rider does not fear hills and steeper grades. Based on the use_hills factor, penalties are applied to roads based on elevation change and grade. These penalties help the path avoid hilly roads in favor of flatter roads or less steep grades where available. Note that it is not always possible to find alternate paths to avoid hills (for example when route locations are in mountainous areas). The default value is 0.5. use_ferry This value indicates the willingness to take ferries. This is a range of values between 0 and 1. Values near 0 attempt to avoid ferries and values near 1 will favor ferries. Note that sometimes ferries are required to complete a route so values of 0 are not guaranteed to avoid ferries entirely. The default value is 0.5. use_living_streets This value indicates the willingness to take living streets. This is a range of values between 0 and 1. Values near 0 attempt to avoid living streets and values from 0.5 to 1 will currently have no effect on route selection. The default value is 0.5. Note that sometimes living streets are required to complete a route so values of 0 are not guaranteed to avoid living streets entirely. avoid_bad_surfaces This value is meant to represent how much a cyclist wants to avoid roads with poor surfaces relative to the bicycle type being used. This is a range of values between 0 and 1. When the value is 0, there is no penalization of roads with different surface types; only bicycle speed on each surface is taken into account. As the value approaches 1, roads with poor surfaces for the bike are penalized heavier so that they are only taken if they significantly improve travel time. When the value is equal to 1, all bad surfaces are completely disallowed from routing, including start and end points. The default value is 0.25. bss_return_cost This value is useful when bikeshare is chosen as travel mode. It is meant to give the time will be used to return a rental bike. This value will be displayed in the final directions and used to calculate the whole duation. The default value is 120 seconds. bss_return_penalty This value is useful when bikeshare is chosen as travel mode. It is meant to describe the potential effort to return a rental bike. This value won't be displayed and used only inside of the algorithm. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false . Motor_scooter costing options \u00b6 Standard costing for travel by motor scooter or moped. By default, motor_scooter costing will avoid higher class roads unless the country overrides allows motor scooters on these roads. Motor scooter routes follow regular roads when needed, but avoid roads without motor_scooter, moped, or mofa access. The costing model recognizes factors unique to motor_scooter travel and offers options for tuning motor_scooter routes. Factors unique to travel by motor_scooter influence the resulting route. All of the options described above for autos also apply to motor_scooter costing methods. These additional options are available for motor_scooter costing methods. Motor_scooter options Description top_speed Top speed the motorized scooter can go. Used to avoid roads with higher speeds than this value. For motor_scooter this value must be between 20 and 120 KPH. The default value is 45 KPH (~28 MPH) use_primary A riders's propensity to use primary roads. This is a range of values from 0 to 1, where 0 attempts to avoid primary roads, and 1 indicates the rider is more comfortable riding on primary roads. Based on the use_primary factor, roads with certain classifications and higher speeds are penalized in an attempt to avoid them when finding the best path. The default value is 0.5. use_hills A riders's desire to tackle hills in their routes. This is a range of values from 0 to 1, where 0 attempts to avoid hills and steep grades even if it means a longer (time and distance) path, while 1 indicates the rider does not fear hills and steeper grades. Based on the use_hills factor, penalties are applied to roads based on elevation change and grade. These penalties help the path avoid hilly roads in favor of flatter roads or less steep grades where available. Note that it is not always possible to find alternate paths to avoid hills (for example when route locations are in mountainous areas). The default value is 0.5. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false . Motorcycle costing options -> BETA \u00b6 Standard costing for travel by motorcycle. By default, motorcycle costing will default to higher class roads. The costing model recognizes factors unique to motorcycle travel and offers options for tuning motorcycle routes. All of the options described above for autos also apply to motorcycle costing methods. The following options are available for motorcycle costing: Motorcycle options Description use_highways A riders's propensity to prefer the use of highways. This is a range of values from 0 to 1, where 0 attempts to avoid highways, and values toward 1 indicates the rider prefers highways. The default value is 1.0. use_trails A riders's desire for adventure in their routes. This is a range of values from 0 to 1, where 0 will avoid trails, tracks, unclassified or bad surfaces and values towards 1 will tend to avoid major roads and route on secondary roads. The default value is 0.0. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false . Pedestrian costing options \u00b6 These options are available for pedestrian costing methods. Pedestrian options Description walking_speed Walking speed in kilometers per hour. Must be between 0.5 and 25 km/hr. Defaults to 5.1 km/hr (3.1 miles/hour). walkway_factor A factor that modifies the cost when encountering roads classified as footway (no motorized vehicles allowed), which may be designated footpaths or designated sidewalks along residential roads. Pedestrian routes generally attempt to favor using these walkways and sidewalks . The default walkway_factor is 1.0. sidewalk_factor A factor that modifies the cost when encountering roads with dedicated sidewalks. Pedestrian routes generally attempt to favor using sidewalks . The default sidewalk_factor is 1.0. alley_factor A factor that modifies (multiplies) the cost when alleys are encountered. Pedestrian routes generally want to avoid alleys or narrow service roads between buildings. The default alley_factor is 2.0. driveway_factor A factor that modifies (multiplies) the cost when encountering a driveway , which is often a private, service road. Pedestrian routes generally want to avoid driveways (private). The default driveway factor is 5.0. step_penalty A penalty in seconds added to each transition onto a path with steps or stairs . Higher values apply larger cost penalties to avoid paths that contain flights of steps. use_ferry This value indicates the willingness to take ferries. This is range of values between 0 and 1. Values near 0 attempt to avoid ferries and values near 1 will favor ferries. The default value is 0.5. Note that sometimes ferries are required to complete a route so values of 0 are not guaranteed to avoid ferries entirely. use_living_streets This value indicates the willingness to take living streets. This is a range of values between 0 and 1. Values near 0 attempt to avoid living streets and values near 1 will favor living streets. The default value is 0.6. Note that sometimes living streets are required to complete a route so values of 0 are not guaranteed to avoid living streets entirely. use_tracks This value indicates the willingness to take track roads. This is a range of values between 0 and 1. Values near 0 attempt to avoid tracks and values near 1 will favor tracks a little bit. The default value is 0.5. Note that sometimes tracks are required to complete a route so values of 0 are not guaranteed to avoid tracks entirely. use_hills This is a range of values from 0 to 1, where 0 attempts to avoid hills and steep grades even if it means a longer (time and distance) path, while 1 indicates the pedestrian does not fear hills and steeper grades. Based on the use_hills factor, penalties are applied to roads based on elevation change and grade. These penalties help the path avoid hilly roads in favor of flatter roads or less steep grades where available. Note that it is not always possible to find alternate paths to avoid hills (for example when route locations are in mountainous areas). The default value is 0.5. use_lit This value is a range of values from 0 to 1, where 0 indicates indifference towards lit streets, and 1 indicates that unlit streets should be avoided. Note that even with values near 1, there is no guarantee the returned route will include lit segments. The default value is 0. service_penalty A penalty applied for transition to generic service road. The default penalty is 0. service_factor A factor that modifies (multiplies) the cost when generic service roads are encountered. The default service_factor is 1. max_hiking_difficulty This value indicates the maximum difficulty of hiking trails that is allowed. Values between 0 and 6 are allowed. The values correspond to sac_scale values within OpenStreetMap, see reference here . The default value is 1 which means that well cleared trails that are mostly flat or slightly sloped are allowed. Higher difficulty trails can be allowed by specifying a higher value for max_hiking_difficulty. bss_rent_cost This value is useful when bikeshare is chosen as travel mode. It is meant to give the time will be used to rent a bike from a bike share station. This value will be displayed in the final directions and used to calculate the whole duation. The default value is 120 seconds. bss_rent_penalty This value is useful when bikeshare is chosen as travel mode. It is meant to describe the potential effort to rent a bike from a bike share station. This value won't be displayed and used only inside of the algorithm. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false . Transit costing options \u00b6 These options are available for transit costing when the multimodal costing model is used. Transit options Description use_bus User's desire to use buses. Range of values from 0 (try to avoid buses) to 1 (strong preference for riding buses). use_rail User's desire to use rail/subway/metro. Range of values from 0 (try to avoid rail) to 1 (strong preference for riding rail). use_transfers User's desire to favor transfers. Range of values from 0 (try to avoid transfers) to 1 (totally comfortable with transfers). transit_start_end_max_distance A pedestrian option that can be added to the request to extend the defaults (2145 meters or approximately 1.5 miles). This is the maximum walking distance at the beginning or end of a route. transit_transfer_max_distance A pedestrian option that can be added to the request to extend the defaults (800 meters or 0.5 miles). This is the maximum walking distance between transfers. filters A way to filter for one or more stops , routes , or operators . Filters must contain a list of Onestop IDs , which is a unique identifier for Transitland data, and an action . ids : any number of Onestop IDs (such as o-9q9-bart) action : either exclude to exclude all of the ids listed in the filter or include to include only the ids listed in the filter Filter transit data \u00b6 When using filters , you need to include a Onestop ID to identify the stop, routes, or operators to include or exclude in your query. Depending on how you are interacting with transit data from Transitland, there are different ways of obtaining the Onestop ID. Turn-by-Turn API: Query a transit route query and parse the returned JSON maneuver for transit_info to find operator_onestop_id and the route onestop_id . A transit_stop contains the onestop_id for the stop. Mobility Explorer : Click a single route, stop, or operator on the map, or use the drop-down menu to find the Onestop ID for routes and operators. The Onestop ID, among other details, is listed in the sidebar. Transitland : Use the Transitland Datastore API to query directly for stops, routes, and operators using a number of options. For example, you can filter for only subway routes or bus routes . See the Transitland Datastore API documentation for details. Sample JSON payloads for multimodal requests with transit \u00b6 A multimodal request at the current date and time: { \"locations\" :[{ \"lat\" : 40.730930 , \"lon\" : -73.991379 , \"street\" : \"Wanamaker Place\" },{ \"lat\" : 40.749706 , \"lon\" : -73.991562 , \"street\" : \"Penn Plaza\" }], \"costing\" : \"multimodal\" , \"units\" : \"miles\" } A multimodal request departing on 2016-03-29 at 08:00: { \"locations\" :[{ \"lat\" : 40.749706 , \"lon\" : -73.991562 , \"type\" : \"break\" , \"street\" : \"Penn Plaza\" },{ \"lat\" : 40.73093 , \"lon\" : -73.991379 , \"type\" : \"break\" , \"street\" : \"Wanamaker Place\" }], \"costing\" : \"multimodal\" , \"date_time\" :{ \"type\" : 1 , \"value\" : \"2016-03-29T08:00\" }} A multimodal request for a route favoring buses and a person walking at a set speed of 4.1 km/h: { \"locations\" :[{ \"lat\" : 40.749706 , \"lon\" : -73.991562 , \"type\" : \"break\" , \"street\" : \"Penn Plaza\" },{ \"lat\" : 40.73093 , \"lon\" : -73.991379 , \"type\" : \"break\" , \"street\" : \"Wanamaker Place\" }], \"costing\" : \"multimodal\" , \"costing_options\" :{ \"transit\" :{ \"use_bus\" : \"1.0\" , \"use_rail\" : \"0.0\" , \"use_transfers\" : \"0.3\" }, \"pedestrian\" :{ \"walking_speed\" : \"4.1\" }}} A multimodal request with a filter for certain Onestop IDs: { \"locations\" :[{ \"lat\" : 40.730930 , \"lon\" : -73.991379 , \"street\" : \"Wanamaker Place\" },{ \"lat\" : 40.749706 , \"lon\" : -73.991562 , \"street\" : \"Penn Plaza\" }], \"costing\" : \"multimodal\" , \"costing_options\" :{ \"transit\" :{ \"filters\" :{ \"stops\" :{ \"ids\" :[ \"s-dr5rsq8pqg-8st~nyu&#60;r21n\" , \"s-dr5rsr9wyg-14st&#126;unionsq&#60;r20n\" ], \"action\" : \"exclude\" }, \"routes\" :{ \"ids\" :[ \"r-dr5r-r\" ], \"action\" : \"exclude\" }, \"operators\" :{ \"ids\" :[ \"o-dr5r-path\" ], \"action\" : \"include\" }}}}, \"units\" : \"miles\" } Directions options \u00b6 Directions options should be specified at the top level of the JSON object. Options Description units Distance units for output. Allowable unit types are miles (or mi) and kilometers (or km). If no unit type is specified, the units default to kilometers. language The language of the narration instructions based on the IETF BCP 47 language tag string. If no language is specified or the specified language is unsupported, United States-based English (en-US) is used. Currently supported language list directions_type An enum with 3 values. none indicating no maneuvers or instructions should be returned. maneuvers indicating that only maneuvers be returned. instructions indicating that maneuvers with instructions should be returned (this is the default if not specified). alternates A number denoting how many alternate routes should be provided. There may be no alternates or less alternates than the user specifies. Alternates are not yet supported on multipoint routes (that is, routes with more than 2 locations). They are also not supported on time dependent routes. Supported language tags \u00b6 Language tag Language alias Description bg-BG bg Bulgarian (Bulgaria) ca-ES ca Catalan (Spain) cs-CZ cs Czech (Czech Republic) da-DK da Danish (Denmark) de-DE de German (Germany) el-GR el Greek (Greece) en-GB English (United Kingdom) en-US-x-pirate en-x-pirate English (United States) Pirate en-US en English (United States) es-ES es Spanish (Spain) et-EE et Estonian (Estonia) fi-FI fi Finnish (Finland) fr-FR fr French (France) hi-IN hi Hindi (India) hu-HU hu Hungarian (Hungary) it-IT it Italian (Italy) ja-JP ja Japanese (Japan) nb-NO nb Bokmal (Norway) nl-NL nl Dutch (Netherlands) pl-PL pl Polish (Poland) pt-BR Portuguese (Brazil) pt-PT pt Portuguese (Portugal) ro-RO ro Romanian (Romania) ru-RU ru Russian (Russia) sk-SK sk Slovak (Slovakia) sl-SI sl Slovenian (Slovenia) sv-SE sv Swedish (Sweden) tr-TR tr Turkish (Turkey) uk-UA uk Ukrainian (Ukraine) Other request options \u00b6 Options Description exclude_locations A set of locations to exclude or avoid within a route can be specified using a JSON array of avoid_locations. The avoid_locations have the same format as the locations list. At a minimum each avoid location must include latitude and longitude. The avoid_locations are mapped to the closest road or roads and these roads are excluded from the route path computation. exclude_polygons One or multiple exterior rings of polygons in the form of nested JSON arrays, e.g. [[[lon1, lat1], [lon2,lat2]],[[lon1,lat1],[lon2,lat2]]] . Roads intersecting these rings will be avoided during path finding. If you only need to avoid a few specific roads, it's much more efficient to use exclude_locations . Valhalla will close open rings (i.e. copy the first coordingate to the last position). date_time This is the local date and time at the location. type 0 - Current departure time. 1 - Specified departure time 2 - Specified arrival time. Not yet implemented for multimodal costing method. 3 - Invariant specified time. Time does not vary over the course of the path. Not implemented for multimodal or bike share routing value - the date and time is specified in ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. For example \"2016-07-03T08:06\" out_format Output format. If no out_format is specified, JSON is returned. Future work includes PBF (protocol buffer) support. id Name your route request. If id is specified, the naming will be sent thru to the response. linear_references When present and true , the successful route response will include a key linear_references . Its value is an array of base64-encoded OpenLR location references , one for each graph edge of the road network matched by the input trace. prioritize_bidirectional Prioritize bidirectional a* when date_time.type = depart_at/current . By default time_dependent_forward a* is used in these cases, but bidirectional a* is much faster. Currently it does not update the time (and speeds) when searching for the route path, but the ETA on that route is recalculated based on the time-dependent speeds Outputs of a route \u00b6 If a route has been named in the request using the optional &id= input, then the name will be returned as a string id on the JSON object. The route results are returned as a trip . This is a JSON object that contains details about the trip, including locations, a summary with basic information about the entire trip, and a list of legs . Basic trip information includes: Trip item Description status Status code. status_message Status message. units The specified units of length are returned, either kilometers or miles. language The language of the narration instructions. If the user specified a language in the directions options and the specified language was supported - this returned value will be equal to the specified value. Otherwise, this value will be the default (en-US) language. locations Location information is returned in the same form as it is entered with additional fields to indicate the side of the street. warnings (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc. The summary JSON object includes: Summary item Description time Estimated elapsed time to complete the trip. length Distance traveled for the entire trip. Units are either miles or kilometers based on the input units specified. has_toll Flag indicating if the the path uses one or more toll segments. has_highway Flag indicating if the the path uses one or more highway segments. has_ferry Flag indicating if the the path uses one or more ferry segments. min_lat Minimum latitude of a bounding box containing the route. min_lon Minimum longitude of a bounding box containing the route. max_lat Maximum latitude of a bounding box containing the route. max_lon Maximum longitude of a bounding box containing the route. Trip legs and maneuvers \u00b6 A trip contains one or more legs . For n number of break locations, there are n-1 legs. Through locations do not create separate legs. Each leg of the trip includes a summary, which is comprised of the same information as a trip summary but applied to the single leg of the trip. It also includes a shape , which is an encoded polyline of the route path (with 6 digits decimal precision), and a list of maneuvers as a JSON array. For more about decoding route shapes, see these code examples . Each maneuver includes: Maneuver item Description type Type of maneuver. See below for a list. instruction Written maneuver instruction. Describes the maneuver, such as \"Turn right onto Main Street\". verbal_transition_alert_instruction Text suitable for use as a verbal alert in a navigation application. The transition alert instruction will prepare the user for the forthcoming transition. For example: \"Turn right onto North Prince Street\". verbal_pre_transition_instruction Text suitable for use as a verbal message immediately prior to the maneuver transition. For example \"Turn right onto North Prince Street, U.S. 2 22\". verbal_post_transition_instruction Text suitable for use as a verbal message immediately after the maneuver transition. For example \"Continue on U.S. 2 22 for 3.9 miles\". street_names List of street names that are consistent along the entire nonobvious maneuver. begin_street_names When present, these are the street names at the beginning (transition point) of the nonobvious maneuver (if they are different than the names that are consistent along the entire nonobvious maneuver). time Estimated time along the maneuver in seconds. length Maneuver length in the units specified. begin_shape_index Index into the list of shape points for the start of the maneuver. end_shape_index Index into the list of shape points for the end of the maneuver. toll True if the maneuver has any toll, or portions of the maneuver are subject to a toll. highway True if a highway is encountered on this maneuver. rough True if the maneuver is unpaved or rough pavement, or has any portions that have rough pavement. gate True if a gate is encountered on this maneuver. ferry True if a ferry is encountered on this maneuver. sign Contains the interchange guide information at a road junction associated with this maneuver. See below for details. roundabout_exit_count The spoke to exit roundabout after entering. depart_instruction Written depart time instruction. Typically used with a transit maneuver, such as \"Depart: 8:04 AM from 8 St - NYU\". verbal_depart_instruction Text suitable for use as a verbal depart time instruction. Typically used with a transit maneuver, such as \"Depart at 8:04 AM from 8 St - NYU\". arrive_instruction Written arrive time instruction. Typically used with a transit maneuver, such as \"Arrive: 8:10 AM at 34 St - Herald Sq\". verbal_arrive_instruction Text suitable for use as a verbal arrive time instruction. Typically used with a transit maneuver, such as \"Arrive at 8:10 AM at 34 St - Herald Sq\". transit_info Contains the attributes that describe a specific transit route. See below for details. verbal_multi_cue True if the verbal_pre_transition_instruction has been appended with the verbal instruction of the next maneuver. travel_mode Travel mode. \"drive\" \"pedestrian\" \"bicycle\" \"transit\" travel_type Travel type for drive. \"car\" Travel type for pedestrian. \"foot\" Travel type for bicycle. \"road\" Travel type for transit. Tram or light rail = \"tram\" Metro or subway = \"metro\" Rail = \"rail\" Bus = \"bus\" Ferry = \"ferry\" Cable car = \"cable_car\" Gondola = \"gondola\" Funicular = \"funicular\" bss_maneuver_type Used when travel_mode is bikeshare . Describes bike share maneuver. The default value is \"NoneAction \"NoneAction\" \"RentBikeAtBikeShare\" \"ReturnBikeAtBikeShare\" For the maneuver type , the following are available: kNo ne = 0 ; kS tart = 1 ; kS tart Righ t = 2 ; kS tart Le ft = 3 ; kDes t i nat io n = 4 ; kDes t i nat io n Righ t = 5 ; kDes t i nat io n Le ft = 6 ; kBecomes = 7 ; kCo nt i nue = 8 ; kSligh t Righ t = 9 ; kRigh t = 10 ; kSharpRigh t = 11 ; kU turn Righ t = 12 ; kU turn Le ft = 13 ; kSharpLe ft = 14 ; kLe ft = 15 ; kSligh t Le ft = 16 ; kRampS tra igh t = 17 ; kRampRigh t = 18 ; kRampLe ft = 19 ; kExi t Righ t = 20 ; kExi t Le ft = 21 ; kS ta yS tra igh t = 22 ; kS ta yRigh t = 23 ; kS ta yLe ft = 24 ; kMerge = 25 ; kRou n dabou t E nter = 26 ; kRou n dabou t Exi t = 27 ; kFerryE nter = 28 ; kFerryExi t = 29 ; kTra ns i t = 30 ; kTra ns i t Tra nsfer = 31 ; kTra ns i t Remai n O n = 32 ; kTra ns i t Co nne c t io n S tart = 33 ; kTra ns i t Co nne c t io n Tra nsfer = 34 ; kTra ns i t Co nne c t io n Des t i nat io n = 35 ; kPos t Tra ns i t Co nne c t io n Des t i nat io n = 36 ; kMergeRigh t = 37 ; kMergeLe ft = 38 ; The maneuver sign may contain four lists of interchange sign elements as follows: exit_number_elements = list of exit number elements. If an exit number element exists, it is typically just one value. exit_branch_elements = list of exit branch elements. The exit branch element text is the subsequent road name or route number after the sign. exit_toward_elements = list of exit toward elements. The exit toward element text is the location where the road ahead goes - the location is typically a control city, but may also be a future road name or route number. exit_name_elements = list of exit name elements. The exit name element is the interchange identifier - typically not used in the US. Each maneuver sign element includes: Maneuver sign element item Description text Interchange sign text. exit number example: 91B. exit branch example: I 95 North. exit toward example: New York. exit name example: Gettysburg Pike. consecutive_count The frequency of this sign element within a set a consecutive signs. This item is optional. A maneuver transit_info includes: Maneuver transit route item Description onestop_id Global transit route identifier from Transitland. short_name Short name describing the transit route. For example \"N\". long_name Long name describing the transit route. For example \"Broadway Express\". headsign The sign on a public transport vehicle that identifies the route destination to passengers. For example \"ASTORIA - DITMARS BLVD\". color The numeric color value associated with a transit route. The value for yellow would be \"16567306\". text_color The numeric text color value associated with a transit route. The value for black would be \"0\". description The description of the the transit route. For example \"Trains operate from Ditmars Boulevard, Queens, to Stillwell Avenue, Brooklyn, at all times. N trains in Manhattan operate along Broadway and across the Manhattan Bridge to and from Brooklyn. Trains in Brooklyn operate along 4 th Avenue, then through Borough Park to Gravesend. Trains typically operate local in Queens, and either express or local in Manhattan and Brooklyn, depending on the time. Late night trains operate via Whitehall Street, Manhattan. Late night service is local\". operator_onestop_id Global operator/agency identifier from Transitland. operator_name Operator/agency name. For example, \"BART\", \"King County Marine Division\", and so on. Short name is used over long name. operator_url Operator/agency URL. For example, \"http://web.mta.info/\". transit_stops A list of the stops/stations associated with a specific transit route. See below for details. A transit_stop includes: Transit stop item Description type Type of stop (simple stop=0; station=1). onestop_id Global transit stop identifier from Transitland. name Name of the stop or station. For example \"14 St - Union Sq\". arrival_date_time Arrival date and time using the ISO 8601 format (YYYY-MM-DDThh:mm). For example, \"2015-12-29T08:06\". departure_date_time Departure date and time using the ISO 8601 format (YYYY-MM-DDThh:mm). For example, \"2015-12-29T08:06\". is_parent_stop True if this stop is a marked as a parent stop. assumed_schedule True if the times are based on an assumed schedule because the actual schedule is not known. lat Latitude of the transit stop in degrees. lon Longitude of the transit stop in degrees. Continuing with the earlier routing example from the Detroit, Michigan area, a maneuver such as this one may be returned with that request: {\"begin_shape_index\":0,\"length\":0.109,\"end_shape_index\":1,\"instruction\":\"Go south on Appleton.\",\"street_names\":[\"Appleton\"],\"type\":1,\"time\":0} In the future, look for additional maneuver information to enhance navigation applications, including landmark usage. HTTP status codes and conditions \u00b6 The following is a table of HTTP status error code conditions that may occur for a particular request. In general, the service follows the HTTP specification . That is to say that 5xx returns are generally ephemeral server problems that should be resolved shortly or are the result of a bug. 4xx returns are used to mark requests that cannot be carried out, generally due to bad input in the request or problems with the underlying data. A 2xx return is expected when there is a successful route result or trip , as described above. Status Code Status Description 200 your_trip_json A happy bit of json describing your trip result 400 Failed to parse json request You need a valid json request 400 Failed to parse location You need a valid location object in your json request 400 Failed to parse correlated location There was a problem with the location once correlated to the route network 400 Insufficiently specified required parameter 'locations' You forgot the locations parameter 400 No edge/node costing provided You forgot the costing parameter 400 Insufficient number of locations provided You didn't provide enough locations 400 Exceeded max route locations of X You are asking for too many locations 400 Locations are in unconnected regions. Go check/edit the map at osm.org You are routing between regions of no connectivity 400 No costing method found for 'X' You are asking for a non-existent costing mode 400 Path distance exceeds the max distance limit You want to travel further than this mode allows 400 No suitable edges near location There were no edges applicable to your mode of travel near the input location 400 No data found for location There was no route data tile at the input location 400 No path could be found for input There was no path found between the input locations 404 Try any of: '/route' '/locate' You asked for an invalid path 405 Try a POST or GET request instead We only support GET and POST requests 500 Failed to parse intermediate request format Had a problem reading an intermediate request format 500 Failed to parse TripPath Had a problem reading the computed path from Protobuf 500 Could not build directions for TripPath Had a problem using the trip path to create TripDirections 500 Failed to parse TripDirections Had a problem using the trip directions to serialize a json response 501 Not implemented Not Implemented Internal error codes and conditions \u00b6 The following is a table of exception internal error code conditions that may occur for a particular request. An error code utility header file can be included by any of the Valhalla service projects. The codes correspond to code returned from a particular Valhalla project . Error code Error 1xx Loki project codes 100 Failed to parse json request 101 Try a POST or GET request instead 102 The config actions for Loki are incorrectly loaded 103 Missing max_locations configuration 104 Missing max_distance configuration 105 Path action not supported 106 Try any of 107 Not Implemented 110 Insufficiently specified required parameter 'locations' 111 Insufficiently specified required parameter 'time' 112 Insufficiently specified required parameter 'locations' or 'sources & targets' 113 Insufficiently specified required parameter 'contours' 114 Insufficiently specified required parameter 'shape' or 'encoded_polyline' 120 Insufficient number of locations provided 121 Insufficient number of sources provided 122 Insufficient number of targets provided 123 Insufficient shape provided 124 No edge/node costing provided 125 No costing method found 126 No shape provided 130 Failed to parse location 131 Failed to parse source 132 Failed to parse target 140 Action does not support multimodal costing 141 Arrive by for multimodal not implemented yet 142 Arrive by not implemented for isochrones 143 ignore_closure in costing and exclude_closure in search_filter cannot both be specified 150 Exceeded max locations 151 Exceeded max time 152 Exceeded max contours 153 Too many shape points 154 Path distance exceeds the max distance limit 155 Outside the valid walking distance at the beginning or end of a multimodal route 156 Outside the valid walking distance between stops of a multimodal route 157 Exceeded max avoid locations 158 Input trace option is out of bounds 160 Date and time required for origin for date_type of depart at 161 Date and time required for destination for date_type of arrive by 162 Date and time is invalid. Format is YYYY-MM-DDTHH:MM 163 Invalid date_type 170 Locations are in unconnected regions. Go check/edit the map at osm.org 171 No suitable edges near location 199 Unknown 2xx Odin project codes 200 Failed to parse intermediate request format 201 Failed to parse TripPath 210 Trip path does not have any nodes 211 Trip path has only one node 212 Trip must have at least 2 locations 213 Error - No shape or invalid node count 220 Turn degree out of range for cardinal direction 230 Invalid TripDirections_Maneuver_Type in method FormTurnInstruction 231 Invalid TripDirections_Maneuver_Type in method FormRelativeTwoDirection 232 Invalid TripDirections_Maneuver_Type in method FormRelativeThreeDirection 299 Unknown 3xx Skadi project codes 300 Failed to parse json request 301 Try a POST or GET request instead 302 The config actions for Skadi are incorrectly loaded 303 Path action not supported 304 Try any of 305 Not Implemented 310 No shape provided 311 Insufficient shape provided 312 Insufficiently specified required parameter 'shape' or 'encoded_polyline' 313 'resample_distance' must be >= 314 Too many shape points 399 Unknown 4xx Thor project codes 400 Unknown action 401 Failed to parse intermediate request format 410 Insufficiently specified required parameter 'locations' 411 Insufficiently specified required parameter 'shape' 412 No costing method found 420 Failed to parse correlated location 421 Failed to parse location 422 Failed to parse source 423 Failed to parse target 424 Failed to parse shape 430 Exceeded max iterations in CostMatrix::SourceToTarget 440 Cannot reach destination - too far from a transit stop 441 Location is unreachable 442 No path could be found for input 443 Exact route match algorithm failed to find path 444 Map Match algorithm failed to find path 445 Shape match algorithm specification in api request is incorrect. Please see documentation for valid shape_match input. 499 Unknown 5xx Tyr project codes 500 Failed to parse intermediate request format 501 Failed to parse TripDirections 599 Unknown","title":"API Reference"},{"location":"api/turn-by-turn/api-reference/#valhalla-routing-service-api-reference","text":"Valhalla's routing service (a.k.a. turn-by-turn), is an open-source routing service that lets you integrate routing and navigation into a web or mobile application. View an interactive demo The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page .","title":"Valhalla routing service API reference"},{"location":"api/turn-by-turn/api-reference/#inputs-of-a-route","text":"The route request run locally takes the form of localhost:8002/route?json={} , where the JSON inputs inside the {} include location information, name and options for the costing model, and output options. Here is the JSON payload for an example request: { \"locations\" :[{ \"lat\" : 42.358528 , \"lon\" : -83.271400 , \"street\" : \"Appleton\" },{ \"lat\" : 42.996613 , \"lon\" : -78.749855 , \"street\" : \"Ranch Trail\" }], \"costing\" : \"auto\" , \"costing_options\" :{ \"auto\" :{ \"country_crossing_penalty\" : 2000.0 }}, \"units\" : \"miles\" , \"id\" : \"my_work_route\" } This request provides automobile routing between the Detroit, Michigan area and Buffalo, New York, with an optional street name parameter to improve navigation at the start and end points. It attempts to avoid routing north through Canada by adding a penalty for crossing international borders. The resulting route is displayed in miles. There is an option to name your route request. You can do this by appending the following to your request &id= . The id is returned with the response so a user could match to the corresponding request.","title":"Inputs of a route"},{"location":"api/turn-by-turn/api-reference/#locations","text":"You specify locations as an ordered list of two or more locations within a JSON array. Locations are visited in the order specified. A location must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. Note that the Valhalla cannot search for names or addresses or perform geocoding or reverse geocoding. External search services, such as Mapbox Geocoding , can be used to find places and geocode addresses, which must be converted to coordinates for input. To build a route, you need to specify two break locations. In addition, you can include through , via or break_through locations to influence the route path. Location parameters Description lat Latitude of the location in degrees. This is assumed to be both the routing location and the display location if no display_lat and display_lon are provided. lon Longitude of the location in degrees. This is assumed to be both the routing location and the display location if no display_lat and display_lon are provided. type Type of location, either break , through , via or break_through . Each type controls two characteristics: whether or not to allow a u-turn at the location and whether or not to generate guidance/legs at the location. A break is a location at which we allows u-turns and generate legs and arrival/departure maneuvers. A through location is a location at which we neither allow u-turns nor generate legs or arrival/departure maneuvers. A via location is a location at which we allow u-turns but do not generate legs or arrival/departure maneuvers. A break_through location is a location at which we do not allow u-turns but do generate legs and arrival/departure maneuvers. If no type is provided, the type is assumed to be a break . The types of the first and last locations are ignored and are treated as break s. heading (optional) Preferred direction of travel for the start from the location. This can be useful for mobile routing where a vehicle is traveling in a specific direction along a road, and the route should start in that direction. The heading is indicated in degrees from north in a clockwise direction, where north is 0\u00b0, east is 90\u00b0, south is 180\u00b0, and west is 270\u00b0. heading_tolerance (optional) How close in degrees a given street's angle must be in order for it to be considered as in the same direction of the heading parameter. The default value is 60 degrees. street (optional) Street name. The street name may be used to assist finding the correct routing location at the specified latitude, longitude. This is not currently implemented. way_id (optional) OpenStreetMap identification number for a polyline way . The way ID may be used to assist finding the correct routing location at the specified latitude, longitude. This is not currently implemented. minimum_reachability Minimum number of nodes (intersections) reachable for a given edge (road between intersections) to consider that edge as belonging to a connected region. When correlating this location to the route network, try to find candidates who are reachable from this many or more nodes (intersections). If a given candidate edge reaches less than this number of nodes its considered to be a disconnected island and we'll search for more candidates until we find at least one that isn't considered a disconnected island. If this value is larger than the configured service limit it will be clamped to that limit. The default is a minimum of 50 reachable nodes. radius The number of meters about this input location within which edges (roads between intersections) will be considered as candidates for said location. When correlating this location to the route network, try to only return results within this distance (meters) from this location. If there are no candidates within this distance it will return the closest candidate within reason. If this value is larger than the configured service limit it will be clamped to that limit. The default is 0 meters. rank_candidates Whether or not to rank the edge candidates for this location. The ranking is used as a penalty within the routing algorithm so that some edges will be penalized more heavily than others. If true candidates will be ranked according to their distance from the input and various other attributes. If false the candidates will all be treated as equal which should lead to routes that are just the most optimal path with emphasis about which edges were selected. preferred_side If the location is not offset from the road centerline or is closest to an intersection this option has no effect. Otherwise the determined side of street is used to determine whether or not the location should be visited from the same , opposite or either side of the road with respect to the side of the road the given locale drives on. In Germany (driving on the right side of the road), passing a value of same will only allow you to leave from or arrive at a location such that the location will be on your right. In Australia (driving on the left side of the road), passing a value of same will force the location to be on your left. A value of opposite will enforce arriving/departing from a location on the opposite side of the road from that which you would be driving on while a value of either will make no attempt limit the side of street that is available for the route. display_lat Latitude of the map location in degrees. If provided the lat and lon parameters will be treated as the routing location and the display_lat and display_lon will be used to determine the side of street. Both display_lat and display_lon must be provided and valid to achieve the desired effect. display_lon Longitude of the map location in degrees. If provided the lat and lon parameters will be treated as the routing location and the display_lat and display_lon will be used to determine the side of street. Both display_lat and display_lon must be provided and valid to achieve the desired effect. search_cutoff The cutoff at which we will assume the input is too far away from civilisation to be worth correlating to the nearest graph elements node_snap_tolerance During edge correlation this is the tolerance used to determine whether or not to snap to the intersection rather than along the street, if the snap location is within this distance from the intersection the intersection is used instead. The default is 5 meters street_side_tolerance If your input coordinate is less than this tolerance away from the edge centerline then we set your side of street to none otherwise your side of street will be left or right depending on direction of travel street_side_max_distance The max distance in meters that the input coordinates or display ll can be from the edge centerline for them to be used for determining the side of street. Beyond this distance the side of street is set to none search_filter A set of optional filters to exclude candidate edges based on their attribution. The following exclusion filters are supported: exclude_tunnel (boolean, defaults to false ): whether to exclude roads marked as tunnels exclude_bridge (boolean, defaults to false ): whether to exclude roads marked as bridges exclude_ramp (boolean, defaults to false ): whether to exclude link roads marked as ramps, note that some turn channels are also marked as ramps exclude_closures (boolean, defaults to true ): whether to exclude roads considered closed due to live traffic closure. Note: This option cannot be set if costing_options.<costing>.ignore_closures is also specified. An error is returned if both options are specified. Note 2: Ignoring closures at destination and source locations does NOT work for date_time type 0/1 & 2 respectively min_road_class (string, defaults to \"service_other\" ): lowest road class allowed max_road_class (string, defaults to \"motorway\" ): highest road class allowed Road classes from highest to lowest are: motorway, trunk, primary, secondary, tertiary, unclassified, residential, service_other. Optionally, you can include the following location information without impacting the routing. This information is carried through the request and returned as a convenience. name = Location or business name. The name may be used in the route narration directions, such as \"You have arrived at <business name> .\") city = City name. state = State name. postal_code = Postal code. country = Country name. phone = Telephone number. url = URL for the place or location. waiting : The waiting time in seconds at this location. E.g. when the route describes a pizza delivery tour, each location has a service time, which can be respected by setting waiting on the location, then the departure will be delayed by this amount in seconds. Only works for break or break_through types. side_of_street = (response only) The side of street of a break location that is determined based on the actual route when the location is offset from the street. The possible values are left and right . date_time = (response only for /route ) Expected date/time for the user to be at the location using the ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. For example \"2015-12-29T08:00\". If waiting was set on this location in the request, and it's an intermediate location, the date_time will describe the departure time at this location. Future development work includes adding location options and information related to time at each location. This will allow routes to specify a start time or an arrive by time at each location. There is also ongoing work to improve support for through locations.","title":"Locations"},{"location":"api/turn-by-turn/api-reference/#costing-models","text":"Valhalla's routing service uses dynamic, run-time costing to generate the route path. The route request must include the name of the costing model and can include optional parameters available for the chosen costing model. Costing model Description auto Standard costing for driving routes by car, motorcycle, truck, and so on that obeys automobile driving rules, such as access and turn restrictions. Auto provides a short time path (though not guaranteed to be shortest time) and uses intersection costing to minimize turns and maneuvers or road name changes. Routes also tend to favor highways and higher classification roads, such as motorways and trunks. bicycle Standard costing for travel by bicycle, with a slight preference for using cycleways or roads with bicycle lanes. Bicycle routes follow regular roads when needed, but avoid roads without bicycle access. bus Standard costing for bus routes. Bus costing inherits the auto costing behaviors, but checks for bus access on the roads. BETA bikeshare A combination of pedestrian and bicycle. Use bike share station( amenity:bicycle_rental ) to change the travel mode truck Standard costing for trucks. Truck costing inherits the auto costing behaviors, but checks for truck access, width and height restrictions, and weight limits on the roads. hov DEPRECATED: use auto cost with HOV costing options. taxi Standard costing for taxi routes. Taxi costing inherits the auto costing behaviors, but checks for taxi lane access on the roads and favors those roads. motor_scooter Standard costing for travel by motor scooter or moped. By default, motor_scooter costing will avoid higher class roads unless the country overrides allows motor scooters on these roads. Motor scooter routes follow regular roads when needed, but avoid roads without motor_scooter, moped, or mofa access. BETA motorcycle Standard costing for travel by motorcycle. This costing model provides options to tune the route to take roadways (road touring) vs. tracks and trails (adventure motorcycling). multimodal Currently supports pedestrian and transit. In the future, multimodal will support a combination of all of the above. pedestrian Standard walking route that excludes roads without pedestrian access. In general, pedestrian routes are shortest distance with the following exceptions: walkways and footpaths are slightly favored, while steps or stairs and alleys are slightly avoided.","title":"Costing models"},{"location":"api/turn-by-turn/api-reference/#costing-options","text":"Costing methods can have several options that can be adjusted to develop the route path, as well as for estimating time along the path. Specify costing model options in your request using the format of costing_options.type , such as costing_options.auto . Cost options are fixed costs in seconds that are added to both the path cost and the estimated time. Examples of costs are gate_costs and toll_booth_costs , where a fixed amount of time is added. Costs are not generally used to influence the route path; instead, use penalties to do this. Costs must be in the range of 0.0 seconds to 43200.0 seconds (12 hours), otherwise a default value will be assigned. Penalty options are fixed costs in seconds that are only added to the path cost. Penalties can influence the route path determination but do not add to the estimated time along the path. For example, add a toll_booth_penalty to create route paths that tend to avoid toll booths. Penalties must be in the range of 0.0 seconds to 43200.0 seconds (12 hours), otherwise a default value will be assigned. Factor options are used to multiply the cost along an edge or road section in a way that influences the path to favor or avoid a particular attribute. Factor options do not impact estimated time along the path, though. Factors must be in the range 0.1 to 100000.0, where factors of 1.0 have no influence on cost. Anything outside of this range will be assigned a default value. Use a factor less than 1.0 to attempt to favor paths containing preferred attributes, and a value greater than 1.0 to avoid paths with undesirable attributes. Avoidance factors are more effective than favor factors at influencing a path. A factor's impact also depends on the length of road containing the specified attribute, as longer roads have more impact on the costing than very short roads. For this reason, penalty options tend to be better at influencing paths. A special costing option is shortest , which, when true , will solely use distance as cost and disregard all other costs, penalties and factors. It's available for all costing models except multimodal & bikeshare .","title":"Costing options"},{"location":"api/turn-by-turn/api-reference/#automobile-and-bus-costing-options","text":"These options are available for auto , bus , and truck costing methods. Automobile options Description maneuver_penalty A penalty applied when transitioning between roads that do not have consistent naming\u2013in other words, no road names in common. This penalty can be used to create simpler routes that tend to have fewer maneuvers or narrative guidance instructions. The default maneuver penalty is five seconds. gate_cost A cost applied when a gate with undefined or private access is encountered. This cost is added to the estimated time / elapsed time. The default gate cost is 30 seconds. gate_penalty A penalty applied when a gate with no access information is on the road. The default gate penalty is 300 seconds. private_access_penalty A penalty applied when a gate or bollard with access=private is encountered. The default private access penalty is 450 seconds. toll_booth_cost A cost applied when a toll booth is encountered. This cost is added to the estimated and elapsed times. The default cost is 15 seconds. toll_booth_penalty A penalty applied to the cost when a toll booth is encountered. This penalty can be used to create paths that avoid toll roads. The default toll booth penalty is 0. ferry_cost A cost applied when entering a ferry. This cost is added to the estimated and elapsed times. The default cost is 300 seconds (5 minutes). use_ferry This value indicates the willingness to take ferries. This is a range of values between 0 and 1. Values near 0 attempt to avoid ferries and values near 1 will favor ferries. The default value is 0.5. Note that sometimes ferries are required to complete a route so values of 0 are not guaranteed to avoid ferries entirely. use_highways This value indicates the willingness to take highways. This is a range of values between 0 and 1. Values near 0 attempt to avoid highways and values near 1 will favor highways. The default value is 1.0. Note that sometimes highways are required to complete a route so values of 0 are not guaranteed to avoid highways entirely. use_tolls This value indicates the willingness to take roads with tolls. This is a range of values between 0 and 1. Values near 0 attempt to avoid tolls and values near 1 will not attempt to avoid them. The default value is 0.5. Note that sometimes roads with tolls are required to complete a route so values of 0 are not guaranteed to avoid them entirely. use_living_streets This value indicates the willingness to take living streets. This is a range of values between 0 and 1. Values near 0 attempt to avoid living streets and values near 1 will favor living streets. The default value is 0 for trucks, 0.1 for cars, buses, motor scooters and motorcycles. Note that sometimes living streets are required to complete a route so values of 0 are not guaranteed to avoid living streets entirely. use_tracks This value indicates the willingness to take track roads. This is a range of values between 0 and 1. Values near 0 attempt to avoid tracks and values near 1 will favor tracks a little bit. The default value is 0 for autos, 0.5 for motor scooters and motorcycles. Note that sometimes tracks are required to complete a route so values of 0 are not guaranteed to avoid tracks entirely. service_penalty A penalty applied for transition to generic service road. The default penalty is 0 trucks and 15 for cars, buses, motor scooters and motorcycles. service_factor A factor that modifies (multiplies) the cost when generic service roads are encountered. The default service_factor is 1. country_crossing_cost A cost applied when encountering an international border. This cost is added to the estimated and elapsed times. The default cost is 600 seconds. country_crossing_penalty A penalty applied for a country crossing. This penalty can be used to create paths that avoid spanning country boundaries. The default penalty is 0. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false . top_speed Top speed the vehicle can go. Also used to avoid roads with higher speeds than this value. top_speed must be between 10 and 252 KPH. The default value is 140 KPH. fixed_speed Fixed speed the vehicle can go. Used to override the calculated speed. Can be useful if speed of vehicle is known. fixed_speed must be between 1 and 252 KPH. The default value is 0 KPH which disables fixed speed and falls back to the standard calculated speed based on the road attribution. ignore_closures If set to true , ignores all closures, marked due to live traffic closures, during routing. Note: This option cannot be set if location.search_filter.exclude_closures is also specified in the request and will return an error if it is closure_factor A factor that penalizes the cost when traversing a closed edge (eg: if search_filter.exclude_closures is false for origin and/or destination location and the route starts/ends on closed edges). Its value can range from 1.0 - don't penalize closed edges, to 10.0 - apply high cost penalty to closed edges. Default value is 9.0 . Note: This factor is applicable only for motorized modes of transport, i.e auto , motorcycle , motor_scooter , bus , truck & taxi .","title":"Automobile and bus costing options"},{"location":"api/turn-by-turn/api-reference/#other-costing-options","text":"The following options are available for auto , bus , taxi , and truck costing methods. Vehicle Options Description height The height of the vehicle (in meters). Default 1.9 for car, bus, taxi and 4.11 for truck. width The width of the vehicle (in meters). Default 1.6 for car, bus, taxi and 2.6 for truck. exclude_unpaved This value indicates whether or not the path may include unpaved roads. If exclude_unpaved is set to 1 it is allowed to start and end with unpaved roads, but is not allowed to have them in the middle of the route path, otherwise they are allowed. Default false. exclude_cash_only_tolls A boolean value which indicates the desire to avoid routes with cash-only tolls. Default false. include_hov2 A boolean value which indicates the desire to include HOV roads with a 2-occupant requirement in the route when advantageous. Default false. include_hov3 A boolean value which indicates the desire to include HOV roads with a 3-occupant requirement in the route when advantageous. Default false. include_hot A boolean value which indicates the desire to include tolled HOV roads which require the driver to pay a toll if the occupant requirement isn't met. Default false. The following options are available for truck costing. Truck options Description length The length of the truck (in meters). Default 21.64. weight The weight of the truck (in metric tons). Default 21.77. axle_load The axle load of the truck (in metric tons). Default 9.07. axle_count The axle count of the truck. Default 5. hazmat A value indicating if the truck is carrying hazardous materials. Default false.","title":"Other costing options"},{"location":"api/turn-by-turn/api-reference/#bicycle-costing-options","text":"The default bicycle costing is tuned toward road bicycles with a slight preference for using cycleways or roads with bicycle lanes. Bicycle routes use regular roads where needed or where no direct bicycle lane options exist, but avoid roads without bicycle access. The costing model recognizes several factors unique to bicycle travel and offers several options for tuning bicycle routes. Several factors unique to travel by bicycle influence the resulting route. The types of roads suitable for bicycling depend on the type of bicycle. Road bicycles (skinny or narrow tires) generally are suited to paved roads or perhaps very short sections of compacted gravel. They are not designed for riding on coarse gravel or most paths and tracks through wooded areas or farmland. Mountain bikes, on the other hand, are able to traverse a wider set of surfaces. Average travel speed can be highly variable and can depend on bicycle type, fitness and experience of the cyclist, road surface, and hills. The costing model assumes a default speed on smooth, flat roads for each supported bicycle type. This speed can be overridden by an input option. The base speed is modulated by surface type (in conjunction with the bicycle type). In addition, speed is modified based on the hilliness of a road section. Bicyclists vary in their tolerance for riding on roads. Most novice bicyclists, and even other bicyclists, prefer cycleways and dedicated cycling paths and would rather avoid all but the quietest neighborhood roads. Other cyclists may be experienced riding on roads and prefer to take roadways because they often provide the fastest way to get between two places. The bicycle costing model accounts for this with a use_roads factor to indicate a cyclist's tolerance for riding on roads. Bicyclists vary in their fitness level and experience level, and many want to avoid hilly roads, and especially roads with very steep uphill or even downhill sections. Even if the fastest path is over a mountain, many cyclists prefer a flatter path that avoids the climb and descent up and over the mountain. The following options described above for autos also apply to bicycle costing methods: maneuver_penalty , gate_cost , gate_penalty , country_crossing_cost , country_costing_penalty , and service_penalty . These additional options are available for bicycle costing methods. Bicycle options Description bicycle_type The type of bicycle. The default type is Hybrid . Road : a road-style bicycle with narrow tires that is generally lightweight and designed for speed on paved surfaces. Hybrid or City : a bicycle made mostly for city riding or casual riding on roads and paths with good surfaces. Cross : a cyclo-cross bicycle, which is similar to a road bicycle but with wider tires suitable to rougher surfaces. Mountain : a mountain bicycle suitable for most surfaces but generally heavier and slower on paved surfaces. cycling_speed Cycling speed is the average travel speed along smooth, flat roads. This is meant to be the speed a rider can comfortably maintain over the desired distance of the route. It can be modified (in the costing method) by surface type in conjunction with bicycle type and (coming soon) by hilliness of the road section. When no speed is specifically provided, the default speed is determined by the bicycle type and are as follows: Road = 25 KPH (15.5 MPH), Cross = 20 KPH (13 MPH), Hybrid/City = 18 KPH (11.5 MPH), and Mountain = 16 KPH (10 MPH). use_roads A cyclist's propensity to use roads alongside other vehicles. This is a range of values from 0 to 1, where 0 attempts to avoid roads and stay on cycleways and paths, and 1 indicates the rider is more comfortable riding on roads. Based on the use_roads factor, roads with certain classifications and higher speeds are penalized in an attempt to avoid them when finding the best path. The default value is 0.5. use_hills A cyclist's desire to tackle hills in their routes. This is a range of values from 0 to 1, where 0 attempts to avoid hills and steep grades even if it means a longer (time and distance) path, while 1 indicates the rider does not fear hills and steeper grades. Based on the use_hills factor, penalties are applied to roads based on elevation change and grade. These penalties help the path avoid hilly roads in favor of flatter roads or less steep grades where available. Note that it is not always possible to find alternate paths to avoid hills (for example when route locations are in mountainous areas). The default value is 0.5. use_ferry This value indicates the willingness to take ferries. This is a range of values between 0 and 1. Values near 0 attempt to avoid ferries and values near 1 will favor ferries. Note that sometimes ferries are required to complete a route so values of 0 are not guaranteed to avoid ferries entirely. The default value is 0.5. use_living_streets This value indicates the willingness to take living streets. This is a range of values between 0 and 1. Values near 0 attempt to avoid living streets and values from 0.5 to 1 will currently have no effect on route selection. The default value is 0.5. Note that sometimes living streets are required to complete a route so values of 0 are not guaranteed to avoid living streets entirely. avoid_bad_surfaces This value is meant to represent how much a cyclist wants to avoid roads with poor surfaces relative to the bicycle type being used. This is a range of values between 0 and 1. When the value is 0, there is no penalization of roads with different surface types; only bicycle speed on each surface is taken into account. As the value approaches 1, roads with poor surfaces for the bike are penalized heavier so that they are only taken if they significantly improve travel time. When the value is equal to 1, all bad surfaces are completely disallowed from routing, including start and end points. The default value is 0.25. bss_return_cost This value is useful when bikeshare is chosen as travel mode. It is meant to give the time will be used to return a rental bike. This value will be displayed in the final directions and used to calculate the whole duation. The default value is 120 seconds. bss_return_penalty This value is useful when bikeshare is chosen as travel mode. It is meant to describe the potential effort to return a rental bike. This value won't be displayed and used only inside of the algorithm. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false .","title":"Bicycle costing options"},{"location":"api/turn-by-turn/api-reference/#motor_scooter-costing-options","text":"Standard costing for travel by motor scooter or moped. By default, motor_scooter costing will avoid higher class roads unless the country overrides allows motor scooters on these roads. Motor scooter routes follow regular roads when needed, but avoid roads without motor_scooter, moped, or mofa access. The costing model recognizes factors unique to motor_scooter travel and offers options for tuning motor_scooter routes. Factors unique to travel by motor_scooter influence the resulting route. All of the options described above for autos also apply to motor_scooter costing methods. These additional options are available for motor_scooter costing methods. Motor_scooter options Description top_speed Top speed the motorized scooter can go. Used to avoid roads with higher speeds than this value. For motor_scooter this value must be between 20 and 120 KPH. The default value is 45 KPH (~28 MPH) use_primary A riders's propensity to use primary roads. This is a range of values from 0 to 1, where 0 attempts to avoid primary roads, and 1 indicates the rider is more comfortable riding on primary roads. Based on the use_primary factor, roads with certain classifications and higher speeds are penalized in an attempt to avoid them when finding the best path. The default value is 0.5. use_hills A riders's desire to tackle hills in their routes. This is a range of values from 0 to 1, where 0 attempts to avoid hills and steep grades even if it means a longer (time and distance) path, while 1 indicates the rider does not fear hills and steeper grades. Based on the use_hills factor, penalties are applied to roads based on elevation change and grade. These penalties help the path avoid hilly roads in favor of flatter roads or less steep grades where available. Note that it is not always possible to find alternate paths to avoid hills (for example when route locations are in mountainous areas). The default value is 0.5. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false .","title":"Motor_scooter costing options"},{"location":"api/turn-by-turn/api-reference/#motorcycle-costing-options-beta","text":"Standard costing for travel by motorcycle. By default, motorcycle costing will default to higher class roads. The costing model recognizes factors unique to motorcycle travel and offers options for tuning motorcycle routes. All of the options described above for autos also apply to motorcycle costing methods. The following options are available for motorcycle costing: Motorcycle options Description use_highways A riders's propensity to prefer the use of highways. This is a range of values from 0 to 1, where 0 attempts to avoid highways, and values toward 1 indicates the rider prefers highways. The default value is 1.0. use_trails A riders's desire for adventure in their routes. This is a range of values from 0 to 1, where 0 will avoid trails, tracks, unclassified or bad surfaces and values towards 1 will tend to avoid major roads and route on secondary roads. The default value is 0.0. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false .","title":"Motorcycle costing options -&gt; BETA"},{"location":"api/turn-by-turn/api-reference/#pedestrian-costing-options","text":"These options are available for pedestrian costing methods. Pedestrian options Description walking_speed Walking speed in kilometers per hour. Must be between 0.5 and 25 km/hr. Defaults to 5.1 km/hr (3.1 miles/hour). walkway_factor A factor that modifies the cost when encountering roads classified as footway (no motorized vehicles allowed), which may be designated footpaths or designated sidewalks along residential roads. Pedestrian routes generally attempt to favor using these walkways and sidewalks . The default walkway_factor is 1.0. sidewalk_factor A factor that modifies the cost when encountering roads with dedicated sidewalks. Pedestrian routes generally attempt to favor using sidewalks . The default sidewalk_factor is 1.0. alley_factor A factor that modifies (multiplies) the cost when alleys are encountered. Pedestrian routes generally want to avoid alleys or narrow service roads between buildings. The default alley_factor is 2.0. driveway_factor A factor that modifies (multiplies) the cost when encountering a driveway , which is often a private, service road. Pedestrian routes generally want to avoid driveways (private). The default driveway factor is 5.0. step_penalty A penalty in seconds added to each transition onto a path with steps or stairs . Higher values apply larger cost penalties to avoid paths that contain flights of steps. use_ferry This value indicates the willingness to take ferries. This is range of values between 0 and 1. Values near 0 attempt to avoid ferries and values near 1 will favor ferries. The default value is 0.5. Note that sometimes ferries are required to complete a route so values of 0 are not guaranteed to avoid ferries entirely. use_living_streets This value indicates the willingness to take living streets. This is a range of values between 0 and 1. Values near 0 attempt to avoid living streets and values near 1 will favor living streets. The default value is 0.6. Note that sometimes living streets are required to complete a route so values of 0 are not guaranteed to avoid living streets entirely. use_tracks This value indicates the willingness to take track roads. This is a range of values between 0 and 1. Values near 0 attempt to avoid tracks and values near 1 will favor tracks a little bit. The default value is 0.5. Note that sometimes tracks are required to complete a route so values of 0 are not guaranteed to avoid tracks entirely. use_hills This is a range of values from 0 to 1, where 0 attempts to avoid hills and steep grades even if it means a longer (time and distance) path, while 1 indicates the pedestrian does not fear hills and steeper grades. Based on the use_hills factor, penalties are applied to roads based on elevation change and grade. These penalties help the path avoid hilly roads in favor of flatter roads or less steep grades where available. Note that it is not always possible to find alternate paths to avoid hills (for example when route locations are in mountainous areas). The default value is 0.5. use_lit This value is a range of values from 0 to 1, where 0 indicates indifference towards lit streets, and 1 indicates that unlit streets should be avoided. Note that even with values near 1, there is no guarantee the returned route will include lit segments. The default value is 0. service_penalty A penalty applied for transition to generic service road. The default penalty is 0. service_factor A factor that modifies (multiplies) the cost when generic service roads are encountered. The default service_factor is 1. max_hiking_difficulty This value indicates the maximum difficulty of hiking trails that is allowed. Values between 0 and 6 are allowed. The values correspond to sac_scale values within OpenStreetMap, see reference here . The default value is 1 which means that well cleared trails that are mostly flat or slightly sloped are allowed. Higher difficulty trails can be allowed by specifying a higher value for max_hiking_difficulty. bss_rent_cost This value is useful when bikeshare is chosen as travel mode. It is meant to give the time will be used to rent a bike from a bike share station. This value will be displayed in the final directions and used to calculate the whole duation. The default value is 120 seconds. bss_rent_penalty This value is useful when bikeshare is chosen as travel mode. It is meant to describe the potential effort to rent a bike from a bike share station. This value won't be displayed and used only inside of the algorithm. shortest Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings & penalties. Also note, shortest will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is false .","title":"Pedestrian costing options"},{"location":"api/turn-by-turn/api-reference/#transit-costing-options","text":"These options are available for transit costing when the multimodal costing model is used. Transit options Description use_bus User's desire to use buses. Range of values from 0 (try to avoid buses) to 1 (strong preference for riding buses). use_rail User's desire to use rail/subway/metro. Range of values from 0 (try to avoid rail) to 1 (strong preference for riding rail). use_transfers User's desire to favor transfers. Range of values from 0 (try to avoid transfers) to 1 (totally comfortable with transfers). transit_start_end_max_distance A pedestrian option that can be added to the request to extend the defaults (2145 meters or approximately 1.5 miles). This is the maximum walking distance at the beginning or end of a route. transit_transfer_max_distance A pedestrian option that can be added to the request to extend the defaults (800 meters or 0.5 miles). This is the maximum walking distance between transfers. filters A way to filter for one or more stops , routes , or operators . Filters must contain a list of Onestop IDs , which is a unique identifier for Transitland data, and an action . ids : any number of Onestop IDs (such as o-9q9-bart) action : either exclude to exclude all of the ids listed in the filter or include to include only the ids listed in the filter","title":"Transit costing options"},{"location":"api/turn-by-turn/api-reference/#filter-transit-data","text":"When using filters , you need to include a Onestop ID to identify the stop, routes, or operators to include or exclude in your query. Depending on how you are interacting with transit data from Transitland, there are different ways of obtaining the Onestop ID. Turn-by-Turn API: Query a transit route query and parse the returned JSON maneuver for transit_info to find operator_onestop_id and the route onestop_id . A transit_stop contains the onestop_id for the stop. Mobility Explorer : Click a single route, stop, or operator on the map, or use the drop-down menu to find the Onestop ID for routes and operators. The Onestop ID, among other details, is listed in the sidebar. Transitland : Use the Transitland Datastore API to query directly for stops, routes, and operators using a number of options. For example, you can filter for only subway routes or bus routes . See the Transitland Datastore API documentation for details.","title":"Filter transit data"},{"location":"api/turn-by-turn/api-reference/#sample-json-payloads-for-multimodal-requests-with-transit","text":"A multimodal request at the current date and time: { \"locations\" :[{ \"lat\" : 40.730930 , \"lon\" : -73.991379 , \"street\" : \"Wanamaker Place\" },{ \"lat\" : 40.749706 , \"lon\" : -73.991562 , \"street\" : \"Penn Plaza\" }], \"costing\" : \"multimodal\" , \"units\" : \"miles\" } A multimodal request departing on 2016-03-29 at 08:00: { \"locations\" :[{ \"lat\" : 40.749706 , \"lon\" : -73.991562 , \"type\" : \"break\" , \"street\" : \"Penn Plaza\" },{ \"lat\" : 40.73093 , \"lon\" : -73.991379 , \"type\" : \"break\" , \"street\" : \"Wanamaker Place\" }], \"costing\" : \"multimodal\" , \"date_time\" :{ \"type\" : 1 , \"value\" : \"2016-03-29T08:00\" }} A multimodal request for a route favoring buses and a person walking at a set speed of 4.1 km/h: { \"locations\" :[{ \"lat\" : 40.749706 , \"lon\" : -73.991562 , \"type\" : \"break\" , \"street\" : \"Penn Plaza\" },{ \"lat\" : 40.73093 , \"lon\" : -73.991379 , \"type\" : \"break\" , \"street\" : \"Wanamaker Place\" }], \"costing\" : \"multimodal\" , \"costing_options\" :{ \"transit\" :{ \"use_bus\" : \"1.0\" , \"use_rail\" : \"0.0\" , \"use_transfers\" : \"0.3\" }, \"pedestrian\" :{ \"walking_speed\" : \"4.1\" }}} A multimodal request with a filter for certain Onestop IDs: { \"locations\" :[{ \"lat\" : 40.730930 , \"lon\" : -73.991379 , \"street\" : \"Wanamaker Place\" },{ \"lat\" : 40.749706 , \"lon\" : -73.991562 , \"street\" : \"Penn Plaza\" }], \"costing\" : \"multimodal\" , \"costing_options\" :{ \"transit\" :{ \"filters\" :{ \"stops\" :{ \"ids\" :[ \"s-dr5rsq8pqg-8st~nyu&#60;r21n\" , \"s-dr5rsr9wyg-14st&#126;unionsq&#60;r20n\" ], \"action\" : \"exclude\" }, \"routes\" :{ \"ids\" :[ \"r-dr5r-r\" ], \"action\" : \"exclude\" }, \"operators\" :{ \"ids\" :[ \"o-dr5r-path\" ], \"action\" : \"include\" }}}}, \"units\" : \"miles\" }","title":"Sample JSON payloads for multimodal requests with transit"},{"location":"api/turn-by-turn/api-reference/#directions-options","text":"Directions options should be specified at the top level of the JSON object. Options Description units Distance units for output. Allowable unit types are miles (or mi) and kilometers (or km). If no unit type is specified, the units default to kilometers. language The language of the narration instructions based on the IETF BCP 47 language tag string. If no language is specified or the specified language is unsupported, United States-based English (en-US) is used. Currently supported language list directions_type An enum with 3 values. none indicating no maneuvers or instructions should be returned. maneuvers indicating that only maneuvers be returned. instructions indicating that maneuvers with instructions should be returned (this is the default if not specified). alternates A number denoting how many alternate routes should be provided. There may be no alternates or less alternates than the user specifies. Alternates are not yet supported on multipoint routes (that is, routes with more than 2 locations). They are also not supported on time dependent routes.","title":"Directions options"},{"location":"api/turn-by-turn/api-reference/#supported-language-tags","text":"Language tag Language alias Description bg-BG bg Bulgarian (Bulgaria) ca-ES ca Catalan (Spain) cs-CZ cs Czech (Czech Republic) da-DK da Danish (Denmark) de-DE de German (Germany) el-GR el Greek (Greece) en-GB English (United Kingdom) en-US-x-pirate en-x-pirate English (United States) Pirate en-US en English (United States) es-ES es Spanish (Spain) et-EE et Estonian (Estonia) fi-FI fi Finnish (Finland) fr-FR fr French (France) hi-IN hi Hindi (India) hu-HU hu Hungarian (Hungary) it-IT it Italian (Italy) ja-JP ja Japanese (Japan) nb-NO nb Bokmal (Norway) nl-NL nl Dutch (Netherlands) pl-PL pl Polish (Poland) pt-BR Portuguese (Brazil) pt-PT pt Portuguese (Portugal) ro-RO ro Romanian (Romania) ru-RU ru Russian (Russia) sk-SK sk Slovak (Slovakia) sl-SI sl Slovenian (Slovenia) sv-SE sv Swedish (Sweden) tr-TR tr Turkish (Turkey) uk-UA uk Ukrainian (Ukraine)","title":"Supported language tags"},{"location":"api/turn-by-turn/api-reference/#other-request-options","text":"Options Description exclude_locations A set of locations to exclude or avoid within a route can be specified using a JSON array of avoid_locations. The avoid_locations have the same format as the locations list. At a minimum each avoid location must include latitude and longitude. The avoid_locations are mapped to the closest road or roads and these roads are excluded from the route path computation. exclude_polygons One or multiple exterior rings of polygons in the form of nested JSON arrays, e.g. [[[lon1, lat1], [lon2,lat2]],[[lon1,lat1],[lon2,lat2]]] . Roads intersecting these rings will be avoided during path finding. If you only need to avoid a few specific roads, it's much more efficient to use exclude_locations . Valhalla will close open rings (i.e. copy the first coordingate to the last position). date_time This is the local date and time at the location. type 0 - Current departure time. 1 - Specified departure time 2 - Specified arrival time. Not yet implemented for multimodal costing method. 3 - Invariant specified time. Time does not vary over the course of the path. Not implemented for multimodal or bike share routing value - the date and time is specified in ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. For example \"2016-07-03T08:06\" out_format Output format. If no out_format is specified, JSON is returned. Future work includes PBF (protocol buffer) support. id Name your route request. If id is specified, the naming will be sent thru to the response. linear_references When present and true , the successful route response will include a key linear_references . Its value is an array of base64-encoded OpenLR location references , one for each graph edge of the road network matched by the input trace. prioritize_bidirectional Prioritize bidirectional a* when date_time.type = depart_at/current . By default time_dependent_forward a* is used in these cases, but bidirectional a* is much faster. Currently it does not update the time (and speeds) when searching for the route path, but the ETA on that route is recalculated based on the time-dependent speeds","title":"Other request options"},{"location":"api/turn-by-turn/api-reference/#outputs-of-a-route","text":"If a route has been named in the request using the optional &id= input, then the name will be returned as a string id on the JSON object. The route results are returned as a trip . This is a JSON object that contains details about the trip, including locations, a summary with basic information about the entire trip, and a list of legs . Basic trip information includes: Trip item Description status Status code. status_message Status message. units The specified units of length are returned, either kilometers or miles. language The language of the narration instructions. If the user specified a language in the directions options and the specified language was supported - this returned value will be equal to the specified value. Otherwise, this value will be the default (en-US) language. locations Location information is returned in the same form as it is entered with additional fields to indicate the side of the street. warnings (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc. The summary JSON object includes: Summary item Description time Estimated elapsed time to complete the trip. length Distance traveled for the entire trip. Units are either miles or kilometers based on the input units specified. has_toll Flag indicating if the the path uses one or more toll segments. has_highway Flag indicating if the the path uses one or more highway segments. has_ferry Flag indicating if the the path uses one or more ferry segments. min_lat Minimum latitude of a bounding box containing the route. min_lon Minimum longitude of a bounding box containing the route. max_lat Maximum latitude of a bounding box containing the route. max_lon Maximum longitude of a bounding box containing the route.","title":"Outputs of a route"},{"location":"api/turn-by-turn/api-reference/#trip-legs-and-maneuvers","text":"A trip contains one or more legs . For n number of break locations, there are n-1 legs. Through locations do not create separate legs. Each leg of the trip includes a summary, which is comprised of the same information as a trip summary but applied to the single leg of the trip. It also includes a shape , which is an encoded polyline of the route path (with 6 digits decimal precision), and a list of maneuvers as a JSON array. For more about decoding route shapes, see these code examples . Each maneuver includes: Maneuver item Description type Type of maneuver. See below for a list. instruction Written maneuver instruction. Describes the maneuver, such as \"Turn right onto Main Street\". verbal_transition_alert_instruction Text suitable for use as a verbal alert in a navigation application. The transition alert instruction will prepare the user for the forthcoming transition. For example: \"Turn right onto North Prince Street\". verbal_pre_transition_instruction Text suitable for use as a verbal message immediately prior to the maneuver transition. For example \"Turn right onto North Prince Street, U.S. 2 22\". verbal_post_transition_instruction Text suitable for use as a verbal message immediately after the maneuver transition. For example \"Continue on U.S. 2 22 for 3.9 miles\". street_names List of street names that are consistent along the entire nonobvious maneuver. begin_street_names When present, these are the street names at the beginning (transition point) of the nonobvious maneuver (if they are different than the names that are consistent along the entire nonobvious maneuver). time Estimated time along the maneuver in seconds. length Maneuver length in the units specified. begin_shape_index Index into the list of shape points for the start of the maneuver. end_shape_index Index into the list of shape points for the end of the maneuver. toll True if the maneuver has any toll, or portions of the maneuver are subject to a toll. highway True if a highway is encountered on this maneuver. rough True if the maneuver is unpaved or rough pavement, or has any portions that have rough pavement. gate True if a gate is encountered on this maneuver. ferry True if a ferry is encountered on this maneuver. sign Contains the interchange guide information at a road junction associated with this maneuver. See below for details. roundabout_exit_count The spoke to exit roundabout after entering. depart_instruction Written depart time instruction. Typically used with a transit maneuver, such as \"Depart: 8:04 AM from 8 St - NYU\". verbal_depart_instruction Text suitable for use as a verbal depart time instruction. Typically used with a transit maneuver, such as \"Depart at 8:04 AM from 8 St - NYU\". arrive_instruction Written arrive time instruction. Typically used with a transit maneuver, such as \"Arrive: 8:10 AM at 34 St - Herald Sq\". verbal_arrive_instruction Text suitable for use as a verbal arrive time instruction. Typically used with a transit maneuver, such as \"Arrive at 8:10 AM at 34 St - Herald Sq\". transit_info Contains the attributes that describe a specific transit route. See below for details. verbal_multi_cue True if the verbal_pre_transition_instruction has been appended with the verbal instruction of the next maneuver. travel_mode Travel mode. \"drive\" \"pedestrian\" \"bicycle\" \"transit\" travel_type Travel type for drive. \"car\" Travel type for pedestrian. \"foot\" Travel type for bicycle. \"road\" Travel type for transit. Tram or light rail = \"tram\" Metro or subway = \"metro\" Rail = \"rail\" Bus = \"bus\" Ferry = \"ferry\" Cable car = \"cable_car\" Gondola = \"gondola\" Funicular = \"funicular\" bss_maneuver_type Used when travel_mode is bikeshare . Describes bike share maneuver. The default value is \"NoneAction \"NoneAction\" \"RentBikeAtBikeShare\" \"ReturnBikeAtBikeShare\" For the maneuver type , the following are available: kNo ne = 0 ; kS tart = 1 ; kS tart Righ t = 2 ; kS tart Le ft = 3 ; kDes t i nat io n = 4 ; kDes t i nat io n Righ t = 5 ; kDes t i nat io n Le ft = 6 ; kBecomes = 7 ; kCo nt i nue = 8 ; kSligh t Righ t = 9 ; kRigh t = 10 ; kSharpRigh t = 11 ; kU turn Righ t = 12 ; kU turn Le ft = 13 ; kSharpLe ft = 14 ; kLe ft = 15 ; kSligh t Le ft = 16 ; kRampS tra igh t = 17 ; kRampRigh t = 18 ; kRampLe ft = 19 ; kExi t Righ t = 20 ; kExi t Le ft = 21 ; kS ta yS tra igh t = 22 ; kS ta yRigh t = 23 ; kS ta yLe ft = 24 ; kMerge = 25 ; kRou n dabou t E nter = 26 ; kRou n dabou t Exi t = 27 ; kFerryE nter = 28 ; kFerryExi t = 29 ; kTra ns i t = 30 ; kTra ns i t Tra nsfer = 31 ; kTra ns i t Remai n O n = 32 ; kTra ns i t Co nne c t io n S tart = 33 ; kTra ns i t Co nne c t io n Tra nsfer = 34 ; kTra ns i t Co nne c t io n Des t i nat io n = 35 ; kPos t Tra ns i t Co nne c t io n Des t i nat io n = 36 ; kMergeRigh t = 37 ; kMergeLe ft = 38 ; The maneuver sign may contain four lists of interchange sign elements as follows: exit_number_elements = list of exit number elements. If an exit number element exists, it is typically just one value. exit_branch_elements = list of exit branch elements. The exit branch element text is the subsequent road name or route number after the sign. exit_toward_elements = list of exit toward elements. The exit toward element text is the location where the road ahead goes - the location is typically a control city, but may also be a future road name or route number. exit_name_elements = list of exit name elements. The exit name element is the interchange identifier - typically not used in the US. Each maneuver sign element includes: Maneuver sign element item Description text Interchange sign text. exit number example: 91B. exit branch example: I 95 North. exit toward example: New York. exit name example: Gettysburg Pike. consecutive_count The frequency of this sign element within a set a consecutive signs. This item is optional. A maneuver transit_info includes: Maneuver transit route item Description onestop_id Global transit route identifier from Transitland. short_name Short name describing the transit route. For example \"N\". long_name Long name describing the transit route. For example \"Broadway Express\". headsign The sign on a public transport vehicle that identifies the route destination to passengers. For example \"ASTORIA - DITMARS BLVD\". color The numeric color value associated with a transit route. The value for yellow would be \"16567306\". text_color The numeric text color value associated with a transit route. The value for black would be \"0\". description The description of the the transit route. For example \"Trains operate from Ditmars Boulevard, Queens, to Stillwell Avenue, Brooklyn, at all times. N trains in Manhattan operate along Broadway and across the Manhattan Bridge to and from Brooklyn. Trains in Brooklyn operate along 4 th Avenue, then through Borough Park to Gravesend. Trains typically operate local in Queens, and either express or local in Manhattan and Brooklyn, depending on the time. Late night trains operate via Whitehall Street, Manhattan. Late night service is local\". operator_onestop_id Global operator/agency identifier from Transitland. operator_name Operator/agency name. For example, \"BART\", \"King County Marine Division\", and so on. Short name is used over long name. operator_url Operator/agency URL. For example, \"http://web.mta.info/\". transit_stops A list of the stops/stations associated with a specific transit route. See below for details. A transit_stop includes: Transit stop item Description type Type of stop (simple stop=0; station=1). onestop_id Global transit stop identifier from Transitland. name Name of the stop or station. For example \"14 St - Union Sq\". arrival_date_time Arrival date and time using the ISO 8601 format (YYYY-MM-DDThh:mm). For example, \"2015-12-29T08:06\". departure_date_time Departure date and time using the ISO 8601 format (YYYY-MM-DDThh:mm). For example, \"2015-12-29T08:06\". is_parent_stop True if this stop is a marked as a parent stop. assumed_schedule True if the times are based on an assumed schedule because the actual schedule is not known. lat Latitude of the transit stop in degrees. lon Longitude of the transit stop in degrees. Continuing with the earlier routing example from the Detroit, Michigan area, a maneuver such as this one may be returned with that request: {\"begin_shape_index\":0,\"length\":0.109,\"end_shape_index\":1,\"instruction\":\"Go south on Appleton.\",\"street_names\":[\"Appleton\"],\"type\":1,\"time\":0} In the future, look for additional maneuver information to enhance navigation applications, including landmark usage.","title":"Trip legs and maneuvers"},{"location":"api/turn-by-turn/api-reference/#http-status-codes-and-conditions","text":"The following is a table of HTTP status error code conditions that may occur for a particular request. In general, the service follows the HTTP specification . That is to say that 5xx returns are generally ephemeral server problems that should be resolved shortly or are the result of a bug. 4xx returns are used to mark requests that cannot be carried out, generally due to bad input in the request or problems with the underlying data. A 2xx return is expected when there is a successful route result or trip , as described above. Status Code Status Description 200 your_trip_json A happy bit of json describing your trip result 400 Failed to parse json request You need a valid json request 400 Failed to parse location You need a valid location object in your json request 400 Failed to parse correlated location There was a problem with the location once correlated to the route network 400 Insufficiently specified required parameter 'locations' You forgot the locations parameter 400 No edge/node costing provided You forgot the costing parameter 400 Insufficient number of locations provided You didn't provide enough locations 400 Exceeded max route locations of X You are asking for too many locations 400 Locations are in unconnected regions. Go check/edit the map at osm.org You are routing between regions of no connectivity 400 No costing method found for 'X' You are asking for a non-existent costing mode 400 Path distance exceeds the max distance limit You want to travel further than this mode allows 400 No suitable edges near location There were no edges applicable to your mode of travel near the input location 400 No data found for location There was no route data tile at the input location 400 No path could be found for input There was no path found between the input locations 404 Try any of: '/route' '/locate' You asked for an invalid path 405 Try a POST or GET request instead We only support GET and POST requests 500 Failed to parse intermediate request format Had a problem reading an intermediate request format 500 Failed to parse TripPath Had a problem reading the computed path from Protobuf 500 Could not build directions for TripPath Had a problem using the trip path to create TripDirections 500 Failed to parse TripDirections Had a problem using the trip directions to serialize a json response 501 Not implemented Not Implemented","title":"HTTP status codes and conditions"},{"location":"api/turn-by-turn/api-reference/#internal-error-codes-and-conditions","text":"The following is a table of exception internal error code conditions that may occur for a particular request. An error code utility header file can be included by any of the Valhalla service projects. The codes correspond to code returned from a particular Valhalla project . Error code Error 1xx Loki project codes 100 Failed to parse json request 101 Try a POST or GET request instead 102 The config actions for Loki are incorrectly loaded 103 Missing max_locations configuration 104 Missing max_distance configuration 105 Path action not supported 106 Try any of 107 Not Implemented 110 Insufficiently specified required parameter 'locations' 111 Insufficiently specified required parameter 'time' 112 Insufficiently specified required parameter 'locations' or 'sources & targets' 113 Insufficiently specified required parameter 'contours' 114 Insufficiently specified required parameter 'shape' or 'encoded_polyline' 120 Insufficient number of locations provided 121 Insufficient number of sources provided 122 Insufficient number of targets provided 123 Insufficient shape provided 124 No edge/node costing provided 125 No costing method found 126 No shape provided 130 Failed to parse location 131 Failed to parse source 132 Failed to parse target 140 Action does not support multimodal costing 141 Arrive by for multimodal not implemented yet 142 Arrive by not implemented for isochrones 143 ignore_closure in costing and exclude_closure in search_filter cannot both be specified 150 Exceeded max locations 151 Exceeded max time 152 Exceeded max contours 153 Too many shape points 154 Path distance exceeds the max distance limit 155 Outside the valid walking distance at the beginning or end of a multimodal route 156 Outside the valid walking distance between stops of a multimodal route 157 Exceeded max avoid locations 158 Input trace option is out of bounds 160 Date and time required for origin for date_type of depart at 161 Date and time required for destination for date_type of arrive by 162 Date and time is invalid. Format is YYYY-MM-DDTHH:MM 163 Invalid date_type 170 Locations are in unconnected regions. Go check/edit the map at osm.org 171 No suitable edges near location 199 Unknown 2xx Odin project codes 200 Failed to parse intermediate request format 201 Failed to parse TripPath 210 Trip path does not have any nodes 211 Trip path has only one node 212 Trip must have at least 2 locations 213 Error - No shape or invalid node count 220 Turn degree out of range for cardinal direction 230 Invalid TripDirections_Maneuver_Type in method FormTurnInstruction 231 Invalid TripDirections_Maneuver_Type in method FormRelativeTwoDirection 232 Invalid TripDirections_Maneuver_Type in method FormRelativeThreeDirection 299 Unknown 3xx Skadi project codes 300 Failed to parse json request 301 Try a POST or GET request instead 302 The config actions for Skadi are incorrectly loaded 303 Path action not supported 304 Try any of 305 Not Implemented 310 No shape provided 311 Insufficient shape provided 312 Insufficiently specified required parameter 'shape' or 'encoded_polyline' 313 'resample_distance' must be >= 314 Too many shape points 399 Unknown 4xx Thor project codes 400 Unknown action 401 Failed to parse intermediate request format 410 Insufficiently specified required parameter 'locations' 411 Insufficiently specified required parameter 'shape' 412 No costing method found 420 Failed to parse correlated location 421 Failed to parse location 422 Failed to parse source 423 Failed to parse target 424 Failed to parse shape 430 Exceeded max iterations in CostMatrix::SourceToTarget 440 Cannot reach destination - too far from a transit stop 441 Location is unreachable 442 No path could be found for input 443 Exact route match algorithm failed to find path 444 Map Match algorithm failed to find path 445 Shape match algorithm specification in api request is incorrect. Please see documentation for valid shape_match input. 499 Unknown 5xx Tyr project codes 500 Failed to parse intermediate request format 501 Failed to parse TripDirections 599 Unknown","title":"Internal error codes and conditions"},{"location":"api/turn-by-turn/overview/","text":"Routing overview \u00b6 The Valhalla route service (a.k.a. turn-by-turn) is an open-source routing service that lets you integrate routing and navigation into a web or mobile application. The service works globally, and provides dynamic and customizable routing by driving, walking, bicycling, and using multimodal and transit options, with clear directions for maneuvers along the route. Route requests and results \u00b6 When you request a route , you are sending and receiving JSON , which is a human-readable text format. In the JSON array, you need to specify the locations to visit on the route, the costing model that represents the mode of travel, such as car or bicycle, and your API key. The location coordinates, given in decimal degrees, can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service such as Mapbox Geocoding , and so on. Costing methods can have several options that can be adjusted to develop the the route path and estimate the time along the path. The service route results provide details about the trip, including locations, a summary with basic information about the entire trip and a list of legs. Each leg has its own summary, a shape, which is an encoded polyline of the route path, and a list of maneuvers. These maneuvers provide written narrative instructions, plus verbal alerts that can be used as audio guidance in navigation apps. The JSON returned from the route query can be drawn on a map and shown as instructions for maneuvers along the route. You can display Valhalla routes on web and mobile maps. Data sources in Turn-by-Turn \u00b6 Valhalla draws data from OpenStreetMap and from Transitland , the open transit data aggregation project. Apps can also query the Transitland API to build maps and analyses that enrich that journey and provide context around Points A and B, as well as the many multimodal transportation options that connect them. Journeys planned by Valhalla and data in Transitland all include Onestop IDs, an open identifier scheme that catalogs transit operators, stops, and routes from around the world. The source code is open to view and modify, and contributions are welcomed.","title":"Overview"},{"location":"api/turn-by-turn/overview/#routing-overview","text":"The Valhalla route service (a.k.a. turn-by-turn) is an open-source routing service that lets you integrate routing and navigation into a web or mobile application. The service works globally, and provides dynamic and customizable routing by driving, walking, bicycling, and using multimodal and transit options, with clear directions for maneuvers along the route.","title":"Routing overview"},{"location":"api/turn-by-turn/overview/#route-requests-and-results","text":"When you request a route , you are sending and receiving JSON , which is a human-readable text format. In the JSON array, you need to specify the locations to visit on the route, the costing model that represents the mode of travel, such as car or bicycle, and your API key. The location coordinates, given in decimal degrees, can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service such as Mapbox Geocoding , and so on. Costing methods can have several options that can be adjusted to develop the the route path and estimate the time along the path. The service route results provide details about the trip, including locations, a summary with basic information about the entire trip and a list of legs. Each leg has its own summary, a shape, which is an encoded polyline of the route path, and a list of maneuvers. These maneuvers provide written narrative instructions, plus verbal alerts that can be used as audio guidance in navigation apps. The JSON returned from the route query can be drawn on a map and shown as instructions for maneuvers along the route. You can display Valhalla routes on web and mobile maps.","title":"Route requests and results"},{"location":"api/turn-by-turn/overview/#data-sources-in-turn-by-turn","text":"Valhalla draws data from OpenStreetMap and from Transitland , the open transit data aggregation project. Apps can also query the Transitland API to build maps and analyses that enrich that journey and provide context around Points A and B, as well as the many multimodal transportation options that connect them. Journeys planned by Valhalla and data in Transitland all include Onestop IDs, an open identifier scheme that catalogs transit operators, stops, and routes from around the world. The source code is open to view and modify, and contributions are welcomed.","title":"Data sources in Turn-by-Turn"},{"location":"meili/algorithms/","text":"Map Matching in a Programmer's Perspective \u00b6 Meili uses a Hidden Markov Model (HMM) approach, proposed by Paul Newson and John Krumm in 2009 , to solve the map matching problem. The map-matching problem is modelled as follows: given a sequence of GPS measurements (observations in terms of HMM), each measurement has to match one of a set of potential candidate road segments (hidden states in terms of HMM), the problem is to find the most likely sequence of candidates. In this figure we see a noisy GPS sequence of 4 measurements, from green to red. Each measurement could match one of its candidates nearby (the small markers in cyan) but which is the most likely one? The answer is 0, 4, 9, 11 respectively. That is our most likely sequence of candidates, which constructs the red matched route. A good explanation about the modelling can be found here and here . The problem can be formulated as a graph search problem that is familiar to programmers. Here we briefly introduce the problem formulation and then introduce several solutions, followed by improvements and experiments. Graphical Model \u00b6 Put the example above in a graphical model, it looks like this: It is a Directed Acyclic Graph (DAG). Each measurement has a column of nodes associated. A node (a hidden state in terms of HMM) in the graph represents a candidate, namely a tuple (road segment, offset) that tells a location on a road segment on the map. An edge (u, v) means that node u is able to affect the decision about v . Take the edge (node 9, node 12) as an example: since it takes a much longer way than it looks from node 9 to node 12, node 12 is therefore unlikely to be the match to the last measurement. As you can see in the graph a measurement can be affected only by its previous measurement. Two probability models are used together to quantify how likely a measurement would be to match a node. The emission probability tells that closer a node stays to its measurement more likely the measurement is to match it, while the transition probability tells that closer the walk distance from u to v is to the measurement distance, the more likely v 's measurement is to match it. # A gaussian distribution def emission_prob ( u ): c = 1 / ( SIGMA_Z * math . sqrt ( 2 * math . pi )) return c * math . exp ( - great_circle_distance ( u . measurement , u ) ** 2 ) # A empirical distribution def transition_prob ( u , v ): c = 1 / BETA # Calculating route distance is expensive. # We will discuss how to reduce the number of calls to this function later. delta = math . abs ( route_distance ( u , v ) - great_circle_distance ( u . measurement , v . measurement )) return c * math . exp ( - delta ) A path is a list of edges. The probability of a path is defined as follows: def path_prob ( path ): assert path u , v = path [ 0 ] joint_prob = emission_prob ( u ) for u , v in path : joint_prob *= transition_prob ( u , v ) * emission_prob ( v ) return joint_prob The task is to find the most likely sequence over all possible sequences. For convenience's sake, we added two virtual nodes, the source node s and the target node t , and corresponding virtual edges to the graph with all emission and transition probabilities to be 1.0. The task hence becomes: find a path from s to t that maximizes the path probability. Solutions \u00b6 To make the problem clear, a brute-force solution is given first. Given a graph represented by a Adjacency List , a source node and a target node, the procedure maximum_path_prob tries hard to list all paths in between and then selects the optimal one among them. def maximum_path_prob ( adjacency_list , s , t ): return max (( path_prob ( path ), path ) for path in all_paths ( adjacency_list , s , t ), key = lambda prob , path : prob ) # Generate all paths from s to t recursively def all_paths ( adjacency_list , s , t ): if s == t : return [[]] paths = [] for v in adjacency_list [ s ]: for path in all_paths ( adjacency_list , v , t ): paths . append ([( s , v )] + path ) return paths Viterbi Algorithm is usually used to find the most likely sequence in HMM. In the DAG the Viterbi Algorithm works like Breath-First-Search (BFS) algorithm that searches the target level by level. During the search/expansion, the Viterbi Algorithm also remembers each node's optimal solution (the optimal path from the source and the path probability) and use them to find optimal solutions for next level. def viterbi_search ( adjacency_list , s , t ): # Initialize joint probability for each node joint_prob = {} for u in adjacency_list : joint_prob [ u ] = 0 predecessor = {} queue = FIFOQueue () queue . push ( s ) joint_prob [ s ] = emission_prob ( s ) predecessor [ s ] = None while not queue . empty (): # Extract node u u = queue . pop () # Guarantee the optimal solution to u is found assert joint_prob [ u ] == maximum_path_prob ( adjacency_list , s , u )[ 0 ] if u == t : break for v in adjacency_list [ u ]: # Relaxation new_prob = joint_prob [ u ] * transition_prob ( u , v ) * emission_prob ( v ) if joint_prob [ v ] < new_prob : joint_prob [ v ] = new_prob predecessor [ v ] = u if v not in queue : queue . push ( v ) return joint_prob [ t ], construct_path ( predecessor , s , t ) The Viterbi Algorithm is the one used in the paper to find the optimal path, while another approach is to use Topological Sort in the DAG. Both algorithms have to explore all edges to find the path. However in the map-matching model exploring an edge is expensive. During the exploration of an edge (u, v) , it needs to find the shortest path between u and v in the road network for calculating its transition probability. Suppose that, given a sequence of S measurements and each measurement has average T states, the Viterbi Algorithm or the topological sort approach will traverse all edges i.e. do S * T * T times of shortest path calculations. This is not good, especially in dense urban areas where you can easily get a large average T . To reduce the number of transition probability calculations, we use the Dijkstra's algorithm to avoid extracting those unlikely nodes as many as possible. Like the Viterbi Algorithm, the Dijkstra's algorithm solves the problem in a Dynamic Programming approach. The advantage of the Dijkstra's algorithm is that it extracts nodes in a greedy way, i.e. extracts the most likely node every time. With this strategy, as soon as the target is extracted, the optimal solution is guaranteed to be found and thus the rest of nodes can be safely thrown away. Before applying the Dijkstra's algorithm we should notice that our objective is to find the most likely path, whereas the Dijkstra's algorithm is designed to solve shortest path problem, i.e. minimizing a certain objective. Therefore we need to transform the maximization problem to a minimization problem in the following way: With following prerequisites: T = transition_prob E = emission_prob lg = math . log10 assert 0 <= E ( u ) <= 1.0 and 0 <= T ( u , v ) <= 1.0 We are maximizing path_prob(path) among a set of paths. Expanding path_prob(path) we get: # For simplicity we ignored the last node product ( E ( u ) * T ( u , v ) for u , v in path ) which is equivalent to maximizing: lg ( product ( E ( u ) * T ( u , v ) for u , v in path )) # equivalent to sum ( lg ( E ( u )) + lg ( T ( u , v )) for u , v in path ) # because lg(a * b) == lg(a) + lg(b) which is equivalent to minimizing: - sum ( lg ( E ( u )) + lg ( T ( u , v )) for u , v in path ) # equivalent to sum ( - lg ( E ( u )) + - lg ( T ( u , v )) for u , v in path ) # Must be non-negative assert 0 <= - lg ( E ( u )) and 0 <= - lg ( T ( u , v )) After the transformation, the emission probability of a node turns to the node cost, and the transition probability of an edge turns to the edge cost. def node_cost ( u ): return - 1 * math . log10 ( emission_prob ( u )) def edge_cost ( u , v ): return - 1 * math . log10 ( transition_prob ( u , v )) The problem becomes find a path from s to t that minimizes sum(node_cost(u) + edge_cost(u, v) for u, v in path) which can be efficiently solved by the Dijkstra's algorithm. Thanks to the similarity to the Viterbi Algorithm, changing the FIFO queue in the viterbi_search procedure to a priority queue, and the probability calculation to the cost calculation should get you a rough Dijkstra based solution, a greedy, lazy but faster version of the Viterbi Algorithm. TODO Experiments \u00b6 TODO comparison between the original Viterbi Algorithm and the Dijkstra Viterbi Algorithm, and comparisons with and without tweaks.","title":"Algorithms"},{"location":"meili/algorithms/#map-matching-in-a-programmers-perspective","text":"Meili uses a Hidden Markov Model (HMM) approach, proposed by Paul Newson and John Krumm in 2009 , to solve the map matching problem. The map-matching problem is modelled as follows: given a sequence of GPS measurements (observations in terms of HMM), each measurement has to match one of a set of potential candidate road segments (hidden states in terms of HMM), the problem is to find the most likely sequence of candidates. In this figure we see a noisy GPS sequence of 4 measurements, from green to red. Each measurement could match one of its candidates nearby (the small markers in cyan) but which is the most likely one? The answer is 0, 4, 9, 11 respectively. That is our most likely sequence of candidates, which constructs the red matched route. A good explanation about the modelling can be found here and here . The problem can be formulated as a graph search problem that is familiar to programmers. Here we briefly introduce the problem formulation and then introduce several solutions, followed by improvements and experiments.","title":"Map Matching in a Programmer's Perspective"},{"location":"meili/algorithms/#graphical-model","text":"Put the example above in a graphical model, it looks like this: It is a Directed Acyclic Graph (DAG). Each measurement has a column of nodes associated. A node (a hidden state in terms of HMM) in the graph represents a candidate, namely a tuple (road segment, offset) that tells a location on a road segment on the map. An edge (u, v) means that node u is able to affect the decision about v . Take the edge (node 9, node 12) as an example: since it takes a much longer way than it looks from node 9 to node 12, node 12 is therefore unlikely to be the match to the last measurement. As you can see in the graph a measurement can be affected only by its previous measurement. Two probability models are used together to quantify how likely a measurement would be to match a node. The emission probability tells that closer a node stays to its measurement more likely the measurement is to match it, while the transition probability tells that closer the walk distance from u to v is to the measurement distance, the more likely v 's measurement is to match it. # A gaussian distribution def emission_prob ( u ): c = 1 / ( SIGMA_Z * math . sqrt ( 2 * math . pi )) return c * math . exp ( - great_circle_distance ( u . measurement , u ) ** 2 ) # A empirical distribution def transition_prob ( u , v ): c = 1 / BETA # Calculating route distance is expensive. # We will discuss how to reduce the number of calls to this function later. delta = math . abs ( route_distance ( u , v ) - great_circle_distance ( u . measurement , v . measurement )) return c * math . exp ( - delta ) A path is a list of edges. The probability of a path is defined as follows: def path_prob ( path ): assert path u , v = path [ 0 ] joint_prob = emission_prob ( u ) for u , v in path : joint_prob *= transition_prob ( u , v ) * emission_prob ( v ) return joint_prob The task is to find the most likely sequence over all possible sequences. For convenience's sake, we added two virtual nodes, the source node s and the target node t , and corresponding virtual edges to the graph with all emission and transition probabilities to be 1.0. The task hence becomes: find a path from s to t that maximizes the path probability.","title":"Graphical Model"},{"location":"meili/algorithms/#solutions","text":"To make the problem clear, a brute-force solution is given first. Given a graph represented by a Adjacency List , a source node and a target node, the procedure maximum_path_prob tries hard to list all paths in between and then selects the optimal one among them. def maximum_path_prob ( adjacency_list , s , t ): return max (( path_prob ( path ), path ) for path in all_paths ( adjacency_list , s , t ), key = lambda prob , path : prob ) # Generate all paths from s to t recursively def all_paths ( adjacency_list , s , t ): if s == t : return [[]] paths = [] for v in adjacency_list [ s ]: for path in all_paths ( adjacency_list , v , t ): paths . append ([( s , v )] + path ) return paths Viterbi Algorithm is usually used to find the most likely sequence in HMM. In the DAG the Viterbi Algorithm works like Breath-First-Search (BFS) algorithm that searches the target level by level. During the search/expansion, the Viterbi Algorithm also remembers each node's optimal solution (the optimal path from the source and the path probability) and use them to find optimal solutions for next level. def viterbi_search ( adjacency_list , s , t ): # Initialize joint probability for each node joint_prob = {} for u in adjacency_list : joint_prob [ u ] = 0 predecessor = {} queue = FIFOQueue () queue . push ( s ) joint_prob [ s ] = emission_prob ( s ) predecessor [ s ] = None while not queue . empty (): # Extract node u u = queue . pop () # Guarantee the optimal solution to u is found assert joint_prob [ u ] == maximum_path_prob ( adjacency_list , s , u )[ 0 ] if u == t : break for v in adjacency_list [ u ]: # Relaxation new_prob = joint_prob [ u ] * transition_prob ( u , v ) * emission_prob ( v ) if joint_prob [ v ] < new_prob : joint_prob [ v ] = new_prob predecessor [ v ] = u if v not in queue : queue . push ( v ) return joint_prob [ t ], construct_path ( predecessor , s , t ) The Viterbi Algorithm is the one used in the paper to find the optimal path, while another approach is to use Topological Sort in the DAG. Both algorithms have to explore all edges to find the path. However in the map-matching model exploring an edge is expensive. During the exploration of an edge (u, v) , it needs to find the shortest path between u and v in the road network for calculating its transition probability. Suppose that, given a sequence of S measurements and each measurement has average T states, the Viterbi Algorithm or the topological sort approach will traverse all edges i.e. do S * T * T times of shortest path calculations. This is not good, especially in dense urban areas where you can easily get a large average T . To reduce the number of transition probability calculations, we use the Dijkstra's algorithm to avoid extracting those unlikely nodes as many as possible. Like the Viterbi Algorithm, the Dijkstra's algorithm solves the problem in a Dynamic Programming approach. The advantage of the Dijkstra's algorithm is that it extracts nodes in a greedy way, i.e. extracts the most likely node every time. With this strategy, as soon as the target is extracted, the optimal solution is guaranteed to be found and thus the rest of nodes can be safely thrown away. Before applying the Dijkstra's algorithm we should notice that our objective is to find the most likely path, whereas the Dijkstra's algorithm is designed to solve shortest path problem, i.e. minimizing a certain objective. Therefore we need to transform the maximization problem to a minimization problem in the following way: With following prerequisites: T = transition_prob E = emission_prob lg = math . log10 assert 0 <= E ( u ) <= 1.0 and 0 <= T ( u , v ) <= 1.0 We are maximizing path_prob(path) among a set of paths. Expanding path_prob(path) we get: # For simplicity we ignored the last node product ( E ( u ) * T ( u , v ) for u , v in path ) which is equivalent to maximizing: lg ( product ( E ( u ) * T ( u , v ) for u , v in path )) # equivalent to sum ( lg ( E ( u )) + lg ( T ( u , v )) for u , v in path ) # because lg(a * b) == lg(a) + lg(b) which is equivalent to minimizing: - sum ( lg ( E ( u )) + lg ( T ( u , v )) for u , v in path ) # equivalent to sum ( - lg ( E ( u )) + - lg ( T ( u , v )) for u , v in path ) # Must be non-negative assert 0 <= - lg ( E ( u )) and 0 <= - lg ( T ( u , v )) After the transformation, the emission probability of a node turns to the node cost, and the transition probability of an edge turns to the edge cost. def node_cost ( u ): return - 1 * math . log10 ( emission_prob ( u )) def edge_cost ( u , v ): return - 1 * math . log10 ( transition_prob ( u , v )) The problem becomes find a path from s to t that minimizes sum(node_cost(u) + edge_cost(u, v) for u, v in path) which can be efficiently solved by the Dijkstra's algorithm. Thanks to the similarity to the Viterbi Algorithm, changing the FIFO queue in the viterbi_search procedure to a priority queue, and the probability calculation to the cost calculation should get you a rough Dijkstra based solution, a greedy, lazy but faster version of the Viterbi Algorithm.","title":"Solutions"},{"location":"meili/algorithms/#todo-experiments","text":"TODO comparison between the original Viterbi Algorithm and the Dijkstra Viterbi Algorithm, and comparisons with and without tweaks.","title":"TODO Experiments"},{"location":"meili/configuration/","text":"Configuration \u00b6 To launch a Meili service or instantiate a MapMatcherFactor , you need to pass it the Valhalla configuration file , which holds all configurations for Meili at the node meili . Map Matching Parameters \u00b6 The map matching parameters control accuracy and performance of the map matching process. All transport mode nodes ( auto , pedestrian , bicycle , multimodal ) can hold its own settings of these parameters, otherwise the setting in default node will be used. All transport modes can specify following parameters: Parameters Description Default sigma_ z A non-negative value to specify the GPS accuracy (the variance of the normal distribution) of an incoming GPS sequence. It is also used to weight emission costs of measurements. 4.07 beta A non-negative emprical value to weight the transition cost of two successive candidates. 3 max_route_distance_factor A non-negative value used to limit the routing search range which is the distance to next measurement multiplied by this factor. 5 max_route_time_factor A non-negative value used to limit the routing search range which is the time to next measurement multiplied by this factor. 5 breakage_distance A non-negative value. If two successive measurements are far than this distance, then connectivity in between will not be considered. 2000 (meters) interpolation_distance If two successive measurements are closer than this distance, then the later one will be interpolated into the matched route. 10 (meters) search_radius A non-negative value to specify the search radius (in meters) within which to search road candidates for each measurement. 50 (meters) max_search_radius Specify the upper bound of search_radius 100 (meters) turn_penalty_factor A non-negative value to penalize turns from one road segment to next. 0 (meters) Service Parameters \u00b6 The service parameters below are only used in the Meili service: Parameters Description Default mode Specify the default transport mode. multimodal customizable Specify which parameters are allowed to be customized by URL query parameters. [\"mode\", \"search_radius\"] verbose Control verbose output for debugging. false","title":"Configuration"},{"location":"meili/configuration/#configuration","text":"To launch a Meili service or instantiate a MapMatcherFactor , you need to pass it the Valhalla configuration file , which holds all configurations for Meili at the node meili .","title":"Configuration"},{"location":"meili/configuration/#map-matching-parameters","text":"The map matching parameters control accuracy and performance of the map matching process. All transport mode nodes ( auto , pedestrian , bicycle , multimodal ) can hold its own settings of these parameters, otherwise the setting in default node will be used. All transport modes can specify following parameters: Parameters Description Default sigma_ z A non-negative value to specify the GPS accuracy (the variance of the normal distribution) of an incoming GPS sequence. It is also used to weight emission costs of measurements. 4.07 beta A non-negative emprical value to weight the transition cost of two successive candidates. 3 max_route_distance_factor A non-negative value used to limit the routing search range which is the distance to next measurement multiplied by this factor. 5 max_route_time_factor A non-negative value used to limit the routing search range which is the time to next measurement multiplied by this factor. 5 breakage_distance A non-negative value. If two successive measurements are far than this distance, then connectivity in between will not be considered. 2000 (meters) interpolation_distance If two successive measurements are closer than this distance, then the later one will be interpolated into the matched route. 10 (meters) search_radius A non-negative value to specify the search radius (in meters) within which to search road candidates for each measurement. 50 (meters) max_search_radius Specify the upper bound of search_radius 100 (meters) turn_penalty_factor A non-negative value to penalize turns from one road segment to next. 0 (meters)","title":"Map Matching Parameters"},{"location":"meili/configuration/#service-parameters","text":"The service parameters below are only used in the Meili service: Parameters Description Default mode Specify the default transport mode. multimodal customizable Specify which parameters are allowed to be customized by URL query parameters. [\"mode\", \"search_radius\"] verbose Control verbose output for debugging. false","title":"Service Parameters"},{"location":"meili/implementation_details/","text":"Implementation Details \u00b6 Overview \u00b6 Measurements / | \\ | | | V V V +-------------------------------------------------------+ | | | [ Candidate Query ] | | | | / | \\ | | Candidate | | | Candidate | <-- Map Matcher | cluster V V V cluster | | | | [ Map Matching ] <--- [ Viterbi Search ] | | \\__ [ Routing ] | | / | \\ | +-------------|------|-------|--------------------------+ V V V Match Results Candidate Query \u00b6 valhalla/meili/candidate_query.h Given a position and a radius, this component finds all underlying road segments lying within this radius around the position. For every incoming measurement we need to perform such a query to find a cluster of candidates around it, which will be used as input to the map matching component. The spatial query algorithm used in Meili is simple and efficient. Before the query, we spatially divide a road network (i.e. a graph tile) into a grid of 500x500 ( grid.size ) squares. Then we precompute which road segments each square intersects, and add them to the square. The query is simply to retrieve all road segments from the squares that the radius range covers. See [this slide] (http://www.cs.princeton.edu/courses/archive/fall05/cos226/lectures/geosearch.pdf) at page 7 for details. Map Matching \u00b6 valhalla/meili/map_matching.h The MapMatching class is the core component that implements the HMM-based map matching algorithm. It takes a sequence of candidate clusters as input, and picks one candidate from each cluster to form the most likely sequence of candidates (Viterbi path). It delegates the actual search task to the Viterbi Search module, but it defines how to quantify the likelihood. Concretely speaking it inherits from the ViterbiSearch class and implements its virtual costing functions namely ViterbiSearch::TransitionCost and ViterbiSearch::EmissionCost . State \u00b6 valhalla/meili/map_matching.h When feeding a cluster of candidates into the component, an unique ID and an identical time will be attached to each candidate. The ID identifies a state, whereas the time tells from which cluster a candidate comes. Internally we name the wrapped candidate as a state . Viterbi Search \u00b6 valhalla/meili/viterbi_search.h This module focus on finding the most likely sequence (Viterbi path) in a trellis graph in context of HMM model. It provides an uniform interface IViterbiSearch and two implementations: NaiveViterbiSearch implements the naive Viterbi Algorithm and ViterbiSearch implements the lazy Dijkstra-based Viterbi Algorithm. Both implementations are able to find the optimal path. NaiveViterbiSearch is able to work with both maximum and minimum objectives, whereas ViterbiSearch only works with minimum objectives as it's Dijkstra-based. We derive MapMatching from ViterbiSearch for it has better performance in theory. You can develop your own map matching algorithm to work with other road network sources (e.g. pgRouting) as MapMatching does: inherit from either implementation (depending on your objectives) and implement IViterbiSearch::TransitionCost and IViterbiSearch::EmissionCost . The details about these algorithms are described here . Routing \u00b6 valhalla/meili/routing.h This module focuses on finding the shortest path (SP) between two candidates in the road network. The path distance is required in the transition cost calculation ( MapMatching::TransitionCost ). The path will be the inferred path between their respective measurements if both candidates are picked as part of the most likely sequence. The SP algorithm is based on AStar, and it routes from single origin to multiple destinations. AStar fits here because the destination set is a cluster of candidates around their measurement (provided by the candidate query above). So the algorithm can estimate the heuristic cost by targeting at the measurement's position. The SP algorithm doesn't construct the paths for you. Instead it gives back the search tree (i.e. LabelSet ) directly. Then we store the search tree in the origin state for path construction later. Turn cost between road segments along the path is aggregated during the path finding. This cost contributes as an independent part of the transition cost ( MapMatching::TransitionCost ) to penalize paths with turns. Unlike path algorithms in Thor, the SP algorithm scans nodes instead of edges, so turn restriction is not considered here. Viterbi Search VS. Routing \u00b6 It is worth mentioning that they share some similarities but also some differences. Both are finding optimal paths but different objectives (most likely sequence vs. shortest distance path). Both are based on the Dijkstra algorithm (thank you Dijkstra!) but different graphical models (trellis graph vs. road network). Map Matcher \u00b6 valhalla/meili/map_matcher.h A map matcher is a facade component that connects the candidate query component and map matching component, and provides simple interfaces for use. As shown in the overview, you can think of it as a black box that takes measurements as input and gives back match results. In addition, it does some internal filtering work before measurements feeding into the map matching component. Interpolation \u00b6 valhalla/meili/map_matcher.h One thing, which is not shown in the overview, is that not all incoming measurements are sent to the map matching component. If some successive measurements are too spatially close to each other, then only the first measurement will be sent; the rest of measurements will be interpolated into the match route. For example, assume the numbers below represent a sequence of measurements (in order by numbers) along a straight road, and each space is one meter long. If the interpolation_distance is set to 10 meters, we will only send measurements 1* , 4* and 7* because they are farther apart than 10 meters; measurements 2 and 3 will be interpolated into the route from 1* to 4* ; measurement 5 will be interpolated into the route from 4* to 7* , and so on. 1* 2 3 4* 5 8 7* 9 10 The first rationale of this design is that for high-density traces it can reduce the number of measurements involved in map matching. Secondly if two successive measurements are too close, the later one is possible to be found at the upstream of the earlier one due to noise error. This error can result in wrong path inference in some modes such as auto , bicycle where U-turns are forbidden. For example, the true location of 8 should be at the downstream (right side) of 7* , but the noise can shift it to upstream (left side). In auto mode, this slight shift can result in either wrong path or no path found from 7* to 8 . If we interpolate measurement 8 instead of map matching it, this issue can be avoided. Match Result \u00b6 valhalla/meili/match_result.h Each measurement corresponds to a match result. The match result tells you on which road segment the measurement gets matched or interpolated, the match position, and the distance to the position, etc. The corresponding state ID is attached to the result if the measurement gets matched. Since we have stored route search trees to states, you can find the state with this ID and reconstruct the route with the helpers from valhalla/meili/match_route.h . Map Matcher Factory \u00b6 valhalla/meili/map_matcher_factory.h The map matcher factory can facilitate map matcher creation. Pass it the Valhalla configuration and the travel mode, it reads the parameters and creates a map matcher for this mode. The factory also maintains a graph tile reader instance and a candidate query instance and shares them among all its matchers. Because of the data sharing it is cheap to create a map matcher from a factory. Note that both factory and matcher are not thread-safe.","title":"Implementation Details"},{"location":"meili/implementation_details/#implementation-details","text":"","title":"Implementation Details"},{"location":"meili/implementation_details/#overview","text":"Measurements / | \\ | | | V V V +-------------------------------------------------------+ | | | [ Candidate Query ] | | | | / | \\ | | Candidate | | | Candidate | <-- Map Matcher | cluster V V V cluster | | | | [ Map Matching ] <--- [ Viterbi Search ] | | \\__ [ Routing ] | | / | \\ | +-------------|------|-------|--------------------------+ V V V Match Results","title":"Overview"},{"location":"meili/implementation_details/#candidate-query","text":"valhalla/meili/candidate_query.h Given a position and a radius, this component finds all underlying road segments lying within this radius around the position. For every incoming measurement we need to perform such a query to find a cluster of candidates around it, which will be used as input to the map matching component. The spatial query algorithm used in Meili is simple and efficient. Before the query, we spatially divide a road network (i.e. a graph tile) into a grid of 500x500 ( grid.size ) squares. Then we precompute which road segments each square intersects, and add them to the square. The query is simply to retrieve all road segments from the squares that the radius range covers. See [this slide] (http://www.cs.princeton.edu/courses/archive/fall05/cos226/lectures/geosearch.pdf) at page 7 for details.","title":"Candidate Query"},{"location":"meili/implementation_details/#map-matching","text":"valhalla/meili/map_matching.h The MapMatching class is the core component that implements the HMM-based map matching algorithm. It takes a sequence of candidate clusters as input, and picks one candidate from each cluster to form the most likely sequence of candidates (Viterbi path). It delegates the actual search task to the Viterbi Search module, but it defines how to quantify the likelihood. Concretely speaking it inherits from the ViterbiSearch class and implements its virtual costing functions namely ViterbiSearch::TransitionCost and ViterbiSearch::EmissionCost .","title":"Map Matching"},{"location":"meili/implementation_details/#state","text":"valhalla/meili/map_matching.h When feeding a cluster of candidates into the component, an unique ID and an identical time will be attached to each candidate. The ID identifies a state, whereas the time tells from which cluster a candidate comes. Internally we name the wrapped candidate as a state .","title":"State"},{"location":"meili/implementation_details/#viterbi-search","text":"valhalla/meili/viterbi_search.h This module focus on finding the most likely sequence (Viterbi path) in a trellis graph in context of HMM model. It provides an uniform interface IViterbiSearch and two implementations: NaiveViterbiSearch implements the naive Viterbi Algorithm and ViterbiSearch implements the lazy Dijkstra-based Viterbi Algorithm. Both implementations are able to find the optimal path. NaiveViterbiSearch is able to work with both maximum and minimum objectives, whereas ViterbiSearch only works with minimum objectives as it's Dijkstra-based. We derive MapMatching from ViterbiSearch for it has better performance in theory. You can develop your own map matching algorithm to work with other road network sources (e.g. pgRouting) as MapMatching does: inherit from either implementation (depending on your objectives) and implement IViterbiSearch::TransitionCost and IViterbiSearch::EmissionCost . The details about these algorithms are described here .","title":"Viterbi Search"},{"location":"meili/implementation_details/#routing","text":"valhalla/meili/routing.h This module focuses on finding the shortest path (SP) between two candidates in the road network. The path distance is required in the transition cost calculation ( MapMatching::TransitionCost ). The path will be the inferred path between their respective measurements if both candidates are picked as part of the most likely sequence. The SP algorithm is based on AStar, and it routes from single origin to multiple destinations. AStar fits here because the destination set is a cluster of candidates around their measurement (provided by the candidate query above). So the algorithm can estimate the heuristic cost by targeting at the measurement's position. The SP algorithm doesn't construct the paths for you. Instead it gives back the search tree (i.e. LabelSet ) directly. Then we store the search tree in the origin state for path construction later. Turn cost between road segments along the path is aggregated during the path finding. This cost contributes as an independent part of the transition cost ( MapMatching::TransitionCost ) to penalize paths with turns. Unlike path algorithms in Thor, the SP algorithm scans nodes instead of edges, so turn restriction is not considered here.","title":"Routing"},{"location":"meili/implementation_details/#viterbi-search-vs-routing","text":"It is worth mentioning that they share some similarities but also some differences. Both are finding optimal paths but different objectives (most likely sequence vs. shortest distance path). Both are based on the Dijkstra algorithm (thank you Dijkstra!) but different graphical models (trellis graph vs. road network).","title":"Viterbi Search VS. Routing"},{"location":"meili/implementation_details/#map-matcher","text":"valhalla/meili/map_matcher.h A map matcher is a facade component that connects the candidate query component and map matching component, and provides simple interfaces for use. As shown in the overview, you can think of it as a black box that takes measurements as input and gives back match results. In addition, it does some internal filtering work before measurements feeding into the map matching component.","title":"Map Matcher"},{"location":"meili/implementation_details/#interpolation","text":"valhalla/meili/map_matcher.h One thing, which is not shown in the overview, is that not all incoming measurements are sent to the map matching component. If some successive measurements are too spatially close to each other, then only the first measurement will be sent; the rest of measurements will be interpolated into the match route. For example, assume the numbers below represent a sequence of measurements (in order by numbers) along a straight road, and each space is one meter long. If the interpolation_distance is set to 10 meters, we will only send measurements 1* , 4* and 7* because they are farther apart than 10 meters; measurements 2 and 3 will be interpolated into the route from 1* to 4* ; measurement 5 will be interpolated into the route from 4* to 7* , and so on. 1* 2 3 4* 5 8 7* 9 10 The first rationale of this design is that for high-density traces it can reduce the number of measurements involved in map matching. Secondly if two successive measurements are too close, the later one is possible to be found at the upstream of the earlier one due to noise error. This error can result in wrong path inference in some modes such as auto , bicycle where U-turns are forbidden. For example, the true location of 8 should be at the downstream (right side) of 7* , but the noise can shift it to upstream (left side). In auto mode, this slight shift can result in either wrong path or no path found from 7* to 8 . If we interpolate measurement 8 instead of map matching it, this issue can be avoided.","title":"Interpolation"},{"location":"meili/implementation_details/#match-result","text":"valhalla/meili/match_result.h Each measurement corresponds to a match result. The match result tells you on which road segment the measurement gets matched or interpolated, the match position, and the distance to the position, etc. The corresponding state ID is attached to the result if the measurement gets matched. Since we have stored route search trees to states, you can find the state with this ID and reconstruct the route with the helpers from valhalla/meili/match_route.h .","title":"Match Result"},{"location":"meili/implementation_details/#map-matcher-factory","text":"valhalla/meili/map_matcher_factory.h The map matcher factory can facilitate map matcher creation. Pass it the Valhalla configuration and the travel mode, it reads the parameters and creates a map matcher for this mode. The factory also maintains a graph tile reader instance and a candidate query instance and shares them among all its matchers. Because of the data sharing it is cheap to create a map matcher from a factory. Note that both factory and matcher are not thread-safe.","title":"Map Matcher Factory"},{"location":"meili/library_api/","text":"Library API \u00b6 The API is still in testing and will be changed any time. Any suggestions are welcome to share at GitHub Issues . TODO The API listed here is not complete but ready for simple use. Measurement \u00b6 A Measurement object is a measured point read from GPS devices and it is usually inaccurate and noisy therefore needed to be matched. Extra attributes such as accuracy and search radius can be optionally attached to this object to help improve matching performance. #include <valhalla/meili/measurement.h> using namespace valhalla ; // Constructor const midgard :: PointLL lnglat ( 13.44 , 53.67 ); // the noisy location read from GPS device float gps_accuracy = 4.07 , // GPS accuracy in meters search_radius = 30 ; // in the area specified by the radius in meters search road candidates meili :: Measurement ( lnglat , gps_accuracy , search_radius ); See valhalla/meili/measurement.h for more information. Map Matcher Factory \u00b6 A MapMatcherFactory object produces MapMatcher objects for a specific transport mode. Other than that, it also manages in-memory data structures (e.g. tiles) shared among its matchers for you. It is recommended to instantiate it only once; but you have to keep it until all its matchers get destroyed. Pass it a valid configuration object, otherwise it throws std::invalid_argument . #include <valhalla/meili/map_matcher_factory.h> boost :: property_tree :: ptree config ; boost :: property_tree :: json_parser read ( config , \"conf/valhalla.json\" ); // Constructor meili :: MapMatcherFactory ( const boost :: property_tree :: ptree & config ); To create a MapMatcher object of a specific transport mode: // Possibly throw std::invalid_argument if invalid parameters are // found in this mode's configuration meili :: MapMatcher * meili::MapMatcherFactory::Create ( const std :: string & mode_name ); You should take care of the raw MapMatcher pointer returned by the factory. Map Matcher \u00b6 MapMatcher object is responsible for matching sequences to the road network. It is created by MapMatcherFactory . To match a sequence offline: std :: vector < MatchResult > meili :: MapMatcher :: OfflineMatch ( const std :: vector < Measurement >& sequence ); It returns a sequence of MatchResult objects corresponding to the sequence of Measurement objects. Match Result \u00b6 A MatchResult object contains information about which road and where the corresponding measurement is matched, and how to construct the route from previous result. It is usually generated by a MapMatcher object as one result of a sequential matching procedure. Here are some attributes: // Matched coordinate const valhalla :: midgard :: PointLL & meili::MatchResult::lnglat (); // Distance from measurement to the matched coordinate float meili::MatchResult::distance (); // GraphId identify edges and nodes internally in Valhalla tiled data valhalla :: baldr :: GraphId & meili::MatchResult::edgeid (); See the header file valhalla/meili/match_result.h for more information.","title":"Library API"},{"location":"meili/library_api/#library-api","text":"The API is still in testing and will be changed any time. Any suggestions are welcome to share at GitHub Issues . TODO The API listed here is not complete but ready for simple use.","title":"Library API"},{"location":"meili/library_api/#measurement","text":"A Measurement object is a measured point read from GPS devices and it is usually inaccurate and noisy therefore needed to be matched. Extra attributes such as accuracy and search radius can be optionally attached to this object to help improve matching performance. #include <valhalla/meili/measurement.h> using namespace valhalla ; // Constructor const midgard :: PointLL lnglat ( 13.44 , 53.67 ); // the noisy location read from GPS device float gps_accuracy = 4.07 , // GPS accuracy in meters search_radius = 30 ; // in the area specified by the radius in meters search road candidates meili :: Measurement ( lnglat , gps_accuracy , search_radius ); See valhalla/meili/measurement.h for more information.","title":"Measurement"},{"location":"meili/library_api/#map-matcher-factory","text":"A MapMatcherFactory object produces MapMatcher objects for a specific transport mode. Other than that, it also manages in-memory data structures (e.g. tiles) shared among its matchers for you. It is recommended to instantiate it only once; but you have to keep it until all its matchers get destroyed. Pass it a valid configuration object, otherwise it throws std::invalid_argument . #include <valhalla/meili/map_matcher_factory.h> boost :: property_tree :: ptree config ; boost :: property_tree :: json_parser read ( config , \"conf/valhalla.json\" ); // Constructor meili :: MapMatcherFactory ( const boost :: property_tree :: ptree & config ); To create a MapMatcher object of a specific transport mode: // Possibly throw std::invalid_argument if invalid parameters are // found in this mode's configuration meili :: MapMatcher * meili::MapMatcherFactory::Create ( const std :: string & mode_name ); You should take care of the raw MapMatcher pointer returned by the factory.","title":"Map Matcher Factory"},{"location":"meili/library_api/#map-matcher","text":"MapMatcher object is responsible for matching sequences to the road network. It is created by MapMatcherFactory . To match a sequence offline: std :: vector < MatchResult > meili :: MapMatcher :: OfflineMatch ( const std :: vector < Measurement >& sequence ); It returns a sequence of MatchResult objects corresponding to the sequence of Measurement objects.","title":"Map Matcher"},{"location":"meili/library_api/#match-result","text":"A MatchResult object contains information about which road and where the corresponding measurement is matched, and how to construct the route from previous result. It is usually generated by a MapMatcher object as one result of a sequential matching procedure. Here are some attributes: // Matched coordinate const valhalla :: midgard :: PointLL & meili::MatchResult::lnglat (); // Distance from measurement to the matched coordinate float meili::MatchResult::distance (); // GraphId identify edges and nodes internally in Valhalla tiled data valhalla :: baldr :: GraphId & meili::MatchResult::edgeid (); See the header file valhalla/meili/match_result.h for more information.","title":"Match Result"},{"location":"meili/overview/","text":"Overview \u00b6 Meili is a namespace within valhalla which is responsible for providing map matching functionality in the library. This scope of this functionality is essentially limited to the approach defined in the siminole microsoft paper outlining the technique: https://www.microsoft.com/en-us/research/publication/hidden-markov-map-matching-noise-sparseness/ The important thing to note here is that Meili is not responsible for packaging the results of the map match into a route path as defined in our primary routing module Thor. Thus there is a non-trivial amount of effort to take the output of Meili and convert it to the expected format. Meili Code Layout \u00b6 AppendMeasurements \u00b6 The first step Meili does is decide which tracepoints its going to map match. You might think that it map matches every point (and it does) but it doesnt actually do the routing computation using every point if it can avoid it. We allow specifying an interpolation distance which groups close together points such that only one will be used and the rest will be interpolated onto the map match after it is performed. This not only speeds up the code but it also avoids problems with GPS jitter of stationary objects. This work is done in the function AppendMeasurements which append tracepoints into what can be thought of as a matrix. Whats in this matrix? For every input point that AppendMeasurements decides it will use in the routing calculations a column is made in the matrix. Each column can have 1 or more rows but they will not all have the same number of rows. Each row represents an edge candidate for a given trace point. An edge candidate is a snap point along an edge in the graph within the radius of the input trace point. The above is an image of the 4 magenta edge candidates for an input trace point with a 50m radius. AppendMeasurements eventually calls down into CandidateQuery::Query to get the list of candidates for a given trace point. It should be noted that CandidateQuery provides the same functionality Loki::Search does however there are some key differences. The main difference is that CandidateQuery keeps a fine resolution in-memory spatial index/cache of route network geometries. What this means is that it can have much higher throughput (once the cache is warm) than loki for high numbers of points. This is a key difference between map matching and routing use-cases. In routing we dont expect 1000s of way points but GPS traces are frequently reported at 1hz. Which means a 15 minute trace is already close to 1000 points. In the future we'd like to remove CandidateQuery and replace it with functionality from Loki::Search but at this time performance considerations keep us from doing so. Viterbi \u00b6 Viterbi is a dynamic programming algorithm used to find paths (eg. Markov chains) through a hidden state diagram such as a hidden Markov model. Read more about it here: https://en.wikipedia.org/wiki/Viterbi_algorithm. Within Meili we use the algorithm to determine the highest probability map match while doing the least number of routing calculations possible. You can think of the matrix described above as a series of nodes in a state diagram. Each row in each column has a connection to each row in the prevoius and next column in the diagram. We refer to these unique column/row pairs as State s through out the code and each is given a StateId which represents which column (0..n) and which candidate (0..m) it refers to. In the figure below candidates 0 1 and 2 are in column 0 whereas candidates 3, 4, 5 and 6 are in column 1. ViterbiSearch is run by iterating over pairs of columns and running routes between their candidates (rows). While doing so we measure two metrics, emission and transition cost. These costs are inversely related to the probabilities in the hidden markov model. Emmission cost is simply a measure of how close to the road network a given candidate is where as transition cost is a function of network distance along the route between two candidates in the graph. At the end of the viterbi search a highest probability (lowest cost) path, ie a sequence of StateId s, is returned. There may or may not be sections of the path where no route was possible between a given pair of State s or even between columns (all pairs of candidates in 2 adjacent columns). Match Points \u00b6 After a path through the state diagram as been computed we need to get the first part of the output from Meili which is to say which candidates were used in the final path. To do that we call FindMatchResults which loops over the states and an returns a vector of MatchResult objects. The MatchResult contains information about which edge it matched to, what the lat,lon is once snapped to the edge, the distance along the edge as a percentage among other things. This is useful because the final service APIs mapmatching output contains this metadata, either indirectly via a origin/destination location or directly in trace_attributes or the osrm flavored output. Interpolation \u00b6 The MatchResult s that we got back only included those points which AppendMeasurements deemed necessary for the routing calculation. That means that for some of the input points, as mentioned earlier, we didnt actually attach a column to them or any states. This is kind of what it looks like in an ascii diagram: p1p2------p3-------p4p5p6-----------p7--------------p8-----------p9p10 In the above {p2, p5, p6, p9} are all interpolated because they are close in distance to a prior point or in p9 s case close to the last point which cannot be interpolated. So what we do next is we loop over pairs of states again and if between those two states there were unused (ie interpolated) input points then we project each of those points in succession onto the route between them. Using the example above, if we found a route between p4 and p7, then we would project p5 and p6 onto this route geometry to compute their MatchResults . Interpolation also gaurantees that sequence ordering remains unchanged, ie p4 comes before p5 comes before p6 comes before p7 in the final route geometry. Route Building \u00b6 Next we get the second part of Meil's output which is the actual path through the graph that was taken. We compute this with a call to ConstructRoute . Construct route uses the States to get at sequences of edges stored as a collection of EdgeLabel s in a LabelSet . The LableSet contains all the edge labels a graph expansion saw. For a given State we know which was the last label it saw when it reached the destination State . So to get the route out we simply follow the chain of EdgeLabel s back to the origin State . Its like a linkedlist but without pointers, instead it uses indices into the LabelSet . The MergeRoute function is responsible for this recovery of a path between two states. From these EdgeLabels we make a vector of EdgeSegment objects, which is the final object that is returned. The EdgeSegment stores information about which edge in the graph it is, how much of it was used and what was the first and last MatchResult that got matched onto this EdgeSegment . It also contains information about whether or not there is a discontinuity after this EdgeSegment . As described before a discontinuity occurs when no paths for any candidates can be found from between two columns. During this process we also take care to cut EdgeSegment s where a MatchResult is marked as a break or break_through location. These types of locations denote where we want to have route legs in the final output. So that we don't have to break them down later in serialization, we make sure to split edges when constructing the route. Alternatives \u00b6 Meili supports the notion of alternatives. The API calls this \"best_paths\" but should be refactored to use \"alternatives\". What this allows a user to do is get the top k most probable paths with a couple caveats. The first caveat is that if there is a discontinuity in one of the results we will not return any more results after that. So if the first match had a discontinuity you'll only get 1 result even if you asked for 2. The second caveat is that redundant paths are not returned. What is a redundant path? Its a path that has already been seen in a previous result. Technically this means that the sequence of EdgeSegments has already been seen. Why would this happen? It is common that a MatchResult has two candidates, but no matter which one is used, the sequence of edges in the path remains the same. Basically the MatchResults may move around but the path is the same. This commonly occurs at intersections where one candidate may be some distance along the edge and the alternative candiate will be at the end of the previous edge. Either way both edges are on the path, the path didn't materially change. Complications \u00b6 The biggest complication in map matching by far is that of dealing with node snapped candidates. That is to say when an input trace points closest point on the graph is a node in the graph connecting 2 or more edges. This type of candidate presents 2 problems. The first is one of performance. You could say, no problem we'll just put a candidate for every edge at that node, but this is very wasteful as each candidate added increases the number of permutations of routes that viterbi will cause to be computed. So instead of doing that we have special logic in the router there handles node snapped candidates as a single candidate. The second problem with node candidates is that of ambiguity. Because a node does not refer to an edge but all of our other datastructures do ( MatchResult and EdgeSegment ) we end up needing to put a bunch of special case logic to patch things up if they are happening at a node. Specifically when we have a trace point that is the split between two legs in a route, we end up having the end of one leg on one edge and the beginning of the next leg on another edge and using the same MatchResult (which only stores one edge reference) means that it disagrees with one of the legs. Thor Contract \u00b6 Meili itself does not have an external API. It kind of used to but has since been refactored to be accessed via the rest of our routing APIs. What this means is that it must fulfill the same contract that Thor does. That contract consists of a series of Location s with the chosen candidate for each Location getting filled out (in this case we translate the MatchResult into this) as well as a path which is a series of PathInfo s representing the edgs on the path and their cost/duration. The bulk of what has been described about Meili above was refering to its main entry point OfflineMatch (offline refers to the type of algorithm, see here: https://en.wikipedia.org/wiki/Online_algorithm). Thor must take the results of this function which, as described earlier, is a series of MatchResults and a series of EdgeSegments and convert them. This conversion takes place first via FormPath (every path finding algorithm implements one of these) and then via a call to TripLegBuilder::Build for each leg of the route. FormPath builds the vector of PathInfo objects from the EdgeSegments . The MatchResults are used to build origin and destination Location s. The PathInfo s and Location s are then sent to TripLegBuilder::Build as with every other routing operation.","title":"Overview"},{"location":"meili/overview/#overview","text":"Meili is a namespace within valhalla which is responsible for providing map matching functionality in the library. This scope of this functionality is essentially limited to the approach defined in the siminole microsoft paper outlining the technique: https://www.microsoft.com/en-us/research/publication/hidden-markov-map-matching-noise-sparseness/ The important thing to note here is that Meili is not responsible for packaging the results of the map match into a route path as defined in our primary routing module Thor. Thus there is a non-trivial amount of effort to take the output of Meili and convert it to the expected format.","title":"Overview"},{"location":"meili/overview/#meili-code-layout","text":"","title":"Meili Code Layout"},{"location":"meili/overview/#appendmeasurements","text":"The first step Meili does is decide which tracepoints its going to map match. You might think that it map matches every point (and it does) but it doesnt actually do the routing computation using every point if it can avoid it. We allow specifying an interpolation distance which groups close together points such that only one will be used and the rest will be interpolated onto the map match after it is performed. This not only speeds up the code but it also avoids problems with GPS jitter of stationary objects. This work is done in the function AppendMeasurements which append tracepoints into what can be thought of as a matrix. Whats in this matrix? For every input point that AppendMeasurements decides it will use in the routing calculations a column is made in the matrix. Each column can have 1 or more rows but they will not all have the same number of rows. Each row represents an edge candidate for a given trace point. An edge candidate is a snap point along an edge in the graph within the radius of the input trace point. The above is an image of the 4 magenta edge candidates for an input trace point with a 50m radius. AppendMeasurements eventually calls down into CandidateQuery::Query to get the list of candidates for a given trace point. It should be noted that CandidateQuery provides the same functionality Loki::Search does however there are some key differences. The main difference is that CandidateQuery keeps a fine resolution in-memory spatial index/cache of route network geometries. What this means is that it can have much higher throughput (once the cache is warm) than loki for high numbers of points. This is a key difference between map matching and routing use-cases. In routing we dont expect 1000s of way points but GPS traces are frequently reported at 1hz. Which means a 15 minute trace is already close to 1000 points. In the future we'd like to remove CandidateQuery and replace it with functionality from Loki::Search but at this time performance considerations keep us from doing so.","title":"AppendMeasurements"},{"location":"meili/overview/#viterbi","text":"Viterbi is a dynamic programming algorithm used to find paths (eg. Markov chains) through a hidden state diagram such as a hidden Markov model. Read more about it here: https://en.wikipedia.org/wiki/Viterbi_algorithm. Within Meili we use the algorithm to determine the highest probability map match while doing the least number of routing calculations possible. You can think of the matrix described above as a series of nodes in a state diagram. Each row in each column has a connection to each row in the prevoius and next column in the diagram. We refer to these unique column/row pairs as State s through out the code and each is given a StateId which represents which column (0..n) and which candidate (0..m) it refers to. In the figure below candidates 0 1 and 2 are in column 0 whereas candidates 3, 4, 5 and 6 are in column 1. ViterbiSearch is run by iterating over pairs of columns and running routes between their candidates (rows). While doing so we measure two metrics, emission and transition cost. These costs are inversely related to the probabilities in the hidden markov model. Emmission cost is simply a measure of how close to the road network a given candidate is where as transition cost is a function of network distance along the route between two candidates in the graph. At the end of the viterbi search a highest probability (lowest cost) path, ie a sequence of StateId s, is returned. There may or may not be sections of the path where no route was possible between a given pair of State s or even between columns (all pairs of candidates in 2 adjacent columns).","title":"Viterbi"},{"location":"meili/overview/#match-points","text":"After a path through the state diagram as been computed we need to get the first part of the output from Meili which is to say which candidates were used in the final path. To do that we call FindMatchResults which loops over the states and an returns a vector of MatchResult objects. The MatchResult contains information about which edge it matched to, what the lat,lon is once snapped to the edge, the distance along the edge as a percentage among other things. This is useful because the final service APIs mapmatching output contains this metadata, either indirectly via a origin/destination location or directly in trace_attributes or the osrm flavored output.","title":"Match Points"},{"location":"meili/overview/#interpolation","text":"The MatchResult s that we got back only included those points which AppendMeasurements deemed necessary for the routing calculation. That means that for some of the input points, as mentioned earlier, we didnt actually attach a column to them or any states. This is kind of what it looks like in an ascii diagram: p1p2------p3-------p4p5p6-----------p7--------------p8-----------p9p10 In the above {p2, p5, p6, p9} are all interpolated because they are close in distance to a prior point or in p9 s case close to the last point which cannot be interpolated. So what we do next is we loop over pairs of states again and if between those two states there were unused (ie interpolated) input points then we project each of those points in succession onto the route between them. Using the example above, if we found a route between p4 and p7, then we would project p5 and p6 onto this route geometry to compute their MatchResults . Interpolation also gaurantees that sequence ordering remains unchanged, ie p4 comes before p5 comes before p6 comes before p7 in the final route geometry.","title":"Interpolation"},{"location":"meili/overview/#route-building","text":"Next we get the second part of Meil's output which is the actual path through the graph that was taken. We compute this with a call to ConstructRoute . Construct route uses the States to get at sequences of edges stored as a collection of EdgeLabel s in a LabelSet . The LableSet contains all the edge labels a graph expansion saw. For a given State we know which was the last label it saw when it reached the destination State . So to get the route out we simply follow the chain of EdgeLabel s back to the origin State . Its like a linkedlist but without pointers, instead it uses indices into the LabelSet . The MergeRoute function is responsible for this recovery of a path between two states. From these EdgeLabels we make a vector of EdgeSegment objects, which is the final object that is returned. The EdgeSegment stores information about which edge in the graph it is, how much of it was used and what was the first and last MatchResult that got matched onto this EdgeSegment . It also contains information about whether or not there is a discontinuity after this EdgeSegment . As described before a discontinuity occurs when no paths for any candidates can be found from between two columns. During this process we also take care to cut EdgeSegment s where a MatchResult is marked as a break or break_through location. These types of locations denote where we want to have route legs in the final output. So that we don't have to break them down later in serialization, we make sure to split edges when constructing the route.","title":"Route Building"},{"location":"meili/overview/#alternatives","text":"Meili supports the notion of alternatives. The API calls this \"best_paths\" but should be refactored to use \"alternatives\". What this allows a user to do is get the top k most probable paths with a couple caveats. The first caveat is that if there is a discontinuity in one of the results we will not return any more results after that. So if the first match had a discontinuity you'll only get 1 result even if you asked for 2. The second caveat is that redundant paths are not returned. What is a redundant path? Its a path that has already been seen in a previous result. Technically this means that the sequence of EdgeSegments has already been seen. Why would this happen? It is common that a MatchResult has two candidates, but no matter which one is used, the sequence of edges in the path remains the same. Basically the MatchResults may move around but the path is the same. This commonly occurs at intersections where one candidate may be some distance along the edge and the alternative candiate will be at the end of the previous edge. Either way both edges are on the path, the path didn't materially change.","title":"Alternatives"},{"location":"meili/overview/#complications","text":"The biggest complication in map matching by far is that of dealing with node snapped candidates. That is to say when an input trace points closest point on the graph is a node in the graph connecting 2 or more edges. This type of candidate presents 2 problems. The first is one of performance. You could say, no problem we'll just put a candidate for every edge at that node, but this is very wasteful as each candidate added increases the number of permutations of routes that viterbi will cause to be computed. So instead of doing that we have special logic in the router there handles node snapped candidates as a single candidate. The second problem with node candidates is that of ambiguity. Because a node does not refer to an edge but all of our other datastructures do ( MatchResult and EdgeSegment ) we end up needing to put a bunch of special case logic to patch things up if they are happening at a node. Specifically when we have a trace point that is the split between two legs in a route, we end up having the end of one leg on one edge and the beginning of the next leg on another edge and using the same MatchResult (which only stores one edge reference) means that it disagrees with one of the legs.","title":"Complications"},{"location":"meili/overview/#thor-contract","text":"Meili itself does not have an external API. It kind of used to but has since been refactored to be accessed via the rest of our routing APIs. What this means is that it must fulfill the same contract that Thor does. That contract consists of a series of Location s with the chosen candidate for each Location getting filled out (in this case we translate the MatchResult into this) as well as a path which is a series of PathInfo s representing the edgs on the path and their cost/duration. The bulk of what has been described about Meili above was refering to its main entry point OfflineMatch (offline refers to the type of algorithm, see here: https://en.wikipedia.org/wiki/Online_algorithm). Thor must take the results of this function which, as described earlier, is a series of MatchResults and a series of EdgeSegments and convert them. This conversion takes place first via FormPath (every path finding algorithm implements one of these) and then via a call to TripLegBuilder::Build for each leg of the route. FormPath builds the vector of PathInfo objects from the EdgeSegments . The MatchResults are used to build origin and destination Location s. The PathInfo s and Location s are then sent to TripLegBuilder::Build as with every other routing operation.","title":"Thor Contract"},{"location":"meili/service_api/","text":"Service API \u00b6 The API is still in testing and will be changed any time. Any suggestions are welcome to share at GitHub Issues . Request \u00b6 The service accepts a GeoJSON feature or geometry (of type MultiPoint or LineString ) in the POST request body. URL Parameter Description Default mode Transport mode of the sequence. Possible modes are: auto , bycicle , pedestrian and multimodal . multimodal search_radius A numeric value in range [0, 100] to specify a radius (in meters) within which to search road candidates for each measurement. 40 Specifying a transport mode can limit the type of roads to match (e.g. auto will only consider drivable roads), and therefore improve the matching accuracy and speed. If the mode is unknown, use the default multimodal , i.e. consider all types of roads, even a tree row . When GPS accuracy information is unknown, specifying a large search_radius may slow down the matching procedure while a small one may miss possible road candidates. Response \u00b6 The service returns matched routes of the sequence as a GeoJSON MultiLineString feature . Matched coordinates are saved in the property matched_coordinates as a JSON array. If a measurement is not matched to any road, then the corresponding matched coordinate is null . Examples \u00b6 Example request: curl -X POST \"http://localhost:8002?search_radius=35&mode=auto\" Example request body: { \"coordinates\" : [ [ 13.288925 , 52.438512 ], [ 13.288938 , 52.438938 ], [ 13.288904 , 52.439169 ], [ 13.288821 , 52.439398 ], [ 13.288824 , 52.439491 ], [ 13.288824 , 52.439563 ] ] } Example response: { \"status\" : 200 , \"message\" : \"OK\" , \"data\" : { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [ [ 13.288884 , 52.438507 ], [ 13.288852 , 52.438835 ], [ 13.288844 , 52.439090 ], [ 13.288825 , 52.439136 ], [ 13.288805 , 52.439159 ], [ 13.288601 , 52.439365 ], [ 13.288538 , 52.439384 ], [ 13.288719 , 52.439636 ] ] ] }, \"properties\" : { \"matched_coordinates\" : [ [ 13.288884 , 52.438507 ], [ 13.288848 , 52.438934 ], [ 13.288805 , 52.439159 ], [ 13.288601 , 52.439365 ], [ 13.288685 , 52.439590 ], [ 13.288719 , 52.439640 ] ] } } }","title":"Service API"},{"location":"meili/service_api/#service-api","text":"The API is still in testing and will be changed any time. Any suggestions are welcome to share at GitHub Issues .","title":"Service API"},{"location":"meili/service_api/#request","text":"The service accepts a GeoJSON feature or geometry (of type MultiPoint or LineString ) in the POST request body. URL Parameter Description Default mode Transport mode of the sequence. Possible modes are: auto , bycicle , pedestrian and multimodal . multimodal search_radius A numeric value in range [0, 100] to specify a radius (in meters) within which to search road candidates for each measurement. 40 Specifying a transport mode can limit the type of roads to match (e.g. auto will only consider drivable roads), and therefore improve the matching accuracy and speed. If the mode is unknown, use the default multimodal , i.e. consider all types of roads, even a tree row . When GPS accuracy information is unknown, specifying a large search_radius may slow down the matching procedure while a small one may miss possible road candidates.","title":"Request"},{"location":"meili/service_api/#response","text":"The service returns matched routes of the sequence as a GeoJSON MultiLineString feature . Matched coordinates are saved in the property matched_coordinates as a JSON array. If a measurement is not matched to any road, then the corresponding matched coordinate is null .","title":"Response"},{"location":"meili/service_api/#examples","text":"Example request: curl -X POST \"http://localhost:8002?search_radius=35&mode=auto\" Example request body: { \"coordinates\" : [ [ 13.288925 , 52.438512 ], [ 13.288938 , 52.438938 ], [ 13.288904 , 52.439169 ], [ 13.288821 , 52.439398 ], [ 13.288824 , 52.439491 ], [ 13.288824 , 52.439563 ] ] } Example response: { \"status\" : 200 , \"message\" : \"OK\" , \"data\" : { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [ [ 13.288884 , 52.438507 ], [ 13.288852 , 52.438835 ], [ 13.288844 , 52.439090 ], [ 13.288825 , 52.439136 ], [ 13.288805 , 52.439159 ], [ 13.288601 , 52.439365 ], [ 13.288538 , 52.439384 ], [ 13.288719 , 52.439636 ] ] ] }, \"properties\" : { \"matched_coordinates\" : [ [ 13.288884 , 52.438507 ], [ 13.288848 , 52.438934 ], [ 13.288805 , 52.439159 ], [ 13.288601 , 52.439365 ], [ 13.288685 , 52.439590 ], [ 13.288719 , 52.439640 ] ] } } }","title":"Examples"},{"location":"mjolnir/admins/","text":"Why is administrative attribution important? \u00b6 [x] Rental Car [x] Laptop [x] Cell [x] Luggage [ ] Passport D\u2019oh! Facepalm! I totally forgot that my passport has expired. The fastest route from Detroit, MI to Buffalo, NY is via Canada. For a US citizen, it is best to use a passport when driving through Canada; therefore, I must seek an alternate route. What drives me nuts is the fact that most of the routing sites do not provide an option to avoid country crossings. However, Valhalla does provide the ability to avoid country borders. Admins and Costing \u00b6 Mjolnir pulverizes data into a usable form. Well, not really...It does, however, give the option to apply attribution to the Valhalla routing data. An administrative database is created via pbfadminbuilder and can then be used to flag country crossings on edges during the building of the graph data. Now costing comes into play\u2026Valhalla uses dynamic, run-time costing to form the route path. (Read more about SIF and dynamic costing in our previous blog post .) A route request to Valhalla includes the name of the costing model and can include optional parameters accepted by the costing mode. In our case, we are using the Auto costing model and the optional parameters: country_crossing_cost = A cost that is applied when a country crossing is encountered. This cost is added to the estimated time / elapsed time. The default cost is 600 seconds. country_crossing_penalty = A penalty that is applied to the cost when a country crossing is encountered. This penalty can be used to create paths that avoid country crossings. The default penalty is 0. Let\u2019s try it out. Running the route from Detroit, MI to Buffalo, NY takes us through Canada. Obviously, this will not work for me as my passport has expired. However, if I boost the country_crossing_penalty to say 25 minutes or 1500 seconds, we avoid Canada and the use of the passport for this route. Now my trip can begin! I started my passport renewal process and I am jumping into the car with directions that avoid country crossings. Administrative attribution is important. \u00b6 As you can see, administrative attribution is important for avoidance. We could set the country_crossing_penalty to a very high value to always avoid country crossings. Valhalla will also use the administrative information for providing country and state or province information in the narrative (e.g., Crossing into New York, United States or Crossing into France). In the future, we will also use the country ISO code to create logic in ODIN that will be used to determine the base names of streets internationally. The base names will enable us to produce a cleaner narrative by collapsing maneuvers appropriately. Currently, when max_speed tag is not present, Valhalla assigns a speed based on the highway tag. There are country specific guidelines for speed limits per highway tag. We could use these default speed limit matrices for each country in order to provide more accurate time estimation and the best route ( Maxspeed ). What\u2019s next for admins in Valhalla? \u00b6 Valhalla uses admins to determine if we drive on the right or left; however, default access restrictions per country are not assigned yet. Can I walk on a trunk road in France? What about in the United States? How about in Germany? Admins will help Valhalla create default access restrictions for each country where available ( Access-Restrictions ).","title":"Administrative data"},{"location":"mjolnir/admins/#why-is-administrative-attribution-important","text":"[x] Rental Car [x] Laptop [x] Cell [x] Luggage [ ] Passport D\u2019oh! Facepalm! I totally forgot that my passport has expired. The fastest route from Detroit, MI to Buffalo, NY is via Canada. For a US citizen, it is best to use a passport when driving through Canada; therefore, I must seek an alternate route. What drives me nuts is the fact that most of the routing sites do not provide an option to avoid country crossings. However, Valhalla does provide the ability to avoid country borders.","title":"Why is administrative attribution important?"},{"location":"mjolnir/admins/#admins-and-costing","text":"Mjolnir pulverizes data into a usable form. Well, not really...It does, however, give the option to apply attribution to the Valhalla routing data. An administrative database is created via pbfadminbuilder and can then be used to flag country crossings on edges during the building of the graph data. Now costing comes into play\u2026Valhalla uses dynamic, run-time costing to form the route path. (Read more about SIF and dynamic costing in our previous blog post .) A route request to Valhalla includes the name of the costing model and can include optional parameters accepted by the costing mode. In our case, we are using the Auto costing model and the optional parameters: country_crossing_cost = A cost that is applied when a country crossing is encountered. This cost is added to the estimated time / elapsed time. The default cost is 600 seconds. country_crossing_penalty = A penalty that is applied to the cost when a country crossing is encountered. This penalty can be used to create paths that avoid country crossings. The default penalty is 0. Let\u2019s try it out. Running the route from Detroit, MI to Buffalo, NY takes us through Canada. Obviously, this will not work for me as my passport has expired. However, if I boost the country_crossing_penalty to say 25 minutes or 1500 seconds, we avoid Canada and the use of the passport for this route. Now my trip can begin! I started my passport renewal process and I am jumping into the car with directions that avoid country crossings.","title":"Admins and Costing"},{"location":"mjolnir/admins/#administrative-attribution-is-important","text":"As you can see, administrative attribution is important for avoidance. We could set the country_crossing_penalty to a very high value to always avoid country crossings. Valhalla will also use the administrative information for providing country and state or province information in the narrative (e.g., Crossing into New York, United States or Crossing into France). In the future, we will also use the country ISO code to create logic in ODIN that will be used to determine the base names of streets internationally. The base names will enable us to produce a cleaner narrative by collapsing maneuvers appropriately. Currently, when max_speed tag is not present, Valhalla assigns a speed based on the highway tag. There are country specific guidelines for speed limits per highway tag. We could use these default speed limit matrices for each country in order to provide more accurate time estimation and the best route ( Maxspeed ).","title":"Administrative attribution is important."},{"location":"mjolnir/admins/#whats-next-for-admins-in-valhalla","text":"Valhalla uses admins to determine if we drive on the right or left; however, default access restrictions per country are not assigned yet. Can I walk on a trunk road in France? What about in the United States? How about in Germany? Admins will help Valhalla create default access restrictions for each country where available ( Access-Restrictions ).","title":"What\u2019s next for admins in Valhalla?"},{"location":"mjolnir/attribution/","text":"Attribution \u00b6 Attribution is required for many of our data providers. Example language is provided below, but you are responsible for researching each project to follow their license terms. More details are available on the Data Sources page. Required attribution: \u00a9 OpenStreetMap contributors Required attribution for projects using elevation data: \u00a9 OpenStreetMap contributors, U.S. Geological Survey, and U.S. National Oceanic and Atmospheric Administration Where to attribute \u00b6 Attribution needs to \"appear in a place that is reasonable to the medium or means you are utilising.\" Specific examples are given by the OSM Foundation and are generally best practices for giving credit to any source.","title":"Attribution requirements"},{"location":"mjolnir/attribution/#attribution","text":"Attribution is required for many of our data providers. Example language is provided below, but you are responsible for researching each project to follow their license terms. More details are available on the Data Sources page. Required attribution: \u00a9 OpenStreetMap contributors Required attribution for projects using elevation data: \u00a9 OpenStreetMap contributors, U.S. Geological Survey, and U.S. National Oceanic and Atmospheric Administration","title":"Attribution"},{"location":"mjolnir/attribution/#where-to-attribute","text":"Attribution needs to \"appear in a place that is reasonable to the medium or means you are utilising.\" Specific examples are given by the OSM Foundation and are generally best practices for giving credit to any source.","title":"Where to attribute"},{"location":"mjolnir/data_sources/","text":"Data sources in Valhalla \u00b6 Valhalla routing tiles are created from several different open data sets. We owe a tremendous debt of gratitude to the individuals and communities which produced them. This document identifies the data sources and licensing of these data sources. Attribution is required for many of our data providers. See the Attribution document for more information. OpenStreetMap \u00b6 OpenStreetMap is a community-driven, editable map of the world. It prioritizes local knowledge and individual contributions over bulk imports, which often means it has excellent coverage even in remote areas where no large-scale mapping efforts have been attempted. OpenStreetMap contains information on landmarks, buildings, roads, and natural features. Valhalla primarily uses the road information from OSM to create its routing network. Valhalla also uses the relations information to provide extra attribution to roads and to create restrictions. The higher-level administrative polygon information is also used to identify country and state/province information for roads. All OpenStreetMap data is licensed under the ODbL , a share-alike license, which also requires attribution . Please consider donating to the OSM Foundation to help cover the administration and server costs. Transitland \u00b6 Transitland provides public transit information to Valhalla. This data is connected to the OSM road and path network to provide seamless multimodal routing. A licensing overview of Transitland is provided here . Transit feed license details can be found here . Elevation data \u00b6 Valhalla uses terrain data for building elevation-influenced routes, such as for bicycles. You can find more about the license and attribution requirements for elevation data here . Boost Timezone Data \u00b6 Valhalla attaches timezone information to every node/intersection in the road network. The timezone data comes from tz_world . This data contains polygon definitions of the various timezones throughout the world. Timezone specifications within each region and conversions of time between timezones are derived using Boost . Please notify us if you believe that an open data project has not been properly noted.","title":"Data sources"},{"location":"mjolnir/data_sources/#data-sources-in-valhalla","text":"Valhalla routing tiles are created from several different open data sets. We owe a tremendous debt of gratitude to the individuals and communities which produced them. This document identifies the data sources and licensing of these data sources. Attribution is required for many of our data providers. See the Attribution document for more information.","title":"Data sources in Valhalla"},{"location":"mjolnir/data_sources/#openstreetmap","text":"OpenStreetMap is a community-driven, editable map of the world. It prioritizes local knowledge and individual contributions over bulk imports, which often means it has excellent coverage even in remote areas where no large-scale mapping efforts have been attempted. OpenStreetMap contains information on landmarks, buildings, roads, and natural features. Valhalla primarily uses the road information from OSM to create its routing network. Valhalla also uses the relations information to provide extra attribution to roads and to create restrictions. The higher-level administrative polygon information is also used to identify country and state/province information for roads. All OpenStreetMap data is licensed under the ODbL , a share-alike license, which also requires attribution . Please consider donating to the OSM Foundation to help cover the administration and server costs.","title":"OpenStreetMap"},{"location":"mjolnir/data_sources/#transitland","text":"Transitland provides public transit information to Valhalla. This data is connected to the OSM road and path network to provide seamless multimodal routing. A licensing overview of Transitland is provided here . Transit feed license details can be found here .","title":"Transitland"},{"location":"mjolnir/data_sources/#elevation-data","text":"Valhalla uses terrain data for building elevation-influenced routes, such as for bicycles. You can find more about the license and attribution requirements for elevation data here .","title":"Elevation data"},{"location":"mjolnir/data_sources/#boost-timezone-data","text":"Valhalla attaches timezone information to every node/intersection in the road network. The timezone data comes from tz_world . This data contains polygon definitions of the various timezones throughout the world. Timezone specifications within each region and conversions of time between timezones are derived using Boost . Please notify us if you believe that an open data project has not been properly noted.","title":"Boost Timezone Data"},{"location":"mjolnir/geojson/","text":"Map Roulette Geojson Generation \u00b6 To generate the geojson, you'll need to detect the cases, gather the required data, and define how the geojson should be created. Detection \u00b6 You will have to design an algorithm that can detect the cases that you are looking for. Once you are able to detect the cases, you now need to capture the useful data. For an example of existing detection please see the function bool IsUnroutableNode in valhalla_build_statistics.cc . Gathering the Data \u00b6 At a minimum, you will need some sort of geojson feature to display on the Map Roulette interface. This can be a point or linestring or a combination of them. At some point in the data capture you must capture a lat-long pair (PointLL) that is unique for each case you detect. This will be used later as the identifier in the geojson. You will need to modify the roulettedata struct to hold your new data. Geojson \u00b6 To have your geojson correctly recognized by Map Roulette and the automation scripts you will need to have a specific format. You will need to implement something like this that creates your geojson and adds it to a collection. A single task's geojson should look something like the following: { \"instruction\": \"This node is either unreachable or unleavable. Edit the surrounding roads so that the node can be accessed properly\", \"properties\": { \"key\": 4770031602477192848, \"type\": \"Node\" }, \"type\": \"Feature\", \"geometry\": { \"type\": \"Point\", \"coordinates\": [8.64613, 44.63913] } } The properties.key field here is the hashed PointLL (lat-long) used as the id. Look at the previous link about geojson creation to see how to create the hash. That should be it, now you can start automating your Map Roulette tasks.","title":"Geojson"},{"location":"mjolnir/geojson/#map-roulette-geojson-generation","text":"To generate the geojson, you'll need to detect the cases, gather the required data, and define how the geojson should be created.","title":"Map Roulette Geojson Generation"},{"location":"mjolnir/geojson/#detection","text":"You will have to design an algorithm that can detect the cases that you are looking for. Once you are able to detect the cases, you now need to capture the useful data. For an example of existing detection please see the function bool IsUnroutableNode in valhalla_build_statistics.cc .","title":"Detection"},{"location":"mjolnir/geojson/#gathering-the-data","text":"At a minimum, you will need some sort of geojson feature to display on the Map Roulette interface. This can be a point or linestring or a combination of them. At some point in the data capture you must capture a lat-long pair (PointLL) that is unique for each case you detect. This will be used later as the identifier in the geojson. You will need to modify the roulettedata struct to hold your new data.","title":"Gathering the Data"},{"location":"mjolnir/geojson/#geojson","text":"To have your geojson correctly recognized by Map Roulette and the automation scripts you will need to have a specific format. You will need to implement something like this that creates your geojson and adds it to a collection. A single task's geojson should look something like the following: { \"instruction\": \"This node is either unreachable or unleavable. Edit the surrounding roads so that the node can be accessed properly\", \"properties\": { \"key\": 4770031602477192848, \"type\": \"Node\" }, \"type\": \"Feature\", \"geometry\": { \"type\": \"Point\", \"coordinates\": [8.64613, 44.63913] } } The properties.key field here is the hashed PointLL (lat-long) used as the id. Look at the previous link about geojson creation to see how to create the hash. That should be it, now you can start automating your Map Roulette tasks.","title":"Geojson"},{"location":"mjolnir/getting_started_guide/","text":"Mjolnir: Getting started guide \u00b6 The mjolnir library is essentially a set of applications, data structures and alogrithms which deal with things like: parsing OpenStreetMap data extracts, cutting routable \"graph\" tiles, generating tile hierarchies and testing for data deficiencies. If you would like to create your own routing tiles, this guilde will help you get started. Data \u00b6 You can download extracts from Geofabrik GmbH . If you wish to convert the entire planet, we have successfully run conversions on quad-cores(CPU @ 2.70GHz) machines with 16 gigs of RAM utilizing a SSD. Conversions with administrative areas and timezones, but without elevation data will take around 15 hours. This route graph will include motor vehicle, pedestrian, and bicycle route information. For more information on what tags and values we use from OSM please consult our tag parsing guide . Creating Data \u00b6 Build valhalla and its various tools: mkdir build cd build cmake .. make all check -j $( nproc ) You'll see valhalla_build_tiles under the build directory. One level up you'll find scripts/valhalla_build_config which you can use to generate the config file needed to build routing tiles. Check the --help text for all the various configuration options in the config file. Generate your config: ../scripts/valhalla_build_config > valhalla.json Then build some tiles from an extract: ./valhalla_build_tiles --config /path_to_your_config/valhalla.json /data/osm_data/your_osm_extract.pbf Optional Prerequisites \u00b6 Administrative Areas \u00b6 An administrative database is created via valhalla_build_admins and is used to flag country crossings on edges during the building of the graph data. Moreover, we also use admins to determine if we drive on the right or left (default: right). In the future, we will use admins to set the default access restrictions per country. We recommend running the valhalla_build_admins on the planet; otherwise, parent admin information maybe lost or not all admins will get saved to the database. This usually happens when a way is missing from the extract, but is part of the admin relation. Most likely the extract polygon does not cover the entire admin relation. If you would like administrative information within the route graph, please follow the following steps: Download your osm data. If needed, update the admin value under mjolnir in your valhalla.json config. Default filename and directory is /data/valhalla/admin.sqlite . Run valhalla_build_admins under the valhalla directory. ./valhalla_build_admins --config /path_to_your_config/valhalla.json /data/osm_data/your_osm_extract.pbf The next time you run valhalla_build_tiles , admin information will be added to the route graph. Timezones \u00b6 Timezones are used if you want to set your departure or arrival date and time. If you would like timezone information within the route graph, please follow the following steps: If needed, update the timezone value under mjolnir in your valhalla.json config. Default filename and directory is /data/valhalla/tz_world.sqlite . Go to your_valhalla_directory/scripts . Run valhalla_build_timezones > /path_to_your/tz_world.sqlite The next time you run valhalla_build_tiles , timezone information will be added to the route graph. Elevation \u00b6 If you want to add elevation information to your route tiles you can do so using SRTMv3 tiles as the input. If needed run valhalla_build_elevation . I will create an elevation dataset which is about 1.6TB for the whole world Point your valhalla.json configuration to this directory so it can be referenced when building the graph tiles. The proper configuration value for this can be sent when running valhalla_build_config using the --additional-data-elevation argument. The next time you run valhalla_build_tiles , elevation information will be added to the route graph. Transit Data \u00b6 If you want to add transit data to your route tiles you can follow these steps: Use valhalla_build_transit to create an initial set of transit tiles for your region. Configure valhalla.json using valhalla_build_config and the --mjolnir-transit-dir argument. The next time you run valhalla_build_tiles , transit graph will be connected to the route graph.","title":"Mjolnir: Getting started guide"},{"location":"mjolnir/getting_started_guide/#mjolnir-getting-started-guide","text":"The mjolnir library is essentially a set of applications, data structures and alogrithms which deal with things like: parsing OpenStreetMap data extracts, cutting routable \"graph\" tiles, generating tile hierarchies and testing for data deficiencies. If you would like to create your own routing tiles, this guilde will help you get started.","title":"Mjolnir: Getting started guide"},{"location":"mjolnir/getting_started_guide/#data","text":"You can download extracts from Geofabrik GmbH . If you wish to convert the entire planet, we have successfully run conversions on quad-cores(CPU @ 2.70GHz) machines with 16 gigs of RAM utilizing a SSD. Conversions with administrative areas and timezones, but without elevation data will take around 15 hours. This route graph will include motor vehicle, pedestrian, and bicycle route information. For more information on what tags and values we use from OSM please consult our tag parsing guide .","title":"Data"},{"location":"mjolnir/getting_started_guide/#creating-data","text":"Build valhalla and its various tools: mkdir build cd build cmake .. make all check -j $( nproc ) You'll see valhalla_build_tiles under the build directory. One level up you'll find scripts/valhalla_build_config which you can use to generate the config file needed to build routing tiles. Check the --help text for all the various configuration options in the config file. Generate your config: ../scripts/valhalla_build_config > valhalla.json Then build some tiles from an extract: ./valhalla_build_tiles --config /path_to_your_config/valhalla.json /data/osm_data/your_osm_extract.pbf","title":"Creating Data"},{"location":"mjolnir/getting_started_guide/#optional-prerequisites","text":"","title":"Optional Prerequisites"},{"location":"mjolnir/getting_started_guide/#administrative-areas","text":"An administrative database is created via valhalla_build_admins and is used to flag country crossings on edges during the building of the graph data. Moreover, we also use admins to determine if we drive on the right or left (default: right). In the future, we will use admins to set the default access restrictions per country. We recommend running the valhalla_build_admins on the planet; otherwise, parent admin information maybe lost or not all admins will get saved to the database. This usually happens when a way is missing from the extract, but is part of the admin relation. Most likely the extract polygon does not cover the entire admin relation. If you would like administrative information within the route graph, please follow the following steps: Download your osm data. If needed, update the admin value under mjolnir in your valhalla.json config. Default filename and directory is /data/valhalla/admin.sqlite . Run valhalla_build_admins under the valhalla directory. ./valhalla_build_admins --config /path_to_your_config/valhalla.json /data/osm_data/your_osm_extract.pbf The next time you run valhalla_build_tiles , admin information will be added to the route graph.","title":"Administrative Areas"},{"location":"mjolnir/getting_started_guide/#timezones","text":"Timezones are used if you want to set your departure or arrival date and time. If you would like timezone information within the route graph, please follow the following steps: If needed, update the timezone value under mjolnir in your valhalla.json config. Default filename and directory is /data/valhalla/tz_world.sqlite . Go to your_valhalla_directory/scripts . Run valhalla_build_timezones > /path_to_your/tz_world.sqlite The next time you run valhalla_build_tiles , timezone information will be added to the route graph.","title":"Timezones"},{"location":"mjolnir/getting_started_guide/#elevation","text":"If you want to add elevation information to your route tiles you can do so using SRTMv3 tiles as the input. If needed run valhalla_build_elevation . I will create an elevation dataset which is about 1.6TB for the whole world Point your valhalla.json configuration to this directory so it can be referenced when building the graph tiles. The proper configuration value for this can be sent when running valhalla_build_config using the --additional-data-elevation argument. The next time you run valhalla_build_tiles , elevation information will be added to the route graph.","title":"Elevation"},{"location":"mjolnir/getting_started_guide/#transit-data","text":"If you want to add transit data to your route tiles you can follow these steps: Use valhalla_build_transit to create an initial set of transit tiles for your region. Configure valhalla.json using valhalla_build_config and the --mjolnir-transit-dir argument. The next time you run valhalla_build_tiles , transit graph will be connected to the route graph.","title":"Transit Data"},{"location":"mjolnir/map_roulette/","text":"Automatic Map Roulette Task Updates \u00b6 Overview \u00b6 The tool is located under mjonir/py/challenge_admin/ as admin_tool.py and is run from the command line. This tool works in conjunction with valhalla_build_statistics which detects errors in the OpenStreetMap data set and outputs those errors as a geojson file. This tool then reads the geojson file and compares it to the existing tasks already uploaded to Map Roulette and uploads the new tasks. Optionally, the tool can also detect when tasks have been marked as fixed, but have shown up again during the detection process. Configuring \u00b6 A sample configuration file can be found at valhalla/conf/maproulette.json and must be configured before this tool will work properly. Additionally, you will have to do some setup on the maproulette website . Perform Map Roulette Setup \u00b6 Create a challenge \u00b6 To get started you'll need to create a challenge using the interface on the website. Once you have created a challenge, you will just need the challenge ID. You will put the challenge ID into your configuration file later. Get an API key \u00b6 On the Map Roulette website click on your username at the top right, then select \"Profile\". Your API key can be found in the side panel on the left. Modify the Config File \u00b6 Now that you have the information you need, substitute your api key into the config file. Then, you have to set up your challenges entry. A simple entry will look something like: \"challenges\": { \"18\": [\"Loop\", \"Node\"] } This simply specifies that challenge number 18 will contain tasks of type Loop and Node. The challenge number is the one that you found after creating the challenge. The task types are the types of tasks you specified in the geojson. If you have gotten here and don't know what geojson you should have, click here to learn more. Finally, make sure that you change the server_url field to reflect the actual server (http://maproulette.org) if not running the server locally. Using this tool \u00b6 Usage of the tool is fairly simple as it is designed to be largely automatic. All you need to do is provide some command line arguments. Required Arguments \u00b6 There are two required Arguments: -c, --config json config file to use -i, --geojson geojson to build new tasks from There are also others available: -h, --help how to call the program -r, --resubmit try to detect tasks that have not been fixed, if there are unfixed tasks marked as fixed, resubmit them as new tasks","title":"Map roulette"},{"location":"mjolnir/map_roulette/#automatic-map-roulette-task-updates","text":"","title":"Automatic Map Roulette Task Updates"},{"location":"mjolnir/map_roulette/#overview","text":"The tool is located under mjonir/py/challenge_admin/ as admin_tool.py and is run from the command line. This tool works in conjunction with valhalla_build_statistics which detects errors in the OpenStreetMap data set and outputs those errors as a geojson file. This tool then reads the geojson file and compares it to the existing tasks already uploaded to Map Roulette and uploads the new tasks. Optionally, the tool can also detect when tasks have been marked as fixed, but have shown up again during the detection process.","title":"Overview"},{"location":"mjolnir/map_roulette/#configuring","text":"A sample configuration file can be found at valhalla/conf/maproulette.json and must be configured before this tool will work properly. Additionally, you will have to do some setup on the maproulette website .","title":"Configuring"},{"location":"mjolnir/map_roulette/#perform-map-roulette-setup","text":"","title":"Perform Map Roulette Setup"},{"location":"mjolnir/map_roulette/#create-a-challenge","text":"To get started you'll need to create a challenge using the interface on the website. Once you have created a challenge, you will just need the challenge ID. You will put the challenge ID into your configuration file later.","title":"Create a challenge"},{"location":"mjolnir/map_roulette/#get-an-api-key","text":"On the Map Roulette website click on your username at the top right, then select \"Profile\". Your API key can be found in the side panel on the left.","title":"Get an API key"},{"location":"mjolnir/map_roulette/#modify-the-config-file","text":"Now that you have the information you need, substitute your api key into the config file. Then, you have to set up your challenges entry. A simple entry will look something like: \"challenges\": { \"18\": [\"Loop\", \"Node\"] } This simply specifies that challenge number 18 will contain tasks of type Loop and Node. The challenge number is the one that you found after creating the challenge. The task types are the types of tasks you specified in the geojson. If you have gotten here and don't know what geojson you should have, click here to learn more. Finally, make sure that you change the server_url field to reflect the actual server (http://maproulette.org) if not running the server locally.","title":"Modify the Config File"},{"location":"mjolnir/map_roulette/#using-this-tool","text":"Usage of the tool is fairly simple as it is designed to be largely automatic. All you need to do is provide some command line arguments.","title":"Using this tool"},{"location":"mjolnir/map_roulette/#required-arguments","text":"There are two required Arguments: -c, --config json config file to use -i, --geojson geojson to build new tasks from There are also others available: -h, --help how to call the program -r, --resubmit try to detect tasks that have not been fixed, if there are unfixed tasks marked as fixed, resubmit them as new tasks","title":"Required Arguments"},{"location":"mjolnir/map_roulette_blog/","text":"Map Roulette and Valhalla \u00b6 Not so long ago the routing team started to notice that occasionally the origin or destination of a route would be unreachable. These routes weren't anything extravagant or extraordinary, but for some reason they were failing. After some investigation we realized that certain errors in OpenStreetMap could easily cause the routes to fail. The most obvious of these seemed to be when the direction of one way roads was switched. To differentiate between routes that fail because two locations are disconnected in real life and routes that were doomed from the start by these errors, we started trying to detect them. Once we were detecting them we had to figure out what to do with them. Do we manually edit them all ourselves? Do we ignore them and hope they get fixed down the road? There could be hundreds or thousands of these types of errors in OSM that could impact routing. To demonstrate what this might look like, here is the same route before and after an error was fixed. A one way road in the red box was reversed, causing the route to go further than needed. Enter Map Roulette: A platform that allows contributors to submit sets of errors so that the OSM community can fix them. After we found out about this, we started working on code designed specifically to look for these errors, and once we had a collection of these errors we planned to submit them to Map Roulette. As we got closer to doing this, we realized that eliminating the errors only once would not prevent errors from being created in the future. We also thought that we could probably automate the process to minimize manual intervention in the process. To start testing this we needed the help of Martijn Van Exel, the creator of Map Roulette. He helped us get local instances of the Map Roulette server running as well as answered other questions we had along the way. The automation process seemed like a good fit for a bit of Python. After building a few tools for testing the Map Roulette API and our collection of errors, we brought it all together to create a tool that can be run without any manual intervention. We now run this tool right after checking the latest set of tiles for errors, allowing any new errors to be automatically uploaded to Map Roulette. Additionally, the tool can also detect errors that were marked as fixed but were not fixed correctly. The result of all this work is a framework that allows for detection, submission, and eventual resolution of OSM errors. To start doing this for a new type of error, the only thing we would need to do would be to write a detection algorithm, create a geojson representation of the error, and add the new type of error to the tool's configuration file. Currently, we only have one type of error being detected and automatically submitted, but look forward to seeing what other issues we can fix and how much we can help improve OSM.","title":"Map Roulette and Valhalla"},{"location":"mjolnir/map_roulette_blog/#map-roulette-and-valhalla","text":"Not so long ago the routing team started to notice that occasionally the origin or destination of a route would be unreachable. These routes weren't anything extravagant or extraordinary, but for some reason they were failing. After some investigation we realized that certain errors in OpenStreetMap could easily cause the routes to fail. The most obvious of these seemed to be when the direction of one way roads was switched. To differentiate between routes that fail because two locations are disconnected in real life and routes that were doomed from the start by these errors, we started trying to detect them. Once we were detecting them we had to figure out what to do with them. Do we manually edit them all ourselves? Do we ignore them and hope they get fixed down the road? There could be hundreds or thousands of these types of errors in OSM that could impact routing. To demonstrate what this might look like, here is the same route before and after an error was fixed. A one way road in the red box was reversed, causing the route to go further than needed. Enter Map Roulette: A platform that allows contributors to submit sets of errors so that the OSM community can fix them. After we found out about this, we started working on code designed specifically to look for these errors, and once we had a collection of these errors we planned to submit them to Map Roulette. As we got closer to doing this, we realized that eliminating the errors only once would not prevent errors from being created in the future. We also thought that we could probably automate the process to minimize manual intervention in the process. To start testing this we needed the help of Martijn Van Exel, the creator of Map Roulette. He helped us get local instances of the Map Roulette server running as well as answered other questions we had along the way. The automation process seemed like a good fit for a bit of Python. After building a few tools for testing the Map Roulette API and our collection of errors, we brought it all together to create a tool that can be run without any manual intervention. We now run this tool right after checking the latest set of tiles for errors, allowing any new errors to be automatically uploaded to Map Roulette. Additionally, the tool can also detect errors that were marked as fixed but were not fixed correctly. The result of all this work is a framework that allows for detection, submission, and eventual resolution of OSM errors. To start doing this for a new type of error, the only thing we would need to do would be to write a detection algorithm, create a geojson representation of the error, and add the new type of error to the tool's configuration file. Currently, we only have one type of error being detected and automatically submitted, but look forward to seeing what other issues we can fix and how much we can help improve OSM.","title":"Map Roulette and Valhalla"},{"location":"mjolnir/tag_parsing/","text":"OSM Tag Usage \u00b6 Table of Contents \u00b6 OSM Data Model Overview OSM Processing Overview Lua Tag Processing C++ Tag Processing Common Pitfalls and Debugging OSM Data Model Overview \u00b6 OSM's data is mostly schemaless. It currently has a top level structure which consists of 3 element types. Those are nodes, ways and relations. Nodes are point features, ways are linear features (comprised of nodes) and relations are multi features (comprised of nodes and/or ways). See here for more on the types of elements within the OSM dataset. Each of these objects can have any number of key value pairs, called tags associated with it. The tags are used to delineate physical, political, temporal, etc attribution of the element to which they are attached. Valhalla creates a routable graph directly from OSM elements and their tags. The connectivity of the graph is a direct result of how the nodes, ways and relations are correlated in the data model. The attribution on edges and nodes in the resulting graph come directly from the tags on those OSM elements. Note that many OSM elements, because of their tags (or lack thereof), will not be useful in creating a routable graph and are simply ignored. OSM Processing Overview \u00b6 The basic flow valhalla follows when creating routing tiles is as follows: Parse all the ways and their tags Parse all the relations and their tags Parse all the nodes and their tags Each of the step uses a combination of lua and c++ to transform the tags into a structured set of values. From c++ we call into lua passing it a single element. What comes out is a map of keys to values where both have been massaged to fit into a small (compared to the original data) set of permutations. Then the c++ side of things will turn an element's key value pair strings into well defined structures for storage. The result of this is a vector of fixed-size (static number of bytes) structures (think of a c++ struct ) for each element type. Because we turn the tags into fixed-size structures we can store these in a file and use memory mapping to complete this process on very large datasets (the planet) with very modest hardware. Note that we don't store relations in a file simply because they require very little space. Once we've gotten all of the basic structures parsed out of the OSM data model into a well-defined set of structures we simply iterate over those structures to create the graph. We take care to sort the structures so that we can iterate over ways and then, within a given way, over the nodes that comprise it (in the right order). Lua Tag Processing \u00b6 The concept of using lua to transform OSM tags into a discrete set of keys and values is inspired by osm2pgsql . This allows those who want to change the way tags are interpreted to do so without having to recompile valhalla. Additionally, lua is quite simplistic so one could argue that its barrier to entry is pretty low. Valhalla comes with default lua transformation functions which can be found here . If you'd like to override these you may do so by changing arguments in the valhalla.json configuration used with valhalla_build_tiles . The process of boiling down all the different permutations of OSM values into a discrete set is quite formidable (one could argue that it's never done). An interesting resource for inspecting what type of tags on what types of elements exist in wild can be found at TagInfo . This is great when you want to figure out what tags your parser should target to get as much of the desired attribution as possible. TagInfo also publishes a list of different projects that use OSM data and what tag permutations lead to what attribution in those respective projects. Valhalla publishes a file called taginfo.json which allows the TagInfo website to list the tags that valhalla parses. For more see here . C++ Tag Processing \u00b6 The basic principle of this part of the process is that we take the string outputs from the lua calls and marshal them into what are essentially integral types. There may be some other interesting things that happen at this point in time such as marking which OSM nodes which will become graph nodes (because more than one way references them), and marking loops in ways (because the same node happens more than once) or storing turn restriction information. Common Pitfalls and Debugging \u00b6 When you find a problem with the quality of a route or with route tile creation, one of the first places to look will be at the data. There can be a few places you want to check. Missing or wrong tags on OSM elements Missing lua code to parse particular tags Incorrect error handling of tag values Failure to Cut Tiles \u00b6 Take a look at the log that comes out of valhalla_build_tiles . There are many phases of this process. If the process failed at the beginning (in the parsing phase) there is a good chance we have a bug within the c++ marshalling of strings to integers. You'll want to get a copy of the pbf OSM data that was being used when the program crashed (it usually crashes in this case). If you can get a backtrace or even a core file then you can localize this without running it yourself but otherwise simply run valhalla_build_tiles and find where it's crashing. Chances are there is an unprotected std::stoi or something similar. Route Quality Issue \u00b6 If you are having a route quality issue where the route is using a particular road it shouldn't or not using a particular road that it should you'll want to see what valhalla interpreted the particular street to have. We have a tool for this. The first step here is to get the tile set with the quality issue and run a server with it. You can then crack open this debug tool which is pointed at localhost (or you can point it at another server). Simply click the problem road. You'll get a green result (or multiple). Click which ever green result is nearest to the problem you are experiencing. The side panel will show you detailed attribution that valhalla stores for this graph edge (or node if you clicked one of those). Carefully inspect the information. Do any of the access flags tell you anything you wouldn't expect? Once you notice what attribution looks incorrect you can then sift through the details to find the way id. Take the way id and plug it into osm.org, like http://osm.org/way/way_id_here . From there you can see the tags table which should show you the attributes valhalla sees when its parsing. At this point there is either wrong data in OSM or wrong interpretation in valhalla.","title":"OSM Tag Usage"},{"location":"mjolnir/tag_parsing/#osm-tag-usage","text":"","title":"OSM Tag Usage"},{"location":"mjolnir/tag_parsing/#table-of-contents","text":"OSM Data Model Overview OSM Processing Overview Lua Tag Processing C++ Tag Processing Common Pitfalls and Debugging","title":"Table of Contents"},{"location":"mjolnir/tag_parsing/#osm-data-model-overview","text":"OSM's data is mostly schemaless. It currently has a top level structure which consists of 3 element types. Those are nodes, ways and relations. Nodes are point features, ways are linear features (comprised of nodes) and relations are multi features (comprised of nodes and/or ways). See here for more on the types of elements within the OSM dataset. Each of these objects can have any number of key value pairs, called tags associated with it. The tags are used to delineate physical, political, temporal, etc attribution of the element to which they are attached. Valhalla creates a routable graph directly from OSM elements and their tags. The connectivity of the graph is a direct result of how the nodes, ways and relations are correlated in the data model. The attribution on edges and nodes in the resulting graph come directly from the tags on those OSM elements. Note that many OSM elements, because of their tags (or lack thereof), will not be useful in creating a routable graph and are simply ignored.","title":"OSM Data Model Overview"},{"location":"mjolnir/tag_parsing/#osm-processing-overview","text":"The basic flow valhalla follows when creating routing tiles is as follows: Parse all the ways and their tags Parse all the relations and their tags Parse all the nodes and their tags Each of the step uses a combination of lua and c++ to transform the tags into a structured set of values. From c++ we call into lua passing it a single element. What comes out is a map of keys to values where both have been massaged to fit into a small (compared to the original data) set of permutations. Then the c++ side of things will turn an element's key value pair strings into well defined structures for storage. The result of this is a vector of fixed-size (static number of bytes) structures (think of a c++ struct ) for each element type. Because we turn the tags into fixed-size structures we can store these in a file and use memory mapping to complete this process on very large datasets (the planet) with very modest hardware. Note that we don't store relations in a file simply because they require very little space. Once we've gotten all of the basic structures parsed out of the OSM data model into a well-defined set of structures we simply iterate over those structures to create the graph. We take care to sort the structures so that we can iterate over ways and then, within a given way, over the nodes that comprise it (in the right order).","title":"OSM Processing Overview"},{"location":"mjolnir/tag_parsing/#lua-tag-processing","text":"The concept of using lua to transform OSM tags into a discrete set of keys and values is inspired by osm2pgsql . This allows those who want to change the way tags are interpreted to do so without having to recompile valhalla. Additionally, lua is quite simplistic so one could argue that its barrier to entry is pretty low. Valhalla comes with default lua transformation functions which can be found here . If you'd like to override these you may do so by changing arguments in the valhalla.json configuration used with valhalla_build_tiles . The process of boiling down all the different permutations of OSM values into a discrete set is quite formidable (one could argue that it's never done). An interesting resource for inspecting what type of tags on what types of elements exist in wild can be found at TagInfo . This is great when you want to figure out what tags your parser should target to get as much of the desired attribution as possible. TagInfo also publishes a list of different projects that use OSM data and what tag permutations lead to what attribution in those respective projects. Valhalla publishes a file called taginfo.json which allows the TagInfo website to list the tags that valhalla parses. For more see here .","title":"Lua Tag Processing"},{"location":"mjolnir/tag_parsing/#c-tag-processing","text":"The basic principle of this part of the process is that we take the string outputs from the lua calls and marshal them into what are essentially integral types. There may be some other interesting things that happen at this point in time such as marking which OSM nodes which will become graph nodes (because more than one way references them), and marking loops in ways (because the same node happens more than once) or storing turn restriction information.","title":"C++ Tag Processing"},{"location":"mjolnir/tag_parsing/#common-pitfalls-and-debugging","text":"When you find a problem with the quality of a route or with route tile creation, one of the first places to look will be at the data. There can be a few places you want to check. Missing or wrong tags on OSM elements Missing lua code to parse particular tags Incorrect error handling of tag values","title":"Common Pitfalls and Debugging"},{"location":"mjolnir/tag_parsing/#failure-to-cut-tiles","text":"Take a look at the log that comes out of valhalla_build_tiles . There are many phases of this process. If the process failed at the beginning (in the parsing phase) there is a good chance we have a bug within the c++ marshalling of strings to integers. You'll want to get a copy of the pbf OSM data that was being used when the program crashed (it usually crashes in this case). If you can get a backtrace or even a core file then you can localize this without running it yourself but otherwise simply run valhalla_build_tiles and find where it's crashing. Chances are there is an unprotected std::stoi or something similar.","title":"Failure to Cut Tiles"},{"location":"mjolnir/tag_parsing/#route-quality-issue","text":"If you are having a route quality issue where the route is using a particular road it shouldn't or not using a particular road that it should you'll want to see what valhalla interpreted the particular street to have. We have a tool for this. The first step here is to get the tile set with the quality issue and run a server with it. You can then crack open this debug tool which is pointed at localhost (or you can point it at another server). Simply click the problem road. You'll get a green result (or multiple). Click which ever green result is nearest to the problem you are experiencing. The side panel will show you detailed attribution that valhalla stores for this graph edge (or node if you clicked one of those). Carefully inspect the information. Do any of the access flags tell you anything you wouldn't expect? Once you notice what attribution looks incorrect you can then sift through the details to find the way id. Take the way id and plug it into osm.org, like http://osm.org/way/way_id_here . From there you can see the tags table which should show you the attributes valhalla sees when its parsing. At this point there is either wrong data in OSM or wrong interpretation in valhalla.","title":"Route Quality Issue"},{"location":"mjolnir/why_tiles/","text":"Routing Tiles - the Who, What, When, Where, How and Why? \u00b6 A bit of the Who, When and How \u00b6 We had just started our new endeavor at Mapzen and were kicking around fundamental ideas of what our system should look like. Here's a bit of a transcript of how we got here: 17/11/14 01:27 EST Kevin: wakes up in a cold sweat and begins to fumble around for his phone 17/11/14 01:28 EST Kevin: violently stubs his toe on the sharpest lego he's ever witnessed 17/11/14 01:30 EST Kevin: cursing and slightly bloody, he manages to ring Dave 17/11/14 01:32 EST Dave: Uhnnng... 17/11/14 01:32 EST Kevin: Dave! What if we route on tiled data!? 17/11/14 01:33 EST Dave: Um... yeah... you've been working in the mapping world for far too long 17/11/14 01:33 EST Dave: throws his phone to the furthest corner of the room 17/11/14 01:34 EST Kevin: Dave?? 17/11/14 01:35 EST Kevin: begins pacing 17/11/14 04:17 EST Kevin: still pacing 17/11/14 07:01 EST Kevin: rings dave once again 17/11/14 07:02 EST Kevin: But Dave... We can have levels of detail, regional extracts, offline mobile routing... and we can open source it all 17/11/14 07:03 EST Dave: Hmm... Tiled. Hierarchical. Open. Routing. We could call it THOR. That's a pretty sweet acronym! That will make a great project name. But yeah... I'm not sure it'll work. Ok, so the above is slightly embellished (everyone knows Dave stopped answering his phone after that one weekend call about traffic on the NJ Turnpike), and let's just say Kevin's proposal was met with some degree of skepticism. But after reasoned consideration the team decided that tiled, hierarchical routing data had merits and was worth pursuing. Several months later, we have found that a tiled routing graph is possible and have begun exploring some of the benefits we'd hoped it would provide us and especially you! This GIF gives a conceptual overview of the tiles used in a resultant graph traversal and how the level of detail needed may change depending on the connectivity of the road network in a given region. Show me the What, Where and Why! \u00b6 So you can find all of our software at our Valhalla github organization. There's a lot of software there but most of it is modern c++ with a little bit of python for prototypes, a bit of ruby for chef style deployment and a bit of javascript for demo'ing some of the functionality. Onto the Why! \u00b6 We hope to enjoy some key benefits of a tile based approach to routing, they are as follows: Reduced memory requirements a connected graph can take up a lot of space in memory. By cutting the graph into a tiled structure you more easily impose limits on how much of the graph resides in memory at any one time. This could enable on device routing capabilities on even the most meager of hardware which could improve access to those in developing regions. Cacheability imagine a multi-level cache where an S3 bucket has a setting of constantly updated route tiles with proper http cache headers etc. Follow that up with a client side disk cache used to back a memory cache that the routing algorithm actually uses in graph traversal computations. Updateability updates to the graph could be highly parallelized simply because the graph is already broken up into a tiled structure. Faster turn around times on edits would be spectacular. Regional Extracts and Off-line Routing you're headed to Switzerland for vacation and you don't want to pony up the Francs to get a SIM card? Before you go, or while you're on wifi, download an extract of the region. Afterall it's only 100mb or so. Return to Route most phone based navigation applications require contacting a server when a user deviates from the specified route path, even for common cases like stopping for fuel or food. With graph tiles downloaded along the route path, the navigation application can find a path back to the route without an expensive call to the routing server. Enhanced Navigation tiles along the route allow more detailed information to be presented along the route without having to increase the payload in the initial call to the routing service. Exits along the highway, names of upcoming roads, and other information can be presented when graph tiles are present. We're excited with what we've accomplished so far, and look forward to showing you more soon. We plan to launch an open routing service as well as downloadable tiles later in the year. In the meantime though, have a quick browse of the code and reach out if something doesn't make sense!","title":"Why tiles?"},{"location":"mjolnir/why_tiles/#routing-tiles-the-who-what-when-where-how-and-why","text":"","title":"Routing Tiles - the Who, What, When, Where, How and Why?"},{"location":"mjolnir/why_tiles/#a-bit-of-the-who-when-and-how","text":"We had just started our new endeavor at Mapzen and were kicking around fundamental ideas of what our system should look like. Here's a bit of a transcript of how we got here: 17/11/14 01:27 EST Kevin: wakes up in a cold sweat and begins to fumble around for his phone 17/11/14 01:28 EST Kevin: violently stubs his toe on the sharpest lego he's ever witnessed 17/11/14 01:30 EST Kevin: cursing and slightly bloody, he manages to ring Dave 17/11/14 01:32 EST Dave: Uhnnng... 17/11/14 01:32 EST Kevin: Dave! What if we route on tiled data!? 17/11/14 01:33 EST Dave: Um... yeah... you've been working in the mapping world for far too long 17/11/14 01:33 EST Dave: throws his phone to the furthest corner of the room 17/11/14 01:34 EST Kevin: Dave?? 17/11/14 01:35 EST Kevin: begins pacing 17/11/14 04:17 EST Kevin: still pacing 17/11/14 07:01 EST Kevin: rings dave once again 17/11/14 07:02 EST Kevin: But Dave... We can have levels of detail, regional extracts, offline mobile routing... and we can open source it all 17/11/14 07:03 EST Dave: Hmm... Tiled. Hierarchical. Open. Routing. We could call it THOR. That's a pretty sweet acronym! That will make a great project name. But yeah... I'm not sure it'll work. Ok, so the above is slightly embellished (everyone knows Dave stopped answering his phone after that one weekend call about traffic on the NJ Turnpike), and let's just say Kevin's proposal was met with some degree of skepticism. But after reasoned consideration the team decided that tiled, hierarchical routing data had merits and was worth pursuing. Several months later, we have found that a tiled routing graph is possible and have begun exploring some of the benefits we'd hoped it would provide us and especially you! This GIF gives a conceptual overview of the tiles used in a resultant graph traversal and how the level of detail needed may change depending on the connectivity of the road network in a given region.","title":"A bit of the Who, When and How"},{"location":"mjolnir/why_tiles/#show-me-the-what-where-and-why","text":"So you can find all of our software at our Valhalla github organization. There's a lot of software there but most of it is modern c++ with a little bit of python for prototypes, a bit of ruby for chef style deployment and a bit of javascript for demo'ing some of the functionality.","title":"Show me the What, Where and Why!"},{"location":"mjolnir/why_tiles/#onto-the-why","text":"We hope to enjoy some key benefits of a tile based approach to routing, they are as follows: Reduced memory requirements a connected graph can take up a lot of space in memory. By cutting the graph into a tiled structure you more easily impose limits on how much of the graph resides in memory at any one time. This could enable on device routing capabilities on even the most meager of hardware which could improve access to those in developing regions. Cacheability imagine a multi-level cache where an S3 bucket has a setting of constantly updated route tiles with proper http cache headers etc. Follow that up with a client side disk cache used to back a memory cache that the routing algorithm actually uses in graph traversal computations. Updateability updates to the graph could be highly parallelized simply because the graph is already broken up into a tiled structure. Faster turn around times on edits would be spectacular. Regional Extracts and Off-line Routing you're headed to Switzerland for vacation and you don't want to pony up the Francs to get a SIM card? Before you go, or while you're on wifi, download an extract of the region. Afterall it's only 100mb or so. Return to Route most phone based navigation applications require contacting a server when a user deviates from the specified route path, even for common cases like stopping for fuel or food. With graph tiles downloaded along the route path, the navigation application can find a path back to the route without an expensive call to the routing server. Enhanced Navigation tiles along the route allow more detailed information to be presented along the route without having to increase the payload in the initial call to the routing service. Exits along the highway, names of upcoming roads, and other information can be presented when graph tiles are present. We're excited with what we've accomplished so far, and look forward to showing you more soon. We plan to launch an open routing service as well as downloadable tiles later in the year. In the meantime though, have a quick browse of the code and reach out if something doesn't make sense!","title":"Onto the Why!"},{"location":"sif/dynamic-costing/","text":"SIF - Dynamic Costing within Valhalla \u00b6 Two core components of the Valhalla open source routing engine are Thor and Sif . These 2 companions (in Norse mythoogy Thor and Sif are husband and wife) form the basis of Valhalla's path generation algorithm. Thor contains the path computation algorithms and traverses the routing tiles, while Sif performs costing that is central to forming the best path. Rather than baking costs into the routing graph data, Valhalla uses dynamic, run-time costing to generate costs based on a rich set of attributes stored in the routing graph tiles. This allows run-time generation of different types of routes (or routes with different characteristics) simply by using different costing methods and options within those methods. Path Costing Introduction \u00b6 Routing from one location to another is solved by a class of algorithms known as shortest path algorithms . This is somewhat misleading, as often one is interested in a route that is shortest time or one that makes fewer turns. A better term for shortest path algorithms is least cost algorithms - this properly indicates that the method is minimizing cost, be it distance, time, or some other metric. Naive assignment of cost to edges of the routing graph will lead to poor routing solutions. Simple costing based solely on distance or on time (based solely on speed) can lead to poor route paths with excessive turns and stops. Considerations such as turn types, classifications of roads at intersections along the route, road surface type, elevation change, road curvature, and a host of other considerations can be important. It is also important to note that different costing considerations are needed for bicycle routing than pedestrian routing or automobile routing. Dynamic Costing \u00b6 Valhalla uses dynamic, run-time costing when computing route paths and can consider much more than strict time or distance. Different route types can be computed from a single set of route data tiles. There is no need to configure data each time a new routing profile is needed. Simply change the costing methods or apply different options to existing costing methods, the data stays the same. Costing Interface \u00b6 Costing methods have access to all attributes of an edge (road section between 2 intersections) to form the cost along the edge and when transitoning between edges. Within Sif, costing methods are created by deriving a class from the base dynamic costing class or one of the existing costing classes. Each costing method must override 3 different methods to create the unique costing logic: virtual bool Allowed(const baldr::NodeInfo* node) const = 0; Checks if access is allowed for the provided node. For example, node access can be restricted for specific modes of travel if bollards are present. virtual bool Allowed(const baldr::DirectedEdge* edge, const EdgeLabel& pred) const = 0; Checks if access is allowed for the provided directed edge based on the prior edge along the path. This is generally based on mode of travel and the access modes allowed on the edge. It can also be used to prohibit turns where turn restrictions exist, prohibit Uturns, and to prohibit entering roads that do not have through paths. virtual Cost EdgeCost(const baldr::DirectedEdge* edge, const uint32_t density) const = 0; This method gets the cost to traverse the specified directed edge. Cost includes a path cost along with the actual time (seconds) to traverse the edge. Path costs are generally time or distance and can include artificial cost penalties to avoid roads/edges with specific attributes. By returning the actual elapsed time in seconds the costing method can be applied to time dependent and schedule based routing (e.g. transit). Costing methods can also compute edge transition costs , sometimes called turn costs. These costs are applied at the node/intersection when transitioning from one edge to another. A fourth costing method can be defined in the costing class to account for this: virtual Cost TransitionCost(const baldr::DirectedEdge* edge, const baldr::NodeInfo* node, const EdgeLabel& pred) const; Edge transition costs generally consider 3 things: Turn type - whether the turn is a left turn, right turn, or is crossing another road. The cost applied to the turn type also needs to know if driving is done on the left side or right side of the road. While left turns are generally more costly in the US than right turns, the opposite holds in UK. Likelihood of stopping - higher costs should be applied where there is a high likelihood of stopping when going from one road to another. Examples are when crossing a higher class road while on a lower class road. The opposite occurs when on a higher class road - transitions at intersections with lower class roads usually do not require a stop. Name consistency - this one is less intuitive. By applying small cost penalties when going from a road with one name onto one with a different name can lead to \"simpler\" route paths where there are less maneuvers or turns that need description. In addition to these general cases, edge transition costing can be used to apply penalties for specific cases like crossing a country border, going onto a toll road, entering a road that has private access, and other cases where the route path might want to avoid specific roads or types of conditions! A good example of how edge transition costs can affect a route path is a driving route in a gridded downtown area. A shortest time or distance path can make many different turns as it zig-zags from the origin to the destination. Applying edge transition costs will reduce the number of turns and create a much simpler route that is often shorter time in practice. The first image below is without edge transition costs - it makes additional turns that complicate the path description. The second image shows the path with edge transition costs applied - there are fewer turns leading to a simpler route. Note also in the first image that the estimated time is much less - this shows how important edge transition costs are to estimating the time along a route. SIF costing for driving routes (auto) penalizes left hand turns more than right hand turns by default (in countries where driving occurs on the left hand side of the road the opposite occurs). The simple example below shows a case where a longer path is taken so that left turns are avoided. In this case, two right hand turns are made and the route is much longer (almost 700 meters rather than 100 meters).","title":"Dynamic costing"},{"location":"sif/dynamic-costing/#sif-dynamic-costing-within-valhalla","text":"Two core components of the Valhalla open source routing engine are Thor and Sif . These 2 companions (in Norse mythoogy Thor and Sif are husband and wife) form the basis of Valhalla's path generation algorithm. Thor contains the path computation algorithms and traverses the routing tiles, while Sif performs costing that is central to forming the best path. Rather than baking costs into the routing graph data, Valhalla uses dynamic, run-time costing to generate costs based on a rich set of attributes stored in the routing graph tiles. This allows run-time generation of different types of routes (or routes with different characteristics) simply by using different costing methods and options within those methods.","title":"SIF - Dynamic Costing within Valhalla"},{"location":"sif/dynamic-costing/#path-costing-introduction","text":"Routing from one location to another is solved by a class of algorithms known as shortest path algorithms . This is somewhat misleading, as often one is interested in a route that is shortest time or one that makes fewer turns. A better term for shortest path algorithms is least cost algorithms - this properly indicates that the method is minimizing cost, be it distance, time, or some other metric. Naive assignment of cost to edges of the routing graph will lead to poor routing solutions. Simple costing based solely on distance or on time (based solely on speed) can lead to poor route paths with excessive turns and stops. Considerations such as turn types, classifications of roads at intersections along the route, road surface type, elevation change, road curvature, and a host of other considerations can be important. It is also important to note that different costing considerations are needed for bicycle routing than pedestrian routing or automobile routing.","title":"Path Costing Introduction"},{"location":"sif/dynamic-costing/#dynamic-costing","text":"Valhalla uses dynamic, run-time costing when computing route paths and can consider much more than strict time or distance. Different route types can be computed from a single set of route data tiles. There is no need to configure data each time a new routing profile is needed. Simply change the costing methods or apply different options to existing costing methods, the data stays the same.","title":"Dynamic Costing"},{"location":"sif/dynamic-costing/#costing-interface","text":"Costing methods have access to all attributes of an edge (road section between 2 intersections) to form the cost along the edge and when transitoning between edges. Within Sif, costing methods are created by deriving a class from the base dynamic costing class or one of the existing costing classes. Each costing method must override 3 different methods to create the unique costing logic: virtual bool Allowed(const baldr::NodeInfo* node) const = 0; Checks if access is allowed for the provided node. For example, node access can be restricted for specific modes of travel if bollards are present. virtual bool Allowed(const baldr::DirectedEdge* edge, const EdgeLabel& pred) const = 0; Checks if access is allowed for the provided directed edge based on the prior edge along the path. This is generally based on mode of travel and the access modes allowed on the edge. It can also be used to prohibit turns where turn restrictions exist, prohibit Uturns, and to prohibit entering roads that do not have through paths. virtual Cost EdgeCost(const baldr::DirectedEdge* edge, const uint32_t density) const = 0; This method gets the cost to traverse the specified directed edge. Cost includes a path cost along with the actual time (seconds) to traverse the edge. Path costs are generally time or distance and can include artificial cost penalties to avoid roads/edges with specific attributes. By returning the actual elapsed time in seconds the costing method can be applied to time dependent and schedule based routing (e.g. transit). Costing methods can also compute edge transition costs , sometimes called turn costs. These costs are applied at the node/intersection when transitioning from one edge to another. A fourth costing method can be defined in the costing class to account for this: virtual Cost TransitionCost(const baldr::DirectedEdge* edge, const baldr::NodeInfo* node, const EdgeLabel& pred) const; Edge transition costs generally consider 3 things: Turn type - whether the turn is a left turn, right turn, or is crossing another road. The cost applied to the turn type also needs to know if driving is done on the left side or right side of the road. While left turns are generally more costly in the US than right turns, the opposite holds in UK. Likelihood of stopping - higher costs should be applied where there is a high likelihood of stopping when going from one road to another. Examples are when crossing a higher class road while on a lower class road. The opposite occurs when on a higher class road - transitions at intersections with lower class roads usually do not require a stop. Name consistency - this one is less intuitive. By applying small cost penalties when going from a road with one name onto one with a different name can lead to \"simpler\" route paths where there are less maneuvers or turns that need description. In addition to these general cases, edge transition costing can be used to apply penalties for specific cases like crossing a country border, going onto a toll road, entering a road that has private access, and other cases where the route path might want to avoid specific roads or types of conditions! A good example of how edge transition costs can affect a route path is a driving route in a gridded downtown area. A shortest time or distance path can make many different turns as it zig-zags from the origin to the destination. Applying edge transition costs will reduce the number of turns and create a much simpler route that is often shorter time in practice. The first image below is without edge transition costs - it makes additional turns that complicate the path description. The second image shows the path with edge transition costs applied - there are fewer turns leading to a simpler route. Note also in the first image that the estimated time is much less - this shows how important edge transition costs are to estimating the time along a route. SIF costing for driving routes (auto) penalizes left hand turns more than right hand turns by default (in countries where driving occurs on the left hand side of the road the opposite occurs). The simple example below shows a case where a longer path is taken so that left turns are avoided. In this case, two right hand turns are made and the route is much longer (almost 700 meters rather than 100 meters).","title":"Costing Interface"},{"location":"sif/elevation_costing/","text":"Elevation Influenced Bicycle Routing \u00b6 Mapzen and the Valhalla team recently announced updates to their bicycle routing service: Bicycle Routing with Valhalla . Now we have taken it to greater heights by adding \"elevation influenced\" bicycle routing. We are pleased to announce the addition of elevation and grade factors into the bicycle costing model. How badly do you want to avoid those steep hills on your next ride!? Bicycle routing presents several unique challenges. Among the challenges are the wide range of user abilities, preferences, and equipment. Bicyclists vary in their experience and comfort level using roadways shared with larger vehicles (e.g. automobiles, buses, trucks). Different bicycle types are more or less suitable to the wide variety of road and path surfaces. The wide range of physical ability of bicyclists also comes into play when selecting routes in locations where hills and steep grades might be present. The Valhalla team at Mapzen feels these factors all play into one of the strengths of the Valhalla routing engine - its dynamic, run-time costing module known as Sif . Further background on Sif can be found in our prior blog post: Dynamic Costing in Valhalla . Addition of Elevation Factors into Valhalla Routing Tiles \u00b6 In order to measure the change in elevation over a given segment of road, we've built a library (and service) called Skadi ; the goddess of the mountains. Skadi has the ability to efficiently query world-wide digital elevation model data. We use this library when building routing tiles to estimate the prevaling grade/slope of a given section of road. We call this the weighted grade. Here's how it works. Given a segment of road, we evenly sample points (at 60m apart) along it. At each sample, we measure the elevation. We then compute the grade/slope between each pair of sample points and weight it using the above function. This is essentially a linear combination designed to approximate the overall grade/slope of a given segment of road. You'll notice that sections with higher upward slope are weighted more and that conversely higher downward slopes are weighted less. The intuition is that steeper sections will require more \"cost\" to traverse whether walking, biking or driving. If you're biking the unit of cost might be time, since you can't ride as fast up steep hills. When driving the unit of cost might be the fuel used to overcome inertia. In any case, we are attempting to measure approximately how much energy might be needed to traverse a given section of road so that we can minimize (or maximize!?) it, along with other factors, when computing your path! Adding Grade Factors to Dynamic Costing \u00b6 The weighted grade is used within bicycle costing in 2 ways: Weighted grade impacts the speed / resulting time along an edge. The default speed used for bicycle routing is assumed to be the average speed the bicyclist can mainatin on level grades over the length of the route. This speed is modulated based on the weighted grade: increased for grades indicating a descent, and decreased for uphill grades. The higher the weighting factor the steeper the \"average\" grade along the edge, resulting in a higher reduction of speed results. Thus, the weighted grade of an edge impacts the time along the edge and helps avoid steep grades. It also helps provide a beter estimate of the actual time along the route. In general, routes with hills take longer than routes on level ground. A second use for weighted grade considers the bicyclists desire to avoid or use hills in the route. A single option called use_hills has been added to the Valhalla bicycle costing module. This option is similar to the use_roads option. It is a value from 0 to 1.0 indicating the bicyclists comfort level with hills and steep grades. A value of 1.0 indicates a strong, experienced cyclists who does not mind a path with hills. A value of 0.0 indicates the cyclist wishes to find paths that try to avoid hills. Based on this fact, extra cost (penalties) are applied to edges based on the grade. Note that penalties are applied to downhill grades as well! The old adage among cyclists is that what goes down, eventually must go up so after every long downhill there will eventually be a long uphill! Examples \u00b6 The following cases illustrate a set of hills I used to ride in my early days of cycling. This is an area near Ellicott City, MD starting at a point on Illchester Road along the Patapsco River and ending near the end of Illchester Road close to Montgomery Road. The shortest path is to head straight up Illchester Road. The problem is the initial part of the hill is roughly 16-18% for the first 400 meters. A hill-climb time trial race is held on this hill, so it is only for strong riders or those looking for a challenge. After the initial steep section, Illchester Road continues with a more gradual climb and then levels off. With a use_hills factor of 1.0 the shortest distance and shortest time path is taken - straight up the steep hill. For those with less inclination to tackle steep grades, we can try to find an alternate path by setting the use_hills factor to 0.5. This might be for someone who doesn't want to go too far out of the way to avoid a hill. In this example the path avoids the steep section of Illchester Road, instead choosing a less steep uphill path (Bonnie Branch Road onto Beechwood Road then back onto Illchester) to get to the top of Illchester hill. Here the elevation slowly rises from 30 meters to 150 meters over approximately 2km. This is an average grade of 6% - still uphill but much less strenuous. For a novice bicyclist or one who wishes to avoid hills, we can try a use_hills factor of 0.0. Here, a longer path up the more gradual climb along Bonnie Branch Road (approximately 5% average grade) is taken the entire way to Montgomery Road and then the path backtracks to get to the destination along Illchester Road. Here the route is nearly 1km longer than the shortest route (4.35km vs 3.5 km) and takes 3 minutes longer (14 minutes vs. 11 minutes), but with the extra cost penalties applied to the steeper grades the path ends up along the most gradual path out of the river valley. The sample images here were created using a combination of Valhalla routing including the elevation influenced bicycle route API as well as the new Mapzen Elevation Service API to get the range/height profile information to create the elevation chart. The output route path information (an encoded string of latitude,longitude positions along the path) is sent directly to the elevation service to get the heights along the path for charting.","title":"Elevation influenced bicycle routing"},{"location":"sif/elevation_costing/#elevation-influenced-bicycle-routing","text":"Mapzen and the Valhalla team recently announced updates to their bicycle routing service: Bicycle Routing with Valhalla . Now we have taken it to greater heights by adding \"elevation influenced\" bicycle routing. We are pleased to announce the addition of elevation and grade factors into the bicycle costing model. How badly do you want to avoid those steep hills on your next ride!? Bicycle routing presents several unique challenges. Among the challenges are the wide range of user abilities, preferences, and equipment. Bicyclists vary in their experience and comfort level using roadways shared with larger vehicles (e.g. automobiles, buses, trucks). Different bicycle types are more or less suitable to the wide variety of road and path surfaces. The wide range of physical ability of bicyclists also comes into play when selecting routes in locations where hills and steep grades might be present. The Valhalla team at Mapzen feels these factors all play into one of the strengths of the Valhalla routing engine - its dynamic, run-time costing module known as Sif . Further background on Sif can be found in our prior blog post: Dynamic Costing in Valhalla .","title":"Elevation Influenced Bicycle Routing"},{"location":"sif/elevation_costing/#addition-of-elevation-factors-into-valhalla-routing-tiles","text":"In order to measure the change in elevation over a given segment of road, we've built a library (and service) called Skadi ; the goddess of the mountains. Skadi has the ability to efficiently query world-wide digital elevation model data. We use this library when building routing tiles to estimate the prevaling grade/slope of a given section of road. We call this the weighted grade. Here's how it works. Given a segment of road, we evenly sample points (at 60m apart) along it. At each sample, we measure the elevation. We then compute the grade/slope between each pair of sample points and weight it using the above function. This is essentially a linear combination designed to approximate the overall grade/slope of a given segment of road. You'll notice that sections with higher upward slope are weighted more and that conversely higher downward slopes are weighted less. The intuition is that steeper sections will require more \"cost\" to traverse whether walking, biking or driving. If you're biking the unit of cost might be time, since you can't ride as fast up steep hills. When driving the unit of cost might be the fuel used to overcome inertia. In any case, we are attempting to measure approximately how much energy might be needed to traverse a given section of road so that we can minimize (or maximize!?) it, along with other factors, when computing your path!","title":"Addition of Elevation Factors into Valhalla Routing Tiles"},{"location":"sif/elevation_costing/#adding-grade-factors-to-dynamic-costing","text":"The weighted grade is used within bicycle costing in 2 ways: Weighted grade impacts the speed / resulting time along an edge. The default speed used for bicycle routing is assumed to be the average speed the bicyclist can mainatin on level grades over the length of the route. This speed is modulated based on the weighted grade: increased for grades indicating a descent, and decreased for uphill grades. The higher the weighting factor the steeper the \"average\" grade along the edge, resulting in a higher reduction of speed results. Thus, the weighted grade of an edge impacts the time along the edge and helps avoid steep grades. It also helps provide a beter estimate of the actual time along the route. In general, routes with hills take longer than routes on level ground. A second use for weighted grade considers the bicyclists desire to avoid or use hills in the route. A single option called use_hills has been added to the Valhalla bicycle costing module. This option is similar to the use_roads option. It is a value from 0 to 1.0 indicating the bicyclists comfort level with hills and steep grades. A value of 1.0 indicates a strong, experienced cyclists who does not mind a path with hills. A value of 0.0 indicates the cyclist wishes to find paths that try to avoid hills. Based on this fact, extra cost (penalties) are applied to edges based on the grade. Note that penalties are applied to downhill grades as well! The old adage among cyclists is that what goes down, eventually must go up so after every long downhill there will eventually be a long uphill!","title":"Adding Grade Factors to Dynamic Costing"},{"location":"sif/elevation_costing/#examples","text":"The following cases illustrate a set of hills I used to ride in my early days of cycling. This is an area near Ellicott City, MD starting at a point on Illchester Road along the Patapsco River and ending near the end of Illchester Road close to Montgomery Road. The shortest path is to head straight up Illchester Road. The problem is the initial part of the hill is roughly 16-18% for the first 400 meters. A hill-climb time trial race is held on this hill, so it is only for strong riders or those looking for a challenge. After the initial steep section, Illchester Road continues with a more gradual climb and then levels off. With a use_hills factor of 1.0 the shortest distance and shortest time path is taken - straight up the steep hill. For those with less inclination to tackle steep grades, we can try to find an alternate path by setting the use_hills factor to 0.5. This might be for someone who doesn't want to go too far out of the way to avoid a hill. In this example the path avoids the steep section of Illchester Road, instead choosing a less steep uphill path (Bonnie Branch Road onto Beechwood Road then back onto Illchester) to get to the top of Illchester hill. Here the elevation slowly rises from 30 meters to 150 meters over approximately 2km. This is an average grade of 6% - still uphill but much less strenuous. For a novice bicyclist or one who wishes to avoid hills, we can try a use_hills factor of 0.0. Here, a longer path up the more gradual climb along Bonnie Branch Road (approximately 5% average grade) is taken the entire way to Montgomery Road and then the path backtracks to get to the destination along Illchester Road. Here the route is nearly 1km longer than the shortest route (4.35km vs 3.5 km) and takes 3 minutes longer (14 minutes vs. 11 minutes), but with the extra cost penalties applied to the steeper grades the path ends up along the most gradual path out of the river valley. The sample images here were created using a combination of Valhalla routing including the elevation influenced bicycle route API as well as the new Mapzen Elevation Service API to get the range/height profile information to create the elevation chart. The output route path information (an encoded string of latitude,longitude positions along the path) is sent directly to the elevation service to get the heights along the path for charting.","title":"Examples"},{"location":"thor/isochrones/","text":"What are Isochrone Maps? \u00b6 Recently valhalla has gained the ability to return these amazing structures called isochrones. What's an isochrone? The word is a combination of two greek roots iso meaning equal and chrono meaning time. So indeed, an isochrone is a structure representing equal time. In our case it's a line that represents constant travel time about a given location. One can think of isochrone maps as somewhat similar to the familiar topographic maps except that instead of lines of constant height, lines are of constant travel time are depicted. For this reason other terms common in topography apply such as contours or isolines. In this image the green, yellow, orange and red contour lines represent 15, 30, 45 and 60 minutes of driving time respectively. How are Isochrone Maps Useful? \u00b6 Isochrone maps can be used to make informed decisions about travel at both an individual level and en masse. You can get quantitative answeres to questions like: What are our lunch options within 5 minutes from here? How much of the city lives within walking range of public transit? What would adding/removing this road/bus stop/bridge do to travel times? Where can I find housing that still has a reasonable commute to the office? In other words planning departments of DOTs all the way down to consumer applications will have use-cases that call for such an isochrone map service. Technical Details \u00b6 Isochrones are formed in Valhalla by first creating a 2-D grid in latitiude,longitude about the location. This 2-D grid or array is used to define the time or cost it takes to get from the target location to each other grid location. This grid is populated by doing a breadth-first, least-cost first search (basically Dijkstra) from the origin location. At each iteration, the grid cells that are touched by a road segment or graph edge are marked with the time and cost from the origin, if less than the currently marked time. Once the expansion of the graph exceeds the maximum isochrone contour time the grid-marking process terminates. This leaves a 2-D grid or array that has the time or cost to reach each grid location. The 2-D grid is used to find the isocrhone contours by using a well-known contouring method developed by Paul Bourke in the 1980s: contouring . This method finds grid cells that have neighboring cells where values lie on opposing sides of the contour value: for example the current cell has a time value above the contour value and a neighbor has a time value below the contour value. The contouring algorithm generates line segments through grid cells corners or centers based on several possible cases. The tricky part is pieceing these line segments together to form closed contour lines. After forming sets of contour polygons, KEVIN -please write a paragraph or 2 to describe how the contours are formed and output! This 2-D grid of times can be useful for other purposes as well. It provides a very fast way to query a single location to see how long it takes to get there from the test location. Ultimately this could be a way to do very large one-to-many matrices. At this time we do not return the 2-D array of times, but this is a possibility in the future. Where is it? \u00b6 You can find the API documentation here and you see a live demo of it right here .","title":"Isochrones"},{"location":"thor/isochrones/#what-are-isochrone-maps","text":"Recently valhalla has gained the ability to return these amazing structures called isochrones. What's an isochrone? The word is a combination of two greek roots iso meaning equal and chrono meaning time. So indeed, an isochrone is a structure representing equal time. In our case it's a line that represents constant travel time about a given location. One can think of isochrone maps as somewhat similar to the familiar topographic maps except that instead of lines of constant height, lines are of constant travel time are depicted. For this reason other terms common in topography apply such as contours or isolines. In this image the green, yellow, orange and red contour lines represent 15, 30, 45 and 60 minutes of driving time respectively.","title":"What are Isochrone Maps?"},{"location":"thor/isochrones/#how-are-isochrone-maps-useful","text":"Isochrone maps can be used to make informed decisions about travel at both an individual level and en masse. You can get quantitative answeres to questions like: What are our lunch options within 5 minutes from here? How much of the city lives within walking range of public transit? What would adding/removing this road/bus stop/bridge do to travel times? Where can I find housing that still has a reasonable commute to the office? In other words planning departments of DOTs all the way down to consumer applications will have use-cases that call for such an isochrone map service.","title":"How are Isochrone Maps Useful?"},{"location":"thor/isochrones/#technical-details","text":"Isochrones are formed in Valhalla by first creating a 2-D grid in latitiude,longitude about the location. This 2-D grid or array is used to define the time or cost it takes to get from the target location to each other grid location. This grid is populated by doing a breadth-first, least-cost first search (basically Dijkstra) from the origin location. At each iteration, the grid cells that are touched by a road segment or graph edge are marked with the time and cost from the origin, if less than the currently marked time. Once the expansion of the graph exceeds the maximum isochrone contour time the grid-marking process terminates. This leaves a 2-D grid or array that has the time or cost to reach each grid location. The 2-D grid is used to find the isocrhone contours by using a well-known contouring method developed by Paul Bourke in the 1980s: contouring . This method finds grid cells that have neighboring cells where values lie on opposing sides of the contour value: for example the current cell has a time value above the contour value and a neighbor has a time value below the contour value. The contouring algorithm generates line segments through grid cells corners or centers based on several possible cases. The tricky part is pieceing these line segments together to form closed contour lines. After forming sets of contour polygons, KEVIN -please write a paragraph or 2 to describe how the contours are formed and output! This 2-D grid of times can be useful for other purposes as well. It provides a very fast way to query a single location to see how long it takes to get there from the test location. Ultimately this could be a way to do very large one-to-many matrices. At this time we do not return the 2-D array of times, but this is a possibility in the future.","title":"Technical Details"},{"location":"thor/isochrones/#where-is-it","text":"You can find the API documentation here and you see a live demo of it right here .","title":"Where is it?"},{"location":"thor/path-algorithm/","text":"Thor - Determining the Best Path \u00b6 Two core components of the Valhalla open source routing engine are Thor and Sif . These 2 companions (in Norse mythology Thor and Sif are husband and wife) form the basis of Valhalla's path generation algorithm. Thor contains the path computation algorithms and traverses the routing tiles, while Sif performs costing that is central to forming the best path. Rather than baking costs into the routing graph data, Valhalla uses dynamic, run-time costing to generate costs based on a rich set of attributes stored in the routing graph tiles. This allows run-time generation of different types of routes (or routes with different characteristics) simply by using different costing methods and options within those methods. Path Algorithm Introduction \u00b6 Routing from one location to another is solved by a class of algorithms known as shortest path algorithms . This is somewhat misleading, as often one is interested in a route that is shortest time or one that makes fewer turns. A better term for shortest path algorithms is least cost algorithms - this properly indicates that the method is minimizing cost, be it distance, time, or some other metric. Naive assignment of cost to edges of the routing graph will lead to poor routing solutions. Simple costing based solely on distance or on time (based solely on speed) can lead to poor route paths with excessive turns and stops. Considerations such as turn types, classifications of roads at intersections along the route, road surface type, elevation change, road curvature, and a host of other considerations can be important. It is also important to note that different costing considerations are needed for bicycle routing than pedestrian routing or automobile routing. Dynamic costing is described here . Valhalla uses several levels of road hierarchies to enhance performance. The lowest level hierarchy is called the local level. The local level includes all roads and paths that are routable (using various access methods). The next hierarchy level is called arterial. This level drops out all paths and residential roads. The highest level is called the highway level. This level includes just motorways, trunk roads, and primary roads - these are roads needed for long routes. By transitioning to the higher hierarchy levels as the route path moves away from the origin or destination the path finding algorithm considers less roads - improving performance. Also, shortcut edges are formed on the arterial and highway hierarchies. These edges bypass intersections that only connect to lower hierarchy edges. This allows several edges to be combined into one longer edge, which also improves performance. Thor uses several different algorithms to compute the least cost path. These algorithms are described below. A* \u00b6 The basic algorithm provided within Thor is an A* algorithm. This algorithm searches in one direction - from the origin towards the destination. The A* heuristic is added to the cost to help guide the search more rapidly towards the destination. The A* method has been superceded for most cases by the bidirectional A* algorithm which has better performance. Also, the A* algorithm does not work as well with transitions to upper hierarchy levels as the path approaches the destination. Bidirectional A* \u00b6 The primary algorithm used for most types of routes is a bidirectional A* method. This algorithm searches for the lowest cost path in two directions: one from the origin towards the destination and the other \"backwards\" from the destination towards the origin. This algorithm has better performance then the A* algorithm since it more effectively cuts the search space. However, there are some complexities added to handle the backwards progression from the destination to the origin. Turn restrictions and transition costing is more complicated. Also, the determination of the connection point between the two searches (determination of route completion) is more complex. Another strength of the bidirectional A* method is that hierarchy transitions near the destination are simplified. Currently bidirectional A* performs only invariant behaviour of traffic update, there is no algorithm implemented for correct evaluation of edge passing time. Pedestrian and bicycle routes use just the local graph hierarchy. They never transition to the arterial or highway levels and thus never use shortcut edges. The bidirectional A* algorithm makes use of edge markings that enter regions where no through path exists. These are areas of the routing graph that represent cul-de-sas, dead-end roads, and even larger communities where there is only one entrance. The search paths can exclude ever entering an edge that is marked as \"not-though\". Multi-modal \u00b6 Multi-modal routes use an A* method that is enahanced to allow time-dependency and mode changes. Public transit information includes schedule information that find the next departure along directed edges between transit stops. Unique pairs of transit stops and routes create separate graph edges with a unique line-id to which departure schedules can be associated. A* Heuristic \u00b6 A simple class within Thor handles the A* heuristic computation. At the beginning of PathAlgorithm::GetBestPath the A* heuristic is initialized with the latitude, longitude of the destination and a costing factor to multiply distance estimates with. This factor needs to be tied to the costing model to multiply distance that will underestimate the cost to the destination, but keep close to a reasonable true cost so that performance is kept high. For example, in automobile costing the factor is based on the highest speed expected - thus any straight line distance estimate from a specific location will undersestimate the true cost on any path on real roads to get to the destination. Distance estimates are computed using a distance approximation method that computes a Euclidean distance using meters per degree of latitude and an estimate of meters per degree of longitude based on the destination latitude. This produces a close approximation of the arc distance along the surface of the earth while providing a distance measure that is locally stable (nearby locations will get consistent and close distance approximations). Edge Labeling \u00b6 Thor marks directed edges in the routing graph rather than nodes. This allows a node to be traversed multiple times in a route with different directed edges. This allows turn restrictions to be incorporated into the data and the path algorithm. This is demonstrated in the following example where a left turn is not allowed at an intersection. Rather the route must take a separate turn lane to the right and loop back through the intersection. The least cost path to the intersection node is to proceed straight. If the node were marked it would prevent traversing the node after using the turn lane since that path is higher cost. Each directed edge in the routing graph can have three states: Not Visited - An edge that is not visited has not yet been encountered within the PathAlgorithm graph traversal. Temporary - An edge that has been visited or encountered but there could still be a lower cost path to this edge. This edge will be \"adjacent\" or connected to an edge that is permanently labeled. Temporary edges are noted in the Adjacency List and are sorted such that they are \"expanded\" in order of lowest cost. Permanent - Lowest cost path to this edge has been found. Edges that have been visited are stored in a vector with an EdgeLabel structure that contains information about the path up to this edge. In particular the predecessor edge is stored. This allows the shortest path of directed edges to be constructed by using each edges predecessor information to walk the path backwards. Additional information about the path to get to the directed edge is also kept. This information includes: Edge Id - Graph Id of the edge. Opposing edge Id - Graph Id of the opposing edge (for bidirectional A*). End node - GraphId of the end node of the edge. This allows the expansion to occur by reading the node and not having to re-read the directed edge to find its end node. Cost - Cost and elapsed time in seconds along the path to this edge. Sort cost - Cost including includes A* heuristic. Distance - An estimate of the straight line distance to the destination. Predecessor edge - Index to the predecessor edge label information within the EdgeLabels list. Several other pieces of information about the prior edge are also kept to avoid having to re-read an edge. In addition, several transit specific attributes are added for multi-modal routes. Edge Status \u00b6 An unordered map (hash map) is used to identify the state of directed edges. The map contains tile id as key and array of EdgeStatusInfo which contains index of the edge in the EdgeLabels vector and the current edge label state: kUnreachedOrReset, temporary or permanent. Whenever a new tile (new edge in previously unvisited tile) is encountered a new value in the map is inserted with key as tile id and EdgeStatusInfo array of length equal to number of directed edges in the tile as value, all directed edges in the new array are initialized with kUnreachedOrReset status. The index of edge in EdgeStatusInfo array is equal to it's id in the tile EdgeStatus is constructed given an initial size of the edge status map. To avoid rehashing the initial size should be large enough. Set - Sets the status of a directed edge given its GraphId. Update - Updates the status of a directed edge given its GraphId. Get - Gets the status info of a directed edge given its GraphId. Adjacency List \u00b6 The AdjacencyList class provides a sorting order to the edge labels that are marked as temporary and are adjacent to edges that have lowest cost path found. The adjacency list uses a bucket sort implementation for performance. An \"overflow\" bucket is maintained to allow reduced memory use - costs outside the current bucket range get placed into the overflow bucket and are moved into the low-level buckets as needed. The adjacency list stores indexes into a list (vector) of labels where complete cost and predecessor information are stored. The adjacency list simply provides a fast sorting method. Benchmarks show a marked improvement over using an STL priority_queue, even in cases where the overflow bucket is utilized. An AdjacencyList is contructed using a minimum cost (based on the A* heuristic distance from the origin location to the destination location), a range of costs held within the bucket sort, and a bucket size. All costs above mincost + range are stored in an \"overflow\" bucket. The following methods are provided in the AdjacencyList class: Add - Adds a label index to the sorted list. Adds it to the appropriate bucket given the sort cost. If the sortcost is greater than maxcost_ the label is placed in the overflow bucket. If the sortcost is < the current bucket cost then the label is placed at the front of the current bucket (this prevents underflow). DecreaseCost - The specified label index now has a smaller cost. Reorders it in the sorted bucket list. Clear - Clear all labels from from the adjacency list. Called at the start of the path finding algorithm, Remove - Removes the lowest cost label index from the sorted list. EmptyOverflow - Empties the overflow bucket by placing the label indexes into the low level buckets. This method is private and is called from the Remove method when needed.","title":"Path algorithm"},{"location":"thor/path-algorithm/#thor-determining-the-best-path","text":"Two core components of the Valhalla open source routing engine are Thor and Sif . These 2 companions (in Norse mythology Thor and Sif are husband and wife) form the basis of Valhalla's path generation algorithm. Thor contains the path computation algorithms and traverses the routing tiles, while Sif performs costing that is central to forming the best path. Rather than baking costs into the routing graph data, Valhalla uses dynamic, run-time costing to generate costs based on a rich set of attributes stored in the routing graph tiles. This allows run-time generation of different types of routes (or routes with different characteristics) simply by using different costing methods and options within those methods.","title":"Thor - Determining the Best Path"},{"location":"thor/path-algorithm/#path-algorithm-introduction","text":"Routing from one location to another is solved by a class of algorithms known as shortest path algorithms . This is somewhat misleading, as often one is interested in a route that is shortest time or one that makes fewer turns. A better term for shortest path algorithms is least cost algorithms - this properly indicates that the method is minimizing cost, be it distance, time, or some other metric. Naive assignment of cost to edges of the routing graph will lead to poor routing solutions. Simple costing based solely on distance or on time (based solely on speed) can lead to poor route paths with excessive turns and stops. Considerations such as turn types, classifications of roads at intersections along the route, road surface type, elevation change, road curvature, and a host of other considerations can be important. It is also important to note that different costing considerations are needed for bicycle routing than pedestrian routing or automobile routing. Dynamic costing is described here . Valhalla uses several levels of road hierarchies to enhance performance. The lowest level hierarchy is called the local level. The local level includes all roads and paths that are routable (using various access methods). The next hierarchy level is called arterial. This level drops out all paths and residential roads. The highest level is called the highway level. This level includes just motorways, trunk roads, and primary roads - these are roads needed for long routes. By transitioning to the higher hierarchy levels as the route path moves away from the origin or destination the path finding algorithm considers less roads - improving performance. Also, shortcut edges are formed on the arterial and highway hierarchies. These edges bypass intersections that only connect to lower hierarchy edges. This allows several edges to be combined into one longer edge, which also improves performance. Thor uses several different algorithms to compute the least cost path. These algorithms are described below.","title":"Path Algorithm Introduction"},{"location":"thor/path-algorithm/#a","text":"The basic algorithm provided within Thor is an A* algorithm. This algorithm searches in one direction - from the origin towards the destination. The A* heuristic is added to the cost to help guide the search more rapidly towards the destination. The A* method has been superceded for most cases by the bidirectional A* algorithm which has better performance. Also, the A* algorithm does not work as well with transitions to upper hierarchy levels as the path approaches the destination.","title":"A*"},{"location":"thor/path-algorithm/#bidirectional-a","text":"The primary algorithm used for most types of routes is a bidirectional A* method. This algorithm searches for the lowest cost path in two directions: one from the origin towards the destination and the other \"backwards\" from the destination towards the origin. This algorithm has better performance then the A* algorithm since it more effectively cuts the search space. However, there are some complexities added to handle the backwards progression from the destination to the origin. Turn restrictions and transition costing is more complicated. Also, the determination of the connection point between the two searches (determination of route completion) is more complex. Another strength of the bidirectional A* method is that hierarchy transitions near the destination are simplified. Currently bidirectional A* performs only invariant behaviour of traffic update, there is no algorithm implemented for correct evaluation of edge passing time. Pedestrian and bicycle routes use just the local graph hierarchy. They never transition to the arterial or highway levels and thus never use shortcut edges. The bidirectional A* algorithm makes use of edge markings that enter regions where no through path exists. These are areas of the routing graph that represent cul-de-sas, dead-end roads, and even larger communities where there is only one entrance. The search paths can exclude ever entering an edge that is marked as \"not-though\".","title":"Bidirectional A*"},{"location":"thor/path-algorithm/#multi-modal","text":"Multi-modal routes use an A* method that is enahanced to allow time-dependency and mode changes. Public transit information includes schedule information that find the next departure along directed edges between transit stops. Unique pairs of transit stops and routes create separate graph edges with a unique line-id to which departure schedules can be associated.","title":"Multi-modal"},{"location":"thor/path-algorithm/#a-heuristic","text":"A simple class within Thor handles the A* heuristic computation. At the beginning of PathAlgorithm::GetBestPath the A* heuristic is initialized with the latitude, longitude of the destination and a costing factor to multiply distance estimates with. This factor needs to be tied to the costing model to multiply distance that will underestimate the cost to the destination, but keep close to a reasonable true cost so that performance is kept high. For example, in automobile costing the factor is based on the highest speed expected - thus any straight line distance estimate from a specific location will undersestimate the true cost on any path on real roads to get to the destination. Distance estimates are computed using a distance approximation method that computes a Euclidean distance using meters per degree of latitude and an estimate of meters per degree of longitude based on the destination latitude. This produces a close approximation of the arc distance along the surface of the earth while providing a distance measure that is locally stable (nearby locations will get consistent and close distance approximations).","title":"A* Heuristic"},{"location":"thor/path-algorithm/#edge-labeling","text":"Thor marks directed edges in the routing graph rather than nodes. This allows a node to be traversed multiple times in a route with different directed edges. This allows turn restrictions to be incorporated into the data and the path algorithm. This is demonstrated in the following example where a left turn is not allowed at an intersection. Rather the route must take a separate turn lane to the right and loop back through the intersection. The least cost path to the intersection node is to proceed straight. If the node were marked it would prevent traversing the node after using the turn lane since that path is higher cost. Each directed edge in the routing graph can have three states: Not Visited - An edge that is not visited has not yet been encountered within the PathAlgorithm graph traversal. Temporary - An edge that has been visited or encountered but there could still be a lower cost path to this edge. This edge will be \"adjacent\" or connected to an edge that is permanently labeled. Temporary edges are noted in the Adjacency List and are sorted such that they are \"expanded\" in order of lowest cost. Permanent - Lowest cost path to this edge has been found. Edges that have been visited are stored in a vector with an EdgeLabel structure that contains information about the path up to this edge. In particular the predecessor edge is stored. This allows the shortest path of directed edges to be constructed by using each edges predecessor information to walk the path backwards. Additional information about the path to get to the directed edge is also kept. This information includes: Edge Id - Graph Id of the edge. Opposing edge Id - Graph Id of the opposing edge (for bidirectional A*). End node - GraphId of the end node of the edge. This allows the expansion to occur by reading the node and not having to re-read the directed edge to find its end node. Cost - Cost and elapsed time in seconds along the path to this edge. Sort cost - Cost including includes A* heuristic. Distance - An estimate of the straight line distance to the destination. Predecessor edge - Index to the predecessor edge label information within the EdgeLabels list. Several other pieces of information about the prior edge are also kept to avoid having to re-read an edge. In addition, several transit specific attributes are added for multi-modal routes.","title":"Edge Labeling"},{"location":"thor/path-algorithm/#edge-status","text":"An unordered map (hash map) is used to identify the state of directed edges. The map contains tile id as key and array of EdgeStatusInfo which contains index of the edge in the EdgeLabels vector and the current edge label state: kUnreachedOrReset, temporary or permanent. Whenever a new tile (new edge in previously unvisited tile) is encountered a new value in the map is inserted with key as tile id and EdgeStatusInfo array of length equal to number of directed edges in the tile as value, all directed edges in the new array are initialized with kUnreachedOrReset status. The index of edge in EdgeStatusInfo array is equal to it's id in the tile EdgeStatus is constructed given an initial size of the edge status map. To avoid rehashing the initial size should be large enough. Set - Sets the status of a directed edge given its GraphId. Update - Updates the status of a directed edge given its GraphId. Get - Gets the status info of a directed edge given its GraphId.","title":"Edge Status"},{"location":"thor/path-algorithm/#adjacency-list","text":"The AdjacencyList class provides a sorting order to the edge labels that are marked as temporary and are adjacent to edges that have lowest cost path found. The adjacency list uses a bucket sort implementation for performance. An \"overflow\" bucket is maintained to allow reduced memory use - costs outside the current bucket range get placed into the overflow bucket and are moved into the low-level buckets as needed. The adjacency list stores indexes into a list (vector) of labels where complete cost and predecessor information are stored. The adjacency list simply provides a fast sorting method. Benchmarks show a marked improvement over using an STL priority_queue, even in cases where the overflow bucket is utilized. An AdjacencyList is contructed using a minimum cost (based on the A* heuristic distance from the origin location to the destination location), a range of costs held within the bucket sort, and a bucket size. All costs above mincost + range are stored in an \"overflow\" bucket. The following methods are provided in the AdjacencyList class: Add - Adds a label index to the sorted list. Adds it to the appropriate bucket given the sort cost. If the sortcost is greater than maxcost_ the label is placed in the overflow bucket. If the sortcost is < the current bucket cost then the label is placed at the front of the current bucket (this prevents underflow). DecreaseCost - The specified label index now has a smaller cost. Reorders it in the sorted bucket list. Clear - Clear all labels from from the adjacency list. Called at the start of the path finding algorithm, Remove - Removes the lowest cost label index from the sorted list. EmptyOverflow - Empties the overflow bucket by placing the label indexes into the low level buckets. This method is private and is called from the Remove method when needed.","title":"Adjacency List"},{"location":"thor/simple_traffic/","text":"Traffic Influenced Routing - Proof of Concept \u00b6 While Valhalla does not support traffic influenced routing at the current time, the tiled routing graph design and dynamic costing methods used by Valhalla should readily support integration of both real-time and historical traffic or speed information. This paper describes a proof of concept that was developed to demonstrated traffic-influenced routing. The proof of concept allows entry of speeds for a set of OpenStreetMap (OSM) ways. These ways are then correlated with Valhalla graph edges to generate a set of \"speed tiles\". These speed tiles can be thought of as \"lookaside\" speed tables which are used by Valhalla dynamic costing methods to produce traffic-influenced routes. The proof of concept shows how route paths change and estimated times for the route increase in the presence of congestion. Speed Tiles \u00b6 A key method used in the proof of concept is to create speed tiles that correlate to the existing Valhalla graph edges. The speed data is stored in a 1:1 correlation to each graph edge. This allows easy and efficient access of speed data using the existing Valhalla graph Ids that index each graph edge. Storing dynamic speed data separately from the static graph tile data also allows the dynamic speed information to be read, cached, and updated separately without impacting the more static routing tiles. The dynamic speed data is much smaller than the static graph tiles and can readily be updated and read as new routes are created. Valhalla graph tiles can remain cached. Speeds can be represented using a single byte per graph edge. This allows speeds from 0 to 255 kph. A specific value (e.g., 0) is used to indicate that no real-time speed exists for the edge and that the speed must be read from the Valhalla graph tile, which maintains a speed for each graph edge derived from the OSM max_speed tag or approximated based on the OSM highway tag. The proof of concept only considered real-time speed information which meant only a single speed is maintained for each edge. Historical speed data could also be supported as a set of speeds for specific time periods for each graph edge. For example, 168 different speed values could be stored to indicate the average speed along a road segment for each hour of the week. Historical speed data would be more static - it would not be updated every several minutes but could be read in and cached just as the Valhalla graph tiles are. Historical speed data can be used to provide time-dependent speed information that shows expected traffic patterns like rush hour commuting patterns vs. mid-day weekend traffic patterns. Associating Way Ids to Valhalla Edges \u00b6 One possible means of specifying speed or traffic information is to associate a current speed to an OSM way. This provides an easy method of adding speed data to Valhalla. An association of way Ids to Valhalla graph Ids was created for the traffic proof of concept. This was stored as a simple CSV (comma separated values) file listing the OSM way Id and the Valhalla graph Ids of the directed edges and their direction (forward or backward) along the way. A simple process was created to read a CSV file of way Ids with a forward direction speed and a reverse direction speed along the way. This process associated the way Ids to Valhalla directed edges and stored the corresponding speeds in a real-time speed file for each Valhalla tile where edges had real-time speeds were specified. This Valhalla real-time speed tile simply stores an array of speeds in a one to one correlation to the directed edges in the tile. If a directed edge did not have any speed assigned (the majority of edges) then a value of 0 was used to indicate no speed exists. Using real-time speed tiles in this manner allows the real-time speed to be accessed using the same Valhalla graph Id as the directed edge. For the proof of concept the process that assigns speed to OSM ways, and thus Valhalla graph edges, was executed prior to running the Valhalla server so that the real-time speeds were populated and usable by Valhalla routing. Caching of the real-time speed data was implemented only on a per route basis. This meant that each new route would load real-time speed tiles that it needed. This allowed the proof of concept to inject updated speed information and then re-run a route and see the impact of the new or additional real-time speeds. The proof of concept involved a manual entry of speed information, it was in no way automated or using real traffic data. The purpose was to prove a method of influencing Valhalla routes using auxiliary speed tiles. Methods to ingest traffic information and automatically create speed tiles was outside the scope of the proof of concept. The downside of using OSM way Ids for traffic specification is that OSM ways can very long or very short. This can lead to difficulties when trying to localize congestion. OSM ways are often defined in such a way that manual addition or editing of a road is simplified. They often span many intersections or a long stretch of highway. When this happens, a single speed will become assigned to many graph edges and there is no way to represent variaiblity of speed along the way. Conversely, OSM ways can be very short and represent only a small portion of a road between two intersections or can represent a small overpass on a highway. In this case it becomes difficult to assign speeds to many of these short OSM ways, leading to gaps in speed coverage. Dynamic Costing with Traffic \u00b6 Valhalla uses dynamic, run-time costing when computing route paths. Costing methods often use speed and edge length to compute time as the costing parameter and thus create least-time routes. Currently the speed used in these computations comes from OSM max_speed tags or from a speed assigned based on highway tags (if no max_speed tag is present). A custom, dynamic costing method was created for the traffic proof of concept. This costing method uses real-time speeds if available and falls back to the OSM assigned speeds if not available. The proof of concept did not consider how to handle edge transition costs. These are costs to traverse intersections and are used to approximate time spent stopped or waiting at intersections. With real-time traffic information many of these transition costs become part of the real-time speed for a segment of road that may traverse several intersections. It is likely that when good real-time speed coverage is available that the edge transitions costing will need to be updated to lessen the impact of transition costs and thus rely more on the real-time speed data. Example \u00b6 The following images show an example of traffic influenced routing with Valhalla using the proof of concept described above. The examples below all use a former commuting route that I took from Elkridge, Maryland to the Applied Physics Laboratory near Laurel, Maryland. The first image shows the route without any traffic influence. The main part of the path takes I-95 South to MD-32 West to US-29 South with an estimated time of 17 minutes. Using the OSM way Ids along I-95 South, I created real-time speed tiles that set a current speed of 45 kph along I-95 South. With the dynamic costing method using the adjusted real-time speed data along I-95 the resulting new route detoured to take US-1 South to MD-32 West to US-29 South. US-1 has a lower speed limit and more intersections, so this route takes an estimated 19 minutes. This is shown in Figure 2. Using the OSM way Ids along US-1 South, I added real-time speeds of 40 kph along US-1 in addition to the reduced speeds along I-95 South. With the updated real-time speed tiles and dynamic costing the new route follows local roads to MD-100 West to US-29 South. This route takes and estimated 22 minutes and is longer distance as well. These examples show what you would expect as traffic worsens - the optimal route path may become longer distance and may take some lower class roads to find a detour. The time to reach the destination increases as the initial shortest time path becomes slower due to traffic. Figure 1; Commute Route without Real-Time Traffic Figure 2: Commute Route with Reduced Real-Time Speeds along I-95 South Figure 3: Commute Route with Reduced Real-Time Speeds along I-95 South and US-1 South Suitability of Valhalla for Traffic Integration \u00b6 Valhalla's tiled data structures should work well for potential traffic integration. First and foremost, tiling allows for efficient distribution of regional sets of speed data and also allows distributed processing of traffic data based on tiles. The concept of \"look-aside\" speed tiles has several advantages: Easy and rapid access using the same indexes as the Valhalla graph edges. Small data size for real-time speeds. This is crucial since real-time speeds will need to be updated frequently to provide a robust and current routing solution in presence of traffic. Latency and delay in updating current speeds needs to be kept to a minimum in a responsive traffic-influenced routing system. Small data size for dynamic speed data also makes for more efficient access during route computation as less data needs to be read from disk and cached. The one major disadvantage of the stratefy of using look-aside speed tiles is that the speed tiles need to be matched to a specific Valhalla routing tile data set. Valhalla graph Ids are not persistent and depend on the data import process, so speed tiles need to be matched to a specific Valhalla data set so that indexes (graph Ids) match. Work remains to be done to produce production-worthy, traffic-influenced routing within Valhalla. Here are some considerations and possibilities that we are considering. Highway Hierarchies \u00b6 Valhalla creates highway hierarchies in a manner similar to how roads are often presented at different zoom-levels in a map. The local hierarchy corresponds to the highest zoom levels where all roads and paths are stored or displayed. The arterial hierarchy removes residential roads, service roads, cycleways, walking paths, and other lower-class roads not generally used except when near the route origin or destination location. This is similar to a map at a middle zoom level. The highway hierarchy only includes motorways, trunks, and (currently) primary roads. This is similar to the lower zoom levels of a map where only important, higher classification roads are shown. In addition to the grouping of graph nodes and edges into the highway hierarchy, the arterial and highway hierarchy levels also contain \"shortcut edges\" that bypass any nodes that only connect to lower hierarchy level edges. This creates efficiency when computing long routes. For the proof of concept, real-time speeds were only assigned to edges on the local graph hierarchy and thus were not assigned to shortcut edges. Since shortcut edges generally connect or combine edges with different OSM way Ids, the mapping of way Ids to Valhalla graph edges becomes more complicated. We have left this mapping for future efforts if needed. Alternatively, a referencing system such as OpenLR might be used to associate traffic information to Valhalla routing edges. This has many advantages which we expect to investigate in the future. Possible Optimizations Using Highway Hierarchies \u00b6 We are considering a shift in the way Valhalla stores the routing graph in separate highway hierarchies. There is currently duplication of edges across different highway hierarchies. For example, a motorway edge is stored in all 3 hierarchies: local, arterial, and highway. This has some nice properties when used in a bidirectional, A* algorithm. In particular, the search paths only need to transition upwards in the hierarchy (from local to arterial to highway) and never needs to transition downwards. The 2 search paths meet in the middle, usually on the highway hierarchy for any driving route. Pedestrian and bicycle routes never transition upwards, they only traverse the local hierarchy. If Valhalla were to store each edge only on the hierarchy level which it lies then this duplication would be removed. This reduces the total size of the Valhalla graph tiles and should lead to reduced memory use as well. For traffic integration this may have even more impact. If speed data is only provided for the arterial and highway hierarchies this would greatly reduce the number of traffic tiles required to support traffic and also would reduce the total size of any speed lookaside tiles. This seems like a reasonable assumption - residential roads, service roads, parking areas, and especially cycleways and walkways do not generally need traffic data as speeds are usually consistent and traffic volumes are usually too low to generate enough probe data to get meaningful traffic information. This type of change to the Valhalla routing graph will need to be developed, validated, and tested to make sure routing performance and quality remains high. However, this idea seems promising and is worth pursuing as we move forward with traffic investigation and integration. Keep watch for traffic integration work in the future!","title":"Simple traffic"},{"location":"thor/simple_traffic/#traffic-influenced-routing-proof-of-concept","text":"While Valhalla does not support traffic influenced routing at the current time, the tiled routing graph design and dynamic costing methods used by Valhalla should readily support integration of both real-time and historical traffic or speed information. This paper describes a proof of concept that was developed to demonstrated traffic-influenced routing. The proof of concept allows entry of speeds for a set of OpenStreetMap (OSM) ways. These ways are then correlated with Valhalla graph edges to generate a set of \"speed tiles\". These speed tiles can be thought of as \"lookaside\" speed tables which are used by Valhalla dynamic costing methods to produce traffic-influenced routes. The proof of concept shows how route paths change and estimated times for the route increase in the presence of congestion.","title":"Traffic Influenced Routing - Proof of Concept"},{"location":"thor/simple_traffic/#speed-tiles","text":"A key method used in the proof of concept is to create speed tiles that correlate to the existing Valhalla graph edges. The speed data is stored in a 1:1 correlation to each graph edge. This allows easy and efficient access of speed data using the existing Valhalla graph Ids that index each graph edge. Storing dynamic speed data separately from the static graph tile data also allows the dynamic speed information to be read, cached, and updated separately without impacting the more static routing tiles. The dynamic speed data is much smaller than the static graph tiles and can readily be updated and read as new routes are created. Valhalla graph tiles can remain cached. Speeds can be represented using a single byte per graph edge. This allows speeds from 0 to 255 kph. A specific value (e.g., 0) is used to indicate that no real-time speed exists for the edge and that the speed must be read from the Valhalla graph tile, which maintains a speed for each graph edge derived from the OSM max_speed tag or approximated based on the OSM highway tag. The proof of concept only considered real-time speed information which meant only a single speed is maintained for each edge. Historical speed data could also be supported as a set of speeds for specific time periods for each graph edge. For example, 168 different speed values could be stored to indicate the average speed along a road segment for each hour of the week. Historical speed data would be more static - it would not be updated every several minutes but could be read in and cached just as the Valhalla graph tiles are. Historical speed data can be used to provide time-dependent speed information that shows expected traffic patterns like rush hour commuting patterns vs. mid-day weekend traffic patterns.","title":"Speed Tiles"},{"location":"thor/simple_traffic/#associating-way-ids-to-valhalla-edges","text":"One possible means of specifying speed or traffic information is to associate a current speed to an OSM way. This provides an easy method of adding speed data to Valhalla. An association of way Ids to Valhalla graph Ids was created for the traffic proof of concept. This was stored as a simple CSV (comma separated values) file listing the OSM way Id and the Valhalla graph Ids of the directed edges and their direction (forward or backward) along the way. A simple process was created to read a CSV file of way Ids with a forward direction speed and a reverse direction speed along the way. This process associated the way Ids to Valhalla directed edges and stored the corresponding speeds in a real-time speed file for each Valhalla tile where edges had real-time speeds were specified. This Valhalla real-time speed tile simply stores an array of speeds in a one to one correlation to the directed edges in the tile. If a directed edge did not have any speed assigned (the majority of edges) then a value of 0 was used to indicate no speed exists. Using real-time speed tiles in this manner allows the real-time speed to be accessed using the same Valhalla graph Id as the directed edge. For the proof of concept the process that assigns speed to OSM ways, and thus Valhalla graph edges, was executed prior to running the Valhalla server so that the real-time speeds were populated and usable by Valhalla routing. Caching of the real-time speed data was implemented only on a per route basis. This meant that each new route would load real-time speed tiles that it needed. This allowed the proof of concept to inject updated speed information and then re-run a route and see the impact of the new or additional real-time speeds. The proof of concept involved a manual entry of speed information, it was in no way automated or using real traffic data. The purpose was to prove a method of influencing Valhalla routes using auxiliary speed tiles. Methods to ingest traffic information and automatically create speed tiles was outside the scope of the proof of concept. The downside of using OSM way Ids for traffic specification is that OSM ways can very long or very short. This can lead to difficulties when trying to localize congestion. OSM ways are often defined in such a way that manual addition or editing of a road is simplified. They often span many intersections or a long stretch of highway. When this happens, a single speed will become assigned to many graph edges and there is no way to represent variaiblity of speed along the way. Conversely, OSM ways can be very short and represent only a small portion of a road between two intersections or can represent a small overpass on a highway. In this case it becomes difficult to assign speeds to many of these short OSM ways, leading to gaps in speed coverage.","title":"Associating Way Ids to Valhalla Edges"},{"location":"thor/simple_traffic/#dynamic-costing-with-traffic","text":"Valhalla uses dynamic, run-time costing when computing route paths. Costing methods often use speed and edge length to compute time as the costing parameter and thus create least-time routes. Currently the speed used in these computations comes from OSM max_speed tags or from a speed assigned based on highway tags (if no max_speed tag is present). A custom, dynamic costing method was created for the traffic proof of concept. This costing method uses real-time speeds if available and falls back to the OSM assigned speeds if not available. The proof of concept did not consider how to handle edge transition costs. These are costs to traverse intersections and are used to approximate time spent stopped or waiting at intersections. With real-time traffic information many of these transition costs become part of the real-time speed for a segment of road that may traverse several intersections. It is likely that when good real-time speed coverage is available that the edge transitions costing will need to be updated to lessen the impact of transition costs and thus rely more on the real-time speed data.","title":"Dynamic Costing with Traffic"},{"location":"thor/simple_traffic/#example","text":"The following images show an example of traffic influenced routing with Valhalla using the proof of concept described above. The examples below all use a former commuting route that I took from Elkridge, Maryland to the Applied Physics Laboratory near Laurel, Maryland. The first image shows the route without any traffic influence. The main part of the path takes I-95 South to MD-32 West to US-29 South with an estimated time of 17 minutes. Using the OSM way Ids along I-95 South, I created real-time speed tiles that set a current speed of 45 kph along I-95 South. With the dynamic costing method using the adjusted real-time speed data along I-95 the resulting new route detoured to take US-1 South to MD-32 West to US-29 South. US-1 has a lower speed limit and more intersections, so this route takes an estimated 19 minutes. This is shown in Figure 2. Using the OSM way Ids along US-1 South, I added real-time speeds of 40 kph along US-1 in addition to the reduced speeds along I-95 South. With the updated real-time speed tiles and dynamic costing the new route follows local roads to MD-100 West to US-29 South. This route takes and estimated 22 minutes and is longer distance as well. These examples show what you would expect as traffic worsens - the optimal route path may become longer distance and may take some lower class roads to find a detour. The time to reach the destination increases as the initial shortest time path becomes slower due to traffic. Figure 1; Commute Route without Real-Time Traffic Figure 2: Commute Route with Reduced Real-Time Speeds along I-95 South Figure 3: Commute Route with Reduced Real-Time Speeds along I-95 South and US-1 South","title":"Example"},{"location":"thor/simple_traffic/#suitability-of-valhalla-for-traffic-integration","text":"Valhalla's tiled data structures should work well for potential traffic integration. First and foremost, tiling allows for efficient distribution of regional sets of speed data and also allows distributed processing of traffic data based on tiles. The concept of \"look-aside\" speed tiles has several advantages: Easy and rapid access using the same indexes as the Valhalla graph edges. Small data size for real-time speeds. This is crucial since real-time speeds will need to be updated frequently to provide a robust and current routing solution in presence of traffic. Latency and delay in updating current speeds needs to be kept to a minimum in a responsive traffic-influenced routing system. Small data size for dynamic speed data also makes for more efficient access during route computation as less data needs to be read from disk and cached. The one major disadvantage of the stratefy of using look-aside speed tiles is that the speed tiles need to be matched to a specific Valhalla routing tile data set. Valhalla graph Ids are not persistent and depend on the data import process, so speed tiles need to be matched to a specific Valhalla data set so that indexes (graph Ids) match. Work remains to be done to produce production-worthy, traffic-influenced routing within Valhalla. Here are some considerations and possibilities that we are considering.","title":"Suitability of Valhalla for Traffic Integration"},{"location":"thor/simple_traffic/#highway-hierarchies","text":"Valhalla creates highway hierarchies in a manner similar to how roads are often presented at different zoom-levels in a map. The local hierarchy corresponds to the highest zoom levels where all roads and paths are stored or displayed. The arterial hierarchy removes residential roads, service roads, cycleways, walking paths, and other lower-class roads not generally used except when near the route origin or destination location. This is similar to a map at a middle zoom level. The highway hierarchy only includes motorways, trunks, and (currently) primary roads. This is similar to the lower zoom levels of a map where only important, higher classification roads are shown. In addition to the grouping of graph nodes and edges into the highway hierarchy, the arterial and highway hierarchy levels also contain \"shortcut edges\" that bypass any nodes that only connect to lower hierarchy level edges. This creates efficiency when computing long routes. For the proof of concept, real-time speeds were only assigned to edges on the local graph hierarchy and thus were not assigned to shortcut edges. Since shortcut edges generally connect or combine edges with different OSM way Ids, the mapping of way Ids to Valhalla graph edges becomes more complicated. We have left this mapping for future efforts if needed. Alternatively, a referencing system such as OpenLR might be used to associate traffic information to Valhalla routing edges. This has many advantages which we expect to investigate in the future.","title":"Highway Hierarchies"},{"location":"thor/simple_traffic/#possible-optimizations-using-highway-hierarchies","text":"We are considering a shift in the way Valhalla stores the routing graph in separate highway hierarchies. There is currently duplication of edges across different highway hierarchies. For example, a motorway edge is stored in all 3 hierarchies: local, arterial, and highway. This has some nice properties when used in a bidirectional, A* algorithm. In particular, the search paths only need to transition upwards in the hierarchy (from local to arterial to highway) and never needs to transition downwards. The 2 search paths meet in the middle, usually on the highway hierarchy for any driving route. Pedestrian and bicycle routes never transition upwards, they only traverse the local hierarchy. If Valhalla were to store each edge only on the hierarchy level which it lies then this duplication would be removed. This reduces the total size of the Valhalla graph tiles and should lead to reduced memory use as well. For traffic integration this may have even more impact. If speed data is only provided for the arterial and highway hierarchies this would greatly reduce the number of traffic tiles required to support traffic and also would reduce the total size of any speed lookaside tiles. This seems like a reasonable assumption - residential roads, service roads, parking areas, and especially cycleways and walkways do not generally need traffic data as speeds are usually consistent and traffic volumes are usually too low to generate enough probe data to get meaningful traffic information. This type of change to the Valhalla routing graph will need to be developed, validated, and tested to make sure routing performance and quality remains high. However, this idea seems promising and is worth pursuing as we move forward with traffic investigation and integration. Keep watch for traffic integration work in the future!","title":"Possible Optimizations Using Highway Hierarchies"}]}